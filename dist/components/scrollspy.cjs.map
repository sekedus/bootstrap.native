{"version":3,"file":"scrollspy.cjs","sources":["../../src/strings/scrollspyString.ts","../../src/strings/scrollspyComponent.ts","../../src/components/scrollspy.ts"],"sourcesContent":["/** @type {string} */\nconst scrollspyString = \"scrollspy\";\nexport default scrollspyString;\n","/** @type {string} */\nconst scrollspyComponent = \"ScrollSpy\";\nexport default scrollspyComponent;\n","/* Native JavaScript for Bootstrap 5 | ScrollSpy\n------------------------------------------------ */\nimport {\n  addClass,\n  createCustomEvent,\n  dispatchEvent,\n  getAttribute,\n  getBoundingClientRect,\n  getDocument,\n  getDocumentBody,\n  getDocumentElement,\n  getElementsByTagName,\n  getInstance,\n  hasClass,\n  isHTMLElement,\n  querySelector,\n  removeClass,\n} from \"@thednp/shorty\";\n\nimport PositionObserver from \"@thednp/position-observer\";\n\nimport activeClass from \"../strings/activeClass\";\nimport scrollspyString from \"../strings/scrollspyString\";\nimport scrollspyComponent from \"../strings/scrollspyComponent\";\n\nimport BaseComponent from \"./base-component\";\nimport { ScrollSpyEvent, ScrollSpyOptions } from \"../interface/scrollspy\";\n\n// SCROLLSPY PRIVATE GC\n// ====================\nconst scrollspySelector = '[data-bs-spy=\"scroll\"]';\n\nconst scrollspyDefaults: ScrollSpyOptions = {\n  offset: 10,\n  target: null,\n};\n\ntype ScrollSpyEventProps = {\n  relatedTarget: HTMLElement;\n};\n\n/**\n * Static method which returns an existing `ScrollSpy` instance associated\n * to a target `Element`.\n */\nconst getScrollSpyInstance = (element: HTMLElement) =>\n  getInstance<ScrollSpy>(element, scrollspyComponent);\n\n/**\n * A `ScrollSpy` initialization callback.\n */\nconst scrollspyInitCallback = (element: HTMLElement) => new ScrollSpy(element);\n\n// SCROLLSPY CUSTOM EVENT\n// ======================\nconst activateScrollSpy = createCustomEvent<\n  ScrollSpyEventProps,\n  ScrollSpyEvent\n>(`activate.bs.${scrollspyString}`);\n\n// SCROLLSPY PRIVATE METHODS\n// =========================\n/**\n * Update the state of all items.\n *\n * @param self the `ScrollSpy` instance\n */\nconst updateSpyTargets = (self: ScrollSpy) => {\n  const { target, scrollTarget, options, itemsLength, scrollHeight, element } =\n    self;\n  const { offset } = options;\n  const isRoot = scrollTarget !== element;\n\n  const links = target && getElementsByTagName(\"A\", target);\n  const doc = getDocument(element);\n  const scrollHEIGHT = scrollTarget.scrollHeight;\n\n  self.scrollTop = scrollTarget.scrollTop;\n\n  // only update items/offsets once or with each mutation\n  // istanbul ignore else @preserve\n  if (\n    links && (scrollHEIGHT !== scrollHeight || itemsLength !== links.length)\n  ) {\n    let href;\n    let targetItem;\n    let rect;\n\n    // reset arrays & update\n    self.items = [];\n    self.targets = [];\n    self.offsets = [];\n    self.scrollHeight = scrollHEIGHT;\n    self.maxScroll = self.scrollHeight - getOffsetHeight(self);\n\n    Array.from(links).forEach((link) => {\n      href = getAttribute(link, \"href\");\n      targetItem = href && href.charAt(0) === \"#\" && href.slice(-1) !== \"#\" &&\n        querySelector(href, doc);\n\n      if (targetItem) {\n        self.items.push(link);\n        self.targets.push(targetItem);\n        rect = getBoundingClientRect(targetItem);\n        self.offsets.push(\n          (isRoot ? rect.top + self.scrollTop : targetItem.offsetTop) - offset,\n        );\n      }\n    });\n    self.itemsLength = self.items.length;\n  }\n};\n\n/**\n * Toggles on/off the component observer.\n *\n * @param self the ScrollSpy instance\n * @param add when `true`, listener is added\n */\nconst toggleObservers = (\n  { targets, scrollTarget, element, _observer }: ScrollSpy,\n  add?: boolean,\n) => {\n  if (add) {\n    if (scrollTarget === element) {\n      targets.forEach((targetItem) => _observer.observe(targetItem));\n    } else {\n      _observer.observe(element);\n    }\n  } else _observer.disconnect();\n};\n\n/**\n * Returns the `scrollHeight` property of the scrolling element.\n *\n * @param scrollTarget the `ScrollSpy` instance\n * @return `scrollTarget` height\n */\nconst getScrollHeight = (scrollTarget: HTMLElement) => {\n  return scrollTarget.scrollHeight;\n};\n\n/**\n * Returns the height property of the scrolling element.\n *\n * @param params the `ScrollSpy` instance\n */\nconst getOffsetHeight = ({ element, scrollTarget }: ScrollSpy) => {\n  return scrollTarget !== element\n    ? scrollTarget.clientHeight\n    : getBoundingClientRect(element).height;\n};\n\n/**\n * Clear all items of the target.\n *\n * @param target a single item\n */\nconst clear = (target: HTMLElement) => {\n  [...getElementsByTagName(\"A\", target)].forEach((item) => {\n    if (hasClass(item, activeClass)) removeClass(item, activeClass);\n  });\n};\n\n/**\n * Activates a new item.\n *\n * @param self the `ScrollSpy` instance\n * @param item a single item\n */\nconst activate = (self: ScrollSpy, item: HTMLElement) => {\n  const { target, element } = self;\n\n  // istanbul ignore else @preserve\n  if (isHTMLElement(target)) clear(target);\n\n  self.activeItem = item;\n  addClass(item, activeClass);\n\n  // activate all parents\n  const parents: HTMLElement[] = [];\n  let parentItem = item;\n  while (parentItem !== getDocumentBody(element)) {\n    parentItem = parentItem.parentElement as HTMLElement;\n    if (hasClass(parentItem, \"nav\") || hasClass(parentItem, \"dropdown-menu\")) {\n      parents.push(parentItem);\n    }\n  }\n\n  parents.forEach((menuItem) => {\n    const parentLink = menuItem.previousElementSibling as HTMLElement | null;\n\n    // istanbul ignore else @preserve\n    if (parentLink && !hasClass(parentLink, activeClass)) {\n      addClass(parentLink, activeClass);\n    }\n  });\n\n  // dispatch\n  activateScrollSpy.relatedTarget = item;\n  dispatchEvent(element, activateScrollSpy);\n};\n\n// SCROLLSPY DEFINITION\n// ====================\n/** Returns a new `ScrollSpy` instance. */\nexport default class ScrollSpy extends BaseComponent {\n  static selector = scrollspySelector;\n  static init = scrollspyInitCallback;\n  static getInstance = getScrollSpyInstance;\n  declare options: ScrollSpyOptions;\n  declare target: HTMLElement | null;\n  declare scrollTarget: HTMLElement;\n  declare scrollTop: number;\n  declare maxScroll: number;\n  declare scrollHeight: number;\n  declare activeItem: HTMLElement | null;\n  declare items: HTMLElement[];\n  declare targets: HTMLElement[];\n  declare itemsLength: number;\n  declare offsets: number[];\n  declare _observer: PositionObserver;\n\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(\n    target: HTMLElement | string,\n    config?: Partial<ScrollSpyOptions>,\n  ) {\n    super(target, config);\n\n    // initialization element & options\n    const { element, options } = this;\n\n    // additional properties\n    this.target = querySelector(\n      options.target as HTMLElement | string,\n      getDocument(element),\n    );\n\n    // invalidate\n    if (this.target) {\n      // set initial state\n      this.scrollTarget = element.clientHeight < element.scrollHeight\n        ? element\n        : getDocumentElement(element);\n      this.scrollHeight = getScrollHeight(this.scrollTarget);\n\n      // run an initial burst, we need to know the targets\n      this.refresh();\n\n      // create observer\n      this._observer = new PositionObserver(() => this.refresh(), {\n        root: this.scrollTarget,\n      });\n\n      // add event handlers\n      toggleObservers(this, true);\n    }\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return scrollspyComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return scrollspyDefaults;\n  }\n  /* eslint-enable */\n\n  // SCROLLSPY PUBLIC METHODS\n  // ========================\n  /** Updates all items. */\n  refresh = () => {\n    const { target } = this;\n\n    // check if target is visible and invalidate\n    // istanbul ignore else @preserve\n    if (isHTMLElement(target) && target.offsetHeight > 0) {\n      updateSpyTargets(this);\n\n      const { scrollTop, maxScroll, itemsLength, items, activeItem } = this;\n\n      if (scrollTop >= maxScroll) {\n        const newActiveItem = items[itemsLength - 1];\n\n        // istanbul ignore else @preserve\n        if (activeItem !== newActiveItem) {\n          activate(this, newActiveItem);\n        }\n        return;\n      }\n\n      const { offsets } = this;\n\n      // istanbul ignore else @preserve\n      if (activeItem && scrollTop < offsets[0] && offsets[0] > 0) {\n        this.activeItem = null;\n        // istanbul ignore else @preserve\n        if (target) clear(target);\n        return;\n      }\n\n      items.forEach((item, i) => {\n        if (\n          activeItem !== item &&\n          scrollTop >= offsets[i] &&\n          (typeof offsets[i + 1] === \"undefined\" || scrollTop < offsets[i + 1])\n        ) {\n          activate(this, item);\n        }\n      });\n    }\n  };\n\n  /** Removes `ScrollSpy` from the target element. */\n  dispose() {\n    const clone = { ...this };\n    toggleObservers(clone);\n    super.dispose();\n  }\n}\n"],"names":["scrollspyString","scrollspyComponent","scrollspySelector","scrollspyDefaults","getScrollSpyInstance","element","getInstance","scrollspyInitCallback","ScrollSpy","activateScrollSpy","createCustomEvent","updateSpyTargets","self","target","scrollTarget","options","itemsLength","scrollHeight","offset","isRoot","links","getElementsByTagName","doc","getDocument","scrollHEIGHT","href","targetItem","rect","getOffsetHeight","link","getAttribute","querySelector","getBoundingClientRect","toggleObservers","targets","_observer","add","getScrollHeight","clear","item","hasClass","activeClass","removeClass","activate","isHTMLElement","addClass","parents","parentItem","getDocumentBody","menuItem","parentLink","dispatchEvent","BaseComponent","config","getDocumentElement","PositionObserver","scrollTop","maxScroll","items","activeItem","newActiveItem","offsets","i","clone"],"mappings":"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"}