{"version":3,"file":"carousel.mjs","sources":["../../src/strings/carouselString.ts","../../src/strings/carouselComponent.ts","../../src/components/carousel.ts"],"sourcesContent":["/** @type {string} */\nconst carouselString = 'carousel';\nexport default carouselString;\n","/** @type {string} */\nconst carouselComponent = 'Carousel';\nexport default carouselComponent;\n","/* Native JavaScript for Bootstrap 5 | Carousel\n----------------------------------------------- */\nimport {\n  addClass,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  dragstartEvent,\n  emulateTransitionEnd,\n  getAttribute,\n  getDocument,\n  getElementsByClassName,\n  getElementTransitionDuration,\n  getInstance,\n  hasClass,\n  isElementInScrollRange,\n  isHTMLElement,\n  isRTL,\n  keyArrowLeft,\n  keyArrowRight,\n  keydownEvent,\n  matches,\n  mouseclickEvent,\n  mouseenterEvent,\n  mouseleaveEvent,\n  ObjectAssign,\n  passiveHandler,\n  pointerdownEvent,\n  pointermoveEvent,\n  pointerupEvent,\n  querySelector,\n  querySelectorAll,\n  reflow,\n  removeClass,\n  Timer,\n  touchstartEvent,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport activeClass from '../strings/activeClass';\nimport dataBsTarget from '../strings/dataBsTarget';\nimport carouselString from '../strings/carouselString';\nimport carouselComponent from '../strings/carouselComponent';\nimport getTargetElement from '../util/getTargetElement';\nimport BaseComponent from './base-component';\nimport type { CarouselEvent, CarouselOptions } from '../interface/carousel';\n\ntype CarouselEventProperties = {\n  relatedTarget: HTMLElement;\n  from: number;\n  to: number;\n  direction: 'left' | 'right';\n};\n\n// CAROUSEL PRIVATE GC\n// ===================\nconst carouselSelector = `[data-bs-ride=\"${carouselString}\"]`;\nconst carouselItem = `${carouselString}-item`;\nconst dataBsSlideTo = 'data-bs-slide-to';\nconst dataBsSlide = 'data-bs-slide';\nconst pausedClass = 'paused';\n\nconst carouselDefaults: CarouselOptions = {\n  pause: 'hover',\n  keyboard: false,\n  touch: true,\n  interval: 5000,\n};\n\n/**\n * Static method which returns an existing `Carousel` instance associated\n * to a target `Element`.\n */\nconst getCarouselInstance = (element: HTMLElement) => getInstance<Carousel>(element, carouselComponent);\n\n/**\n * A `Carousel` initialization callback.\n */\nconst carouselInitCallback = (element: HTMLElement) => new Carousel(element);\n\nlet startX = 0;\nlet currentX = 0;\nlet endX = 0;\n\n// CAROUSEL CUSTOM EVENTS\n// ======================\nconst carouselSlideEvent = createCustomEvent<CarouselEventProperties, CarouselEvent>(`slide.bs.${carouselString}`);\nconst carouselSlidEvent = createCustomEvent<CarouselEventProperties, CarouselEvent>(`slid.bs.${carouselString}`);\n\n// CAROUSEL EVENT HANDLERS\n// =======================\n/**\n * The `transitionend` event listener of the `Carousel`.\n *\n * @param self the `Carousel` instance\n */\nconst carouselTransitionEndHandler = (self: Carousel) => {\n  const { index, direction, element, slides, options } = self;\n\n  // istanbul ignore else @preserve\n  if (self.isAnimating) {\n    const activeItem = getActiveIndex(self);\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    addClass(slides[index], activeClass);\n    removeClass(slides[index], `${carouselItem}-${orientation}`);\n    removeClass(slides[index], `${carouselItem}-${directionClass}`);\n\n    removeClass(slides[activeItem], activeClass);\n    removeClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n    dispatchEvent(element, carouselSlidEvent);\n    Timer.clear(element, dataBsSlide);\n\n    // must check if a previous instance is disposed\n    if (self.cycle && !getDocument(element).hidden && options.interval && !self.isPaused) {\n      self.cycle();\n    }\n  }\n};\n\n/**\n * Handles the `mouseenter` events when *options.pause*\n * is set to `hover`.\n */\nfunction carouselPauseHandler(this: HTMLElement) {\n  const self = getCarouselInstance(this);\n  // istanbul ignore else @preserve\n  if (self && !self.isPaused && !Timer.get(this, pausedClass)) {\n    addClass(this, pausedClass);\n  }\n}\n\n/**\n * Handles the `mouseleave` events when *options.pause*\n * is set to `hover`.\n */\nfunction carouselResumeHandler(this: HTMLElement) {\n  const self = getCarouselInstance(this);\n  // istanbul ignore else @preserve\n  if (self && self.isPaused && !Timer.get(this, pausedClass)) {\n    self.cycle();\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` indicators.\n *\n * @param e the `Event` object\n */\nfunction carouselIndicatorHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  const element = (closest(this, carouselSelector) || getTargetElement(this)) as HTMLElement;\n  const self = getCarouselInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self && !self.isAnimating) {\n    const newIndex = +(\n      getAttribute(this, dataBsSlideTo) ||\n      // istanbul ignore next @preserve\n      0\n    );\n\n    // istanbul ignore else @preserve\n    if (\n      this &&\n      !hasClass(this, activeClass) && // event target is not active\n      !Number.isNaN(newIndex)\n    ) {\n      // AND has the specific attribute\n      self.to(newIndex); // do the slide\n    }\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` arrows.\n *\n * @param e the `Event` object\n */\nfunction carouselControlsHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  const element = closest(this, carouselSelector) || (getTargetElement(this) as HTMLElement);\n  const self = getCarouselInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self && !self.isAnimating) {\n    const orientation = getAttribute(this, dataBsSlide);\n\n    // istanbul ignore else @preserve\n    if (orientation === 'next') {\n      self.next();\n    } else if (orientation === 'prev') {\n      self.prev();\n    }\n  }\n}\n\n/**\n * Handles the keyboard `keydown` event for the visible `Carousel` elements.\n *\n * @param e the `Event` object\n */\nconst carouselKeyHandler = ({ code, target }: KeyboardEvent & { target: Node }) => {\n  const doc = getDocument(target);\n  const [element] = [...querySelectorAll(carouselSelector, doc)].filter(x => isElementInScrollRange(x));\n  const self = getCarouselInstance(element);\n\n  // istanbul ignore next @preserve\n  if (self && !self.isAnimating && !/textarea|input/i.test(target.nodeName)) {\n    const RTL = isRTL(element);\n    const arrowKeyNext = !RTL ? keyArrowRight : keyArrowLeft;\n    const arrowKeyPrev = !RTL ? keyArrowLeft : keyArrowRight;\n\n    // istanbul ignore else @preserve\n    if (code === arrowKeyPrev) self.prev();\n    else if (code === arrowKeyNext) self.next();\n  }\n};\n\n// CAROUSEL TOUCH HANDLERS\n// =======================\n/**\n * Prevents the `touchstart` and `dragstart` events for the `Carousel` element.\n *\n * @param e the `Event` object\n */\nfunction carouselDragHandler(this: HTMLElement, e: DragEvent | TouchEvent) {\n  const { target } = e;\n  const self = getCarouselInstance(this);\n\n  // istanbul ignore next @preserve\n  if (\n    self &&\n    self.isTouch &&\n    ((self.indicator && !self.indicator.contains(target as Node)) || !self.controls.includes(target as HTMLElement))\n  ) {\n    e.stopImmediatePropagation();\n    e.stopPropagation();\n    e.preventDefault();\n  }\n}\n\n// CAROUSEL POINTER HANDLERS\n// =========================\n/**\n * Handles the `pointerdown` event for the `Carousel` element.\n *\n * @param e the `Event` object\n */\nfunction carouselPointerDownHandler(this: HTMLElement, e: PointerEvent) {\n  const { target } = e;\n  const self = getCarouselInstance(this);\n\n  // istanbul ignore else @preserve\n  if (self && !self.isAnimating && !self.isTouch) {\n    // filter pointer event on controls & indicators\n    const { controls, indicators } = self;\n    // istanbul ignore else @preserve\n    if (![...controls, ...indicators].every(el => el === target || el.contains(target as Node))) {\n      startX = e.pageX;\n\n      // istanbul ignore else @preserve\n      if (this.contains(target as Node)) {\n        self.isTouch = true;\n        toggleCarouselTouchHandlers(self, true);\n      }\n    }\n  }\n}\n\n/**\n * Handles the `pointermove` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerMoveHandler = (e: PointerEvent) => {\n  currentX = e.pageX;\n};\n\n/**\n * Handles the `pointerup` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerUpHandler = (e: PointerEvent) => {\n  const { target } = e;\n  const doc = getDocument(target as Node);\n  const self = [...querySelectorAll(carouselSelector, doc)]\n    .map(c => getCarouselInstance(c) as Carousel)\n    .find(i => i.isTouch) as Carousel;\n\n  // impossible to satisfy\n  // istanbul ignore else @preserve\n  if (self) {\n    const { element, index } = self;\n    const RTL = isRTL(element);\n    endX = e.pageX;\n\n    self.isTouch = false;\n    toggleCarouselTouchHandlers(self);\n\n    if (\n      !doc.getSelection()?.toString().length &&\n      element.contains(target as HTMLElement) &&\n      Math.abs(startX - endX) > 120\n    ) {\n      // determine next index to slide to\n      // istanbul ignore else @preserve\n      if (currentX < startX) {\n        self.to(index + (RTL ? -1 : 1));\n      } else if (currentX > startX) {\n        self.to(index + (RTL ? 1 : -1));\n      }\n    }\n\n    // reset pointer position\n    startX = 0;\n    currentX = 0;\n    endX = 0;\n  }\n};\n\n// CAROUSEL PRIVATE METHODS\n// ========================\n/**\n * Sets active indicator for the `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param index the index of the new active indicator\n */\nconst activateCarouselIndicator = (self: Carousel, index: number) => {\n  const { indicators } = self;\n  [...indicators].forEach(x => removeClass(x, activeClass));\n\n  // istanbul ignore else @preserve\n  if (self.indicators[index]) addClass(indicators[index], activeClass);\n};\n\n/**\n * Toggles the pointer event listeners for a given `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param add when `TRUE` event listeners are added\n */\nconst toggleCarouselTouchHandlers = (self: Carousel, add?: boolean) => {\n  const { element } = self;\n  const action = add ? addListener : removeListener;\n  action(getDocument(element), pointermoveEvent, carouselPointerMoveHandler, passiveHandler);\n  action(getDocument(element), pointerupEvent, carouselPointerUpHandler, passiveHandler);\n};\n\n/**\n * Returns the index of the current active item.\n *\n * @param self the `Carousel` instance\n * @returns the query result\n */\nconst getActiveIndex = (self: Carousel) => {\n  const { slides, element } = self;\n  const activeItem = querySelector(`.${carouselItem}.${activeClass}`, element);\n  return isHTMLElement(activeItem) ? [...slides].indexOf(activeItem) : -1;\n};\n\n// CAROUSEL DEFINITION\n// ===================\n/** Creates a new `Carousel` instance. */\nexport default class Carousel extends BaseComponent {\n  static selector = carouselSelector;\n  static init = carouselInitCallback;\n  static getInstance = getCarouselInstance;\n  declare options: CarouselOptions;\n  declare direction: 'right' | 'left';\n  declare index: number;\n  declare isTouch: boolean;\n  declare slides: HTMLCollectionOf<HTMLElement>;\n  declare controls: HTMLElement[];\n  declare indicator: HTMLElement | null;\n  declare indicators: HTMLElement[];\n\n  /**\n   * @param target mostly a `.carousel` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<CarouselOptions>) {\n    super(target, config);\n\n    // initialization element\n    const { element } = this;\n\n    // additional properties\n    this.direction = isRTL(element) ? 'right' : 'left';\n    this.isTouch = false;\n\n    // carousel elements\n    // a LIVE collection is prefferable\n    this.slides = getElementsByClassName(carouselItem, element);\n    const { slides } = this;\n\n    // invalidate when not enough items\n    // no need to go further\n    if (slides.length >= 2) {\n      const activeIndex = getActiveIndex(this);\n      // recover item from disposed instance\n      const transitionItem = [...slides].find(s => matches(s, `.${carouselItem}-next,.${carouselItem}-next`));\n      this.index = activeIndex;\n\n      // external controls must be within same document context\n      const doc = getDocument(element);\n\n      this.controls = [\n        ...querySelectorAll(`[${dataBsSlide}]`, element),\n        ...querySelectorAll(`[${dataBsSlide}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n      ].filter((c, i, ar) => i === ar.indexOf(c));\n\n      this.indicator = querySelector(`.${carouselString}-indicators`, element);\n\n      // a LIVE collection is prefferable\n      this.indicators = [\n        ...(this.indicator\n          ? querySelectorAll(`[${dataBsSlideTo}]`, this.indicator)\n          : // istanbul ignore next @preserve\n            []),\n        ...querySelectorAll(`[${dataBsSlideTo}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n      ].filter((c, i, ar) => i === ar.indexOf(c));\n\n      // set JavaScript and DATA API options\n      const { options } = this;\n\n      // don't use TRUE as interval, it's actually 0, use the default 5000ms better\n      this.options.interval = options.interval === true ? carouselDefaults.interval : options.interval;\n\n      // set first slide active if none\n      // istanbul ignore next @preserve - impossible to test\n      if (transitionItem) {\n        this.index = [...slides].indexOf(transitionItem);\n      } else if (activeIndex < 0) {\n        this.index = 0;\n        addClass(slides[0], activeClass);\n        if (this.indicators.length) activateCarouselIndicator(this, 0);\n      }\n\n      // istanbul ignore else @preserve\n      if (this.indicators.length) activateCarouselIndicator(this, this.index);\n\n      // attach event handlers\n      this._toggleEventListeners(true);\n\n      // start to cycle if interval is set\n      if (options.interval) this.cycle();\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return carouselComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return carouselDefaults;\n  }\n\n  /**\n   * Check if instance is paused.\n   */\n  get isPaused() {\n    return hasClass(this.element, pausedClass);\n  }\n\n  /**\n   * Check if instance is animating.\n   */\n  get isAnimating() {\n    return querySelector(`.${carouselItem}-next,.${carouselItem}-prev`, this.element) !== null;\n  }\n\n  // CAROUSEL PUBLIC METHODS\n  // =======================\n  /** Slide automatically through items. */\n  cycle() {\n    const { element, options, isPaused, index } = this;\n\n    Timer.clear(element, carouselString);\n    if (isPaused) {\n      Timer.clear(element, pausedClass);\n      removeClass(element, pausedClass);\n    }\n\n    Timer.set(\n      element,\n      () => {\n        // it's very important to check self.element\n        // where instance might have been disposed\n        // istanbul ignore else @preserve\n        if (this.element && !this.isPaused && !this.isTouch && isElementInScrollRange(element)) {\n          this.to(index + 1);\n        }\n      },\n      options.interval as number,\n      carouselString,\n    );\n  }\n\n  /** Pause the automatic cycle. */\n  pause() {\n    const { element, options } = this;\n    // istanbul ignore else @preserve\n    if (!this.isPaused && options.interval) {\n      addClass(element, pausedClass);\n      Timer.set(\n        element,\n        () => {\n          /* ESLint is now happy */\n        },\n        1,\n        pausedClass,\n      );\n    }\n  }\n\n  /** Slide to the next item. */\n  next() {\n    // istanbul ignore else @preserve\n    if (!this.isAnimating) {\n      this.to(this.index + 1);\n    }\n  }\n\n  /** Slide to the previous item. */\n  prev() {\n    // istanbul ignore else @preserve\n    if (!this.isAnimating) {\n      this.to(this.index - 1);\n    }\n  }\n\n  /**\n   * Jump to the item with the `idx` index.\n   *\n   * @param idx the index of the item to jump to\n   */\n  to(idx: number) {\n    const { element, slides, options } = this;\n    const activeItem = getActiveIndex(this);\n    const RTL = isRTL(element);\n    let next = idx;\n\n    // when controled via methods, make sure to check again\n    // first return if we're on the same item #227\n    // `to()` must be SPAM protected by Timer\n    if (!this.isAnimating && activeItem !== next && !Timer.get(element, dataBsSlide)) {\n      // determine transition direction\n      // istanbul ignore else @preserve\n      if (activeItem < next || (activeItem === 0 && next === slides.length - 1)) {\n        this.direction = RTL ? 'right' : 'left'; // next\n      } else if (activeItem > next || (activeItem === slides.length - 1 && next === 0)) {\n        this.direction = RTL ? 'left' : 'right'; // prev\n      }\n      const { direction } = this;\n\n      // find the right next index\n      if (next < 0) {\n        next = slides.length - 1;\n      } else if (next >= slides.length) {\n        next = 0;\n      }\n\n      // orientation, class name, eventProperties\n      const orientation = direction === 'left' ? 'next' : 'prev';\n      const directionClass = direction === 'left' ? 'start' : 'end';\n\n      const eventProperties = {\n        relatedTarget: slides[next],\n        from: activeItem,\n        to: next,\n        direction,\n      };\n\n      // update event properties\n      ObjectAssign(carouselSlideEvent, eventProperties);\n      ObjectAssign(carouselSlidEvent, eventProperties);\n\n      // discontinue when prevented\n      dispatchEvent(element, carouselSlideEvent);\n      if (!carouselSlideEvent.defaultPrevented) {\n        // update index\n        this.index = next;\n        activateCarouselIndicator(this, next);\n\n        if (getElementTransitionDuration(slides[next]) && hasClass(element, 'slide')) {\n          Timer.set(\n            element,\n            () => {\n              addClass(slides[next], `${carouselItem}-${orientation}`);\n              reflow(slides[next]);\n              addClass(slides[next], `${carouselItem}-${directionClass}`);\n              addClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n              // the instance might get diposed mid-animation\n              emulateTransitionEnd(\n                slides[next],\n                () => this.slides && this.slides.length && carouselTransitionEndHandler(this),\n              );\n            },\n            0,\n            dataBsSlide,\n          );\n        } else {\n          addClass(slides[next], activeClass);\n          removeClass(slides[activeItem], activeClass);\n\n          Timer.set(\n            element,\n            () => {\n              Timer.clear(element, dataBsSlide);\n              // check for element, might have been disposed\n              // istanbul ignore else @preserve\n              if (element && options.interval && !this.isPaused) {\n                this.cycle();\n              }\n\n              dispatchEvent(element, carouselSlidEvent);\n            },\n            0,\n            dataBsSlide,\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Toggles all event listeners for the `Carousel` instance.\n   *\n   * @param add when `TRUE` event listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const { element, options, slides, controls, indicators } = this;\n    const { touch, pause, interval, keyboard } = options;\n    const action = add ? addListener : removeListener;\n\n    if (pause && interval) {\n      action(element, mouseenterEvent, carouselPauseHandler);\n      action(element, mouseleaveEvent, carouselResumeHandler);\n    }\n\n    if (touch && slides.length > 2) {\n      action(element, pointerdownEvent, carouselPointerDownHandler, passiveHandler);\n      action(element, touchstartEvent, carouselDragHandler, { passive: false });\n      action(element, dragstartEvent, carouselDragHandler, { passive: false });\n    }\n\n    // istanbul ignore else @preserve\n    if (controls.length) {\n      controls.forEach(arrow => {\n        // istanbul ignore else @preserve\n        if (arrow) action(arrow, mouseclickEvent, carouselControlsHandler);\n      });\n    }\n\n    // istanbul ignore else @preserve\n    if (indicators.length) {\n      indicators.forEach(indicator => {\n        action(indicator, mouseclickEvent, carouselIndicatorHandler);\n      });\n    }\n\n    if (keyboard) {\n      action(getDocument(element), keydownEvent, carouselKeyHandler);\n    }\n  };\n\n  /** Remove `Carousel` component from target. */\n  dispose() {\n    const { isAnimating } = this;\n\n    const clone = {\n      ...this,\n      isAnimating,\n    };\n    this._toggleEventListeners();\n    super.dispose();\n\n    // istanbul ignore next @preserve - impossible to test\n    if (clone.isAnimating) {\n      emulateTransitionEnd(clone.slides[clone.index], () => {\n        carouselTransitionEndHandler(clone);\n      });\n    }\n  }\n}\n"],"names":["carouselString","carouselComponent","carouselSelector","carouselItem","dataBsSlideTo","dataBsSlide","pausedClass","carouselDefaults","getCarouselInstance","element","getInstance","carouselInitCallback","Carousel","startX","currentX","endX","carouselSlideEvent","createCustomEvent","carouselSlidEvent","carouselTransitionEndHandler","self","index","direction","slides","options","activeItem","getActiveIndex","orientation","directionClass","addClass","activeClass","removeClass","dispatchEvent","Timer","getDocument","carouselPauseHandler","carouselResumeHandler","carouselIndicatorHandler","e","closest","getTargetElement","newIndex","getAttribute","hasClass","carouselControlsHandler","carouselKeyHandler","code","target","doc","querySelectorAll","x","isElementInScrollRange","RTL","isRTL","arrowKeyNext","keyArrowLeft","keyArrowRight","arrowKeyPrev","carouselDragHandler","carouselPointerDownHandler","controls","indicators","el","toggleCarouselTouchHandlers","carouselPointerMoveHandler","carouselPointerUpHandler","c","i","_a","activateCarouselIndicator","add","action","addListener","removeListener","pointermoveEvent","passiveHandler","pointerupEvent","querySelector","isHTMLElement","BaseComponent","config","__publicField","touch","pause","interval","keyboard","mouseenterEvent","mouseleaveEvent","pointerdownEvent","touchstartEvent","dragstartEvent","arrow","mouseclickEvent","indicator","keydownEvent","getElementsByClassName","activeIndex","transitionItem","s","matches","dataBsTarget","ar","isPaused","idx","next","eventProperties","ObjectAssign","getElementTransitionDuration","reflow","emulateTransitionEnd","isAnimating","clone"],"mappings":"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"}