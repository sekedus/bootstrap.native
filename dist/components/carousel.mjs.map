{"version":3,"file":"carousel.mjs","sources":["../../src/strings/carouselString.ts","../../src/strings/carouselComponent.ts","../../src/components/carousel.ts"],"sourcesContent":["/** @type {string} */\nconst carouselString = 'carousel';\nexport default carouselString;\n","/** @type {string} */\nconst carouselComponent = 'Carousel';\nexport default carouselComponent;\n","/* Native JavaScript for Bootstrap 5 | Carousel\n----------------------------------------------- */\nimport {\n  createCustomEvent,\n  getInstance,\n  dispatchEvent,\n  ObjectAssign,\n  emulateTransitionEnd,\n  passiveHandler,\n  reflow,\n  Timer,\n  getAttribute,\n  getElementsByClassName,\n  querySelectorAll,\n  querySelector,\n  closest,\n  isHTMLElement,\n  isRTL,\n  isElementInScrollRange,\n  getElementTransitionDuration,\n  getDocument,\n  pointerupEvent,\n  pointermoveEvent,\n  pointerdownEvent,\n  keyArrowRight,\n  keyArrowLeft,\n  keydownEvent,\n  mouseclickEvent,\n  mouseleaveEvent,\n  mouseenterEvent,\n  addClass,\n  hasClass,\n  removeClass,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport activeClass from '../strings/activeClass';\nimport dataBsTarget from '../strings/dataBsTarget';\nimport carouselString from '../strings/carouselString';\nimport carouselComponent from '../strings/carouselComponent';\nimport getTargetElement from '../util/getTargetElement';\nimport BaseComponent from './base-component';\nimport type { CarouselEvent, CarouselOptions } from '../interface/carousel';\n\n// CAROUSEL PRIVATE GC\n// ===================\nconst carouselSelector = `[data-bs-ride=\"${carouselString}\"]`;\nconst carouselItem = `${carouselString}-item`;\nconst dataBsSlideTo = 'data-bs-slide-to';\nconst dataBsSlide = 'data-bs-slide';\nconst pausedClass = 'paused';\n\nconst carouselDefaults: CarouselOptions = {\n  pause: 'hover',\n  keyboard: false,\n  touch: true,\n  interval: 5000,\n};\n\n/**\n * Static method which returns an existing `Carousel` instance associated\n * to a target `Element`.\n */\nconst getCarouselInstance = (element: HTMLElement) => getInstance<Carousel>(element, carouselComponent);\n\n/**\n * A `Carousel` initialization callback.\n */\nconst carouselInitCallback = (element: HTMLElement) => new Carousel(element);\n\nlet startX = 0;\nlet currentX = 0;\nlet endX = 0;\n\n// CAROUSEL CUSTOM EVENTS\n// ======================\nconst carouselSlideEvent = createCustomEvent<CarouselEvent>(`slide.bs.${carouselString}`);\nconst carouselSlidEvent = createCustomEvent<CarouselEvent>(`slid.bs.${carouselString}`);\n\n// CAROUSEL EVENT HANDLERS\n// =======================\n/**\n * The `transitionend` event listener of the `Carousel`.\n *\n * @param self the `Carousel` instance\n */\nconst carouselTransitionEndHandler = (self: Carousel) => {\n  const { index, direction, element, slides, options } = self;\n\n  // discontinue disposed instances\n  /* istanbul ignore else */\n  if (self.isAnimating && getCarouselInstance(element)) {\n    const activeItem = getActiveIndex(self);\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    addClass(slides[index], activeClass);\n    removeClass(slides[index], `${carouselItem}-${orientation}`);\n    removeClass(slides[index], `${carouselItem}-${directionClass}`);\n\n    removeClass(slides[activeItem], activeClass);\n    removeClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n    dispatchEvent(element, carouselSlidEvent);\n    Timer.clear(element, dataBsSlide);\n\n    // check for element, might have been disposed\n    if (!getDocument(element).hidden && options.interval && !self.isPaused) {\n      self.cycle();\n    }\n  }\n};\n\n/**\n * Handles the `mouseenter` events when *options.pause*\n * is set to `hover`.\n */\nfunction carouselPauseHandler(this: HTMLElement) {\n  // const element = this;\n  const self = getCarouselInstance(this);\n  /* istanbul ignore else */\n  if (self && !self.isPaused && !Timer.get(this, pausedClass)) {\n    addClass(this, pausedClass);\n  }\n}\n\n/**\n * Handles the `mouseleave` events when *options.pause*\n * is set to `hover`.\n *\n */\nfunction carouselResumeHandler(this: HTMLElement) {\n  // const element = this;\n  const self = getCarouselInstance(this);\n  /* istanbul ignore else */\n  if (self && self.isPaused && !Timer.get(this, pausedClass)) {\n    self.cycle();\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` indicators.\n *\n * @param e the `Event` object\n */\nfunction carouselIndicatorHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  // const indicator = this;\n  const element = (closest(this, carouselSelector) || getTargetElement(this)) as HTMLElement;\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isAnimating) return;\n\n  const newIndex = +(getAttribute(this, dataBsSlideTo) || 0);\n\n  if (\n    this &&\n    !hasClass(this, activeClass) && // event target is not active\n    !Number.isNaN(newIndex)\n  ) {\n    // AND has the specific attribute\n    self.to(newIndex); // do the slide\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` arrows.\n *\n * @param e the `Event` object\n */\nfunction carouselControlsHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  // const control = this;\n  const element = closest(this, carouselSelector) || (getTargetElement(this) as HTMLElement);\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isAnimating) return;\n  const orientation = getAttribute(this, dataBsSlide);\n\n  /* istanbul ignore else */\n  if (orientation === 'next') {\n    self.next();\n  } else if (orientation === 'prev') {\n    self.prev();\n  }\n}\n\n/**\n * Handles the keyboard `keydown` event for the visible `Carousel` elements.\n *\n * @param e the `Event` object\n */\nconst carouselKeyHandler = ({ code, target }: KeyboardEvent & { target: Node }) => {\n  const doc = getDocument(target);\n  const [element] = [...querySelectorAll(carouselSelector, doc)].filter(x => isElementInScrollRange(x));\n  const self = getCarouselInstance(element);\n\n  /* istanbul ignore next */\n  if (!self || self.isAnimating || /textarea|input/i.test(target.nodeName)) return;\n  const RTL = isRTL(element);\n  const arrowKeyNext = !RTL ? keyArrowRight : keyArrowLeft;\n  const arrowKeyPrev = !RTL ? keyArrowLeft : keyArrowRight;\n\n  /* istanbul ignore else */\n  if (code === arrowKeyPrev) self.prev();\n  else if (code === arrowKeyNext) self.next();\n};\n\n// CAROUSEL TOUCH HANDLERS\n// =======================\n/**\n * Handles the `pointerdown` event for the `Carousel` element.\n *\n * @param e the `Event` object\n */\nfunction carouselPointerDownHandler(this: HTMLElement, e: PointerEvent) {\n  // const element = this;\n  const { target } = e;\n  const self = getCarouselInstance(this);\n\n  if (!self || self.isAnimating || self.isTouch) {\n    return;\n  }\n\n  // filter pointer event on controls & indicators\n  const { controls, indicators } = self;\n  if ([...controls, ...indicators].some(el => el === target || el.contains(target as Node))) {\n    return;\n  }\n\n  startX = e.pageX;\n\n  /* istanbul ignore else */\n  if (this.contains(target as Node)) {\n    self.isTouch = true;\n    toggleCarouselTouchHandlers(self, true);\n  }\n}\n\n/**\n * Handles the `pointermove` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerMoveHandler = (e: PointerEvent) => {\n  currentX = e.pageX;\n};\n\n/**\n * Handles the `pointerup` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerUpHandler = (e: PointerEvent) => {\n  const { target } = e;\n  const doc = getDocument(target as Node);\n  const self = [...querySelectorAll(carouselSelector, doc)]\n    .map(c => getCarouselInstance(c) as Carousel)\n    .find(i => i.isTouch) as Carousel;\n\n  // impossible to satisfy\n  /* istanbul ignore next */\n  if (!self) {\n    return;\n  }\n\n  const { element, index } = self;\n  const RTL = isRTL(element);\n\n  self.isTouch = false;\n  toggleCarouselTouchHandlers(self);\n\n  if (doc.getSelection()?.toString().length) {\n    // reset pointer position\n    startX = 0;\n    currentX = 0;\n    endX = 0;\n    return;\n  }\n\n  endX = e.pageX;\n\n  // the event target is outside the carousel context\n  // OR swipe distance is less than 120px\n  /* istanbul ignore else */\n  if (!element.contains(target as HTMLElement) || Math.abs(startX - endX) < 120) {\n    // reset pointer position\n    startX = 0;\n    currentX = 0;\n    endX = 0;\n    return;\n  }\n  // OR determine next index to slide to\n  /* istanbul ignore else */\n  if (currentX < startX) {\n    self.to(index + (RTL ? -1 : 1));\n  } else if (currentX > startX) {\n    self.to(index + (RTL ? 1 : -1));\n  }\n  // reset pointer position\n  startX = 0;\n  currentX = 0;\n  endX = 0;\n};\n\n// CAROUSEL PRIVATE METHODS\n// ========================\n/**\n * Sets active indicator for the `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param pageIndex the index of the new active indicator\n */\nconst activateCarouselIndicator = (self: Carousel, pageIndex: number) => {\n  const { indicators } = self;\n  [...indicators].forEach(x => removeClass(x, activeClass));\n\n  /* istanbul ignore else */\n  if (self.indicators[pageIndex]) addClass(indicators[pageIndex], activeClass);\n};\n\n/**\n * Toggles the pointer event listeners for a given `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param add when `TRUE` event listeners are added\n */\nconst toggleCarouselTouchHandlers = (self: Carousel, add?: boolean) => {\n  const { element } = self;\n  const action = add ? addListener : removeListener;\n  action(getDocument(element), pointermoveEvent, carouselPointerMoveHandler as EventListener, passiveHandler);\n  action(getDocument(element), pointerupEvent, carouselPointerUpHandler as EventListener, passiveHandler);\n};\n\n/**\n * Toggles all event listeners for a given `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param add when `TRUE` event listeners are added\n */\nconst toggleCarouselHandlers = (self: Carousel, add?: boolean) => {\n  const { element, options, slides, controls, indicators } = self;\n  const { touch, pause, interval, keyboard } = options;\n  const action = add ? addListener : removeListener;\n\n  if (pause && interval) {\n    action(element, mouseenterEvent, carouselPauseHandler);\n    action(element, mouseleaveEvent, carouselResumeHandler);\n  }\n\n  if (touch && slides.length > 2) {\n    action(element, pointerdownEvent, carouselPointerDownHandler as EventListener, passiveHandler);\n  }\n\n  /* istanbul ignore else */\n  if (controls.length) {\n    controls.forEach(arrow => {\n      /* istanbul ignore else */\n      if (arrow) action(arrow, mouseclickEvent, carouselControlsHandler as EventListener);\n    });\n  }\n\n  /* istanbul ignore else */\n  if (indicators.length) {\n    indicators.forEach(indicator => {\n      action(indicator, mouseclickEvent, carouselIndicatorHandler as EventListener);\n    });\n  }\n\n  if (keyboard) action(getDocument(element), keydownEvent, carouselKeyHandler as EventListener);\n};\n\n/**\n * Returns the index of the current active item.\n *\n * @param self the `Carousel` instance\n * @returns the query result\n */\nconst getActiveIndex = (self: Carousel) => {\n  const { slides, element } = self;\n  const activeItem = querySelector(`.${carouselItem}.${activeClass}`, element);\n  return isHTMLElement(activeItem) ? [...slides].indexOf(activeItem) : -1;\n};\n\n// CAROUSEL DEFINITION\n// ===================\n/** Creates a new `Carousel` instance. */\nexport default class Carousel extends BaseComponent {\n  static selector = carouselSelector;\n  static init = carouselInitCallback;\n  static getInstance = getCarouselInstance;\n  declare options: CarouselOptions;\n  declare direction: 'right' | 'left';\n  declare index: number;\n  declare isTouch: boolean;\n  declare slides: HTMLCollectionOf<HTMLElement>;\n  declare controls: HTMLElement[];\n  declare indicator: HTMLElement | null;\n  declare indicators: HTMLElement[];\n\n  /**\n   * @param target mostly a `.carousel` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<CarouselOptions>) {\n    super(target, config);\n\n    // initialization element\n    const { element } = this;\n\n    // additional properties\n    this.direction = isRTL(element) ? 'right' : 'left';\n    this.index = 0;\n    this.isTouch = false;\n\n    // carousel elements\n    // a LIVE collection is prefferable\n    this.slides = getElementsByClassName(carouselItem, element);\n    const { slides } = this;\n\n    // invalidate when not enough items\n    // no need to go further\n    if (slides.length < 2) {\n      return;\n    }\n    // external controls must be within same document context\n    const doc = getDocument(element);\n\n    this.controls = [\n      ...querySelectorAll(`[${dataBsSlide}]`, element),\n      ...querySelectorAll(`[${dataBsSlide}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n    ];\n\n    this.indicator = querySelector(`.${carouselString}-indicators`, element);\n\n    // a LIVE collection is prefferable\n    this.indicators = [\n      ...(this.indicator ? querySelectorAll(`[${dataBsSlideTo}]`, this.indicator) : []),\n      ...querySelectorAll(`[${dataBsSlideTo}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n    ];\n\n    // set JavaScript and DATA API options\n    const { options } = this;\n\n    // don't use TRUE as interval, it's actually 0, use the default 5000ms better\n    this.options.interval = options.interval === true ? carouselDefaults.interval : options.interval;\n\n    // set first slide active if none\n    /* istanbul ignore else */\n    if (getActiveIndex(this) < 0) {\n      addClass(slides[0], activeClass);\n      /* istanbul ignore else */\n      if (this.indicators.length) activateCarouselIndicator(this, 0);\n    }\n\n    // attach event handlers\n    toggleCarouselHandlers(this, true);\n\n    // start to cycle if interval is set\n    if (options.interval) this.cycle();\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return carouselComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return carouselDefaults;\n  }\n\n  /**\n   * Check if instance is paused.\n   */\n  get isPaused() {\n    return hasClass(this.element, pausedClass);\n  }\n\n  /**\n   * Check if instance is animating.\n   */\n  get isAnimating() {\n    return querySelector(`.${carouselItem}-next,.${carouselItem}-prev`, this.element) !== null;\n  }\n\n  // CAROUSEL PUBLIC METHODS\n  // =======================\n  /** Slide automatically through items. */\n  cycle() {\n    const { element, options, isPaused, index } = this;\n\n    Timer.clear(element, carouselString);\n    if (isPaused) {\n      Timer.clear(element, pausedClass);\n      removeClass(element, pausedClass);\n    }\n\n    Timer.set(\n      element,\n      () => {\n        // it's very important to check self.element\n        // where instance might have been disposed\n        /* istanbul ignore else */\n        if (this.element && !this.isPaused && !this.isTouch && isElementInScrollRange(element)) {\n          this.to(index + 1);\n        }\n      },\n      options.interval as number,\n      carouselString,\n    );\n  }\n\n  /** Pause the automatic cycle. */\n  pause() {\n    const { element, options } = this;\n    /* istanbul ignore else */\n    if (!this.isPaused && options.interval) {\n      addClass(element, pausedClass);\n      Timer.set(\n        element,\n        () => {\n          /* ESLint is now happy */\n        },\n        1,\n        pausedClass,\n      );\n    }\n  }\n\n  /** Slide to the next item. */\n  next() {\n    /* istanbul ignore else */\n    if (!this.isAnimating) {\n      this.to(this.index + 1);\n    }\n  }\n\n  /** Slide to the previous item. */\n  prev() {\n    /* istanbul ignore else */\n    if (!this.isAnimating) {\n      this.to(this.index - 1);\n    }\n  }\n\n  /**\n   * Jump to the item with the `idx` index.\n   *\n   * @param idx the index of the item to jump to\n   */\n  to(idx: number) {\n    const { element, slides, options } = this;\n    const activeItem = getActiveIndex(this);\n    const RTL = isRTL(element);\n    let next = idx;\n\n    // when controled via methods, make sure to check again\n    // first return if we're on the same item #227\n    // `to()` must be SPAM protected by Timer\n    if (this.isAnimating || activeItem === next || Timer.get(element, dataBsSlide)) return;\n\n    // determine transition direction\n    /* istanbul ignore else */\n    if (activeItem < next || (activeItem === 0 && next === slides.length - 1)) {\n      this.direction = RTL ? 'right' : 'left'; // next\n    } else if (activeItem > next || (activeItem === slides.length - 1 && next === 0)) {\n      this.direction = RTL ? 'left' : 'right'; // prev\n    }\n    const { direction } = this;\n\n    // find the right next index\n    if (next < 0) {\n      next = slides.length - 1;\n    } else if (next >= slides.length) {\n      next = 0;\n    }\n\n    // orientation, class name, eventProperties\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    const eventProperties = {\n      relatedTarget: slides[next],\n      from: activeItem,\n      to: next,\n      direction,\n    };\n\n    // update event properties\n    ObjectAssign(carouselSlideEvent, eventProperties);\n    ObjectAssign(carouselSlidEvent, eventProperties);\n\n    // discontinue when prevented\n    dispatchEvent(element, carouselSlideEvent);\n    if (carouselSlideEvent.defaultPrevented) return;\n\n    // update index\n    this.index = next;\n    activateCarouselIndicator(this, next);\n\n    if (getElementTransitionDuration(slides[next]) && hasClass(element, 'slide')) {\n      Timer.set(\n        element,\n        () => {\n          addClass(slides[next], `${carouselItem}-${orientation}`);\n          reflow(slides[next]);\n          addClass(slides[next], `${carouselItem}-${directionClass}`);\n          addClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n          emulateTransitionEnd(slides[next], () => carouselTransitionEndHandler(this));\n        },\n        0,\n        dataBsSlide,\n      );\n    } else {\n      addClass(slides[next], activeClass);\n      removeClass(slides[activeItem], activeClass);\n\n      Timer.set(\n        element,\n        () => {\n          Timer.clear(element, dataBsSlide);\n          // check for element, might have been disposed\n          /* istanbul ignore else */\n          if (element && options.interval && !this.isPaused) {\n            this.cycle();\n          }\n\n          dispatchEvent(element, carouselSlidEvent);\n        },\n        0,\n        dataBsSlide,\n      );\n    }\n  }\n\n  /** Remove `Carousel` component from target. */\n  dispose() {\n    const { slides } = this;\n    const itemClasses = ['start', 'end', 'prev', 'next'];\n\n    [...slides].forEach((slide, idx) => {\n      if (hasClass(slide, activeClass)) activateCarouselIndicator(this, idx);\n      itemClasses.forEach(c => removeClass(slide, `${carouselItem}-${c}`));\n    });\n\n    toggleCarouselHandlers(this);\n    super.dispose();\n  }\n}\n"],"names":["carouselString","carouselComponent","carouselSelector","carouselItem","dataBsSlideTo","dataBsSlide","pausedClass","carouselDefaults","getCarouselInstance","element","getInstance","carouselInitCallback","Carousel","startX","currentX","endX","carouselSlideEvent","createCustomEvent","carouselSlidEvent","carouselTransitionEndHandler","self","index","direction","slides","options","activeItem","getActiveIndex","orientation","directionClass","addClass","activeClass","removeClass","dispatchEvent","Timer","getDocument","carouselPauseHandler","carouselResumeHandler","carouselIndicatorHandler","e","closest","getTargetElement","newIndex","getAttribute","hasClass","carouselControlsHandler","carouselKeyHandler","code","target","doc","querySelectorAll","x","isElementInScrollRange","RTL","isRTL","keyArrowRight","keyArrowLeft","carouselPointerDownHandler","controls","indicators","el","toggleCarouselTouchHandlers","carouselPointerMoveHandler","carouselPointerUpHandler","c","i","activateCarouselIndicator","pageIndex","add","action","addListener","removeListener","pointermoveEvent","passiveHandler","pointerupEvent","toggleCarouselHandlers","touch","pause","interval","keyboard","mouseenterEvent","mouseleaveEvent","pointerdownEvent","arrow","mouseclickEvent","indicator","keydownEvent","querySelector","isHTMLElement","BaseComponent","config","getElementsByClassName","dataBsTarget","isPaused","idx","next","eventProperties","ObjectAssign","getElementTransitionDuration","reflow","emulateTransitionEnd","itemClasses","slide"],"mappings":";;;;AACA,MAAMA,IAAiB,YCAjBC,IAAoB,YC8CpBC,IAAmB,kBAAkBF,OACrCG,IAAe,GAAGH,UAClBI,IAAgB,oBAChBC,IAAc,iBACdC,IAAc,UAEdC,IAAoC;AAAA,EACxC,OAAO;AAAA,EACP,UAAU;AAAA,EACV,OAAO;AAAA,EACP,UAAU;AACZ,GAMMC,IAAsB,CAACC,MAAyBC,GAAsBD,GAASR,CAAiB,GAKhGU,KAAuB,CAACF,MAAyB,IAAIG,GAASH,CAAO;AAE3E,IAAII,IAAS,GACTC,IAAW,GACXC,IAAO;AAIX,MAAMC,IAAqBC,EAAiC,YAAYjB,GAAgB,GAClFkB,IAAoBD,EAAiC,WAAWjB,GAAgB,GAShFmB,KAA+B,CAACC,MAAmB;AACvD,QAAM,EAAE,OAAAC,GAAO,WAAAC,GAAW,SAAAb,GAAS,QAAAc,GAAQ,SAAAC,EAAY,IAAAJ;AAIvD,MAAIA,EAAK,eAAeZ,EAAoBC,CAAO,GAAG;AAC9C,UAAAgB,IAAaC,EAAeN,CAAI,GAChCO,IAAcL,MAAc,SAAS,SAAS,QAC9CM,IAAiBN,MAAc,SAAS,UAAU;AAE/CO,IAAAA,EAAAN,EAAOF,IAAQS,CAAW,GACnCC,EAAYR,EAAOF,IAAQ,GAAGlB,KAAgBwB,GAAa,GAC3DI,EAAYR,EAAOF,IAAQ,GAAGlB,KAAgByB,GAAgB,GAElDG,EAAAR,EAAOE,IAAaK,CAAW,GAC3CC,EAAYR,EAAOE,IAAa,GAAGtB,KAAgByB,GAAgB,GAEnEI,EAAcvB,GAASS,CAAiB,GAClCe,EAAA,MAAMxB,GAASJ,CAAW,GAG5B,CAAC6B,EAAYzB,CAAO,EAAE,UAAUe,EAAQ,YAAY,CAACJ,EAAK,YAC5DA,EAAK,MAAM;AAAA,EAEf;AACF;AAMA,SAASe,KAAwC;AAEzC,QAAAf,IAAOZ,EAAoB,IAAI;AAEjC,EAAAY,KAAQ,CAACA,EAAK,YAAY,CAACa,EAAM,IAAI,MAAM3B,CAAW,KACxDuB,EAAS,MAAMvB,CAAW;AAE9B;AAOA,SAAS8B,KAAyC;AAE1C,QAAAhB,IAAOZ,EAAoB,IAAI;AAEjC,EAAAY,KAAQA,EAAK,YAAY,CAACa,EAAM,IAAI,MAAM3B,CAAW,KACvDc,EAAK,MAAM;AAEf;AAOA,SAASiB,GAA4CC,GAAe;AAClE,EAAAA,EAAE,eAAe;AAEjB,QAAM7B,IAAW8B,EAAQ,MAAMrC,CAAgB,KAAKsC,EAAiB,IAAI,GACnEpB,IAAOZ,EAAoBC,CAAO;AAEpC,MAAA,CAACW,KAAQA,EAAK;AAAa;AAE/B,QAAMqB,IAAW,EAAEC,EAAa,MAAMtC,CAAa,KAAK;AAGtD,EAAA,QACA,CAACuC,EAAS,MAAMb,CAAW,KAC3B,CAAC,OAAO,MAAMW,CAAQ,KAGtBrB,EAAK,GAAGqB,CAAQ;AAEpB;AAOA,SAASG,GAA2CN,GAAe;AACjE,EAAAA,EAAE,eAAe;AAEjB,QAAM7B,IAAU8B,EAAQ,MAAMrC,CAAgB,KAAMsC,EAAiB,IAAI,GACnEpB,IAAOZ,EAAoBC,CAAO;AAEpC,MAAA,CAACW,KAAQA,EAAK;AAAa;AACzB,QAAAO,IAAce,EAAa,MAAMrC,CAAW;AAGlD,EAAIsB,MAAgB,SAClBP,EAAK,KAAK,IACDO,MAAgB,UACzBP,EAAK,KAAK;AAEd;AAOA,MAAMyB,KAAqB,CAAC,EAAE,MAAAC,GAAM,QAAAC,QAA+C;AAC3E,QAAAC,IAAMd,EAAYa,CAAM,GACxB,CAACtC,CAAO,IAAI,CAAC,GAAGwC,EAAiB/C,GAAkB8C,CAAG,CAAC,EAAE,OAAO,CAAKE,MAAAC,EAAuBD,CAAC,CAAC,GAC9F9B,IAAOZ,EAAoBC,CAAO;AAGxC,MAAI,CAACW,KAAQA,EAAK,eAAe,kBAAkB,KAAK2B,EAAO,QAAQ;AAAG;AACpE,QAAAK,IAAMC,EAAM5C,CAAO;AAKzB,EAAIqC,OAHkBM,IAAqBE,IAAfC,KAGDnC,EAAK,KAAK,IAC5B0B,OALaM,IAAsBG,IAAhBD,MAKIlC,EAAK,KAAK;AAC5C;AASA,SAASoC,GAA8ClB,GAAiB;AAEhE,QAAA,EAAE,QAAAS,EAAW,IAAAT,GACblB,IAAOZ,EAAoB,IAAI;AAErC,MAAI,CAACY,KAAQA,EAAK,eAAeA,EAAK;AACpC;AAII,QAAA,EAAE,UAAAqC,GAAU,YAAAC,EAAe,IAAAtC;AACjC,EAAI,CAAC,GAAGqC,GAAU,GAAGC,CAAU,EAAE,KAAK,CAAMC,MAAAA,MAAOZ,KAAUY,EAAG,SAASZ,CAAc,CAAC,MAIxFlC,IAASyB,EAAE,OAGP,KAAK,SAASS,CAAc,MAC9B3B,EAAK,UAAU,IACfwC,EAA4BxC,GAAM,EAAI;AAE1C;AAOA,MAAMyC,KAA6B,CAACvB,MAAoB;AACtD,EAAAxB,IAAWwB,EAAE;AACf,GAOMwB,KAA2B,CAACxB,MAAoB;AAC9C,QAAA,EAAE,QAAAS,EAAW,IAAAT,GACbU,IAAMd,EAAYa,CAAc,GAChC3B,IAAO,CAAC,GAAG6B,EAAiB/C,GAAkB8C,CAAG,CAAC,EACrD,IAAI,CAAAe,MAAKvD,EAAoBuD,CAAC,CAAa,EAC3C,KAAK,CAAAC,MAAKA,EAAE,OAAO;AAItB,MAAI,CAAC5C;AACH;AAGI,QAAA,EAAE,SAAAX,GAAS,OAAAY,EAAU,IAAAD,GACrBgC,IAAMC,EAAM5C,CAAO;AAKzB,MAHAW,EAAK,UAAU,IACfwC,EAA4BxC,CAAI,GAE5B4B,EAAI,aAAA,GAAgB,SAAA,EAAW,QAAQ;AAEhC,IAAAnC,IAAA,GACEC,IAAA,GACJC,IAAA;AACP;AAAA,EACF;AAOI,MALJA,IAAOuB,EAAE,OAKL,CAAC7B,EAAQ,SAASsC,CAAqB,KAAK,KAAK,IAAIlC,IAASE,CAAI,IAAI,KAAK;AAEpE,IAAAF,IAAA,GACEC,IAAA,GACJC,IAAA;AACP;AAAA,EACF;AAGA,EAAID,IAAWD,IACbO,EAAK,GAAGC,KAAS+B,IAAM,KAAK,EAAE,IACrBtC,IAAWD,KACpBO,EAAK,GAAGC,KAAS+B,IAAM,IAAI,GAAG,GAGvBvC,IAAA,GACEC,IAAA,GACJC,IAAA;AACT,GAUMkD,IAA4B,CAAC7C,GAAgB8C,MAAsB;AACjE,QAAA,EAAE,YAAAR,EAAe,IAAAtC;AACtB,GAAA,GAAGsC,CAAU,EAAE,QAAQ,OAAK3B,EAAYmB,GAAGpB,CAAW,CAAC,GAGpDV,EAAK,WAAW8C,MAAqBrC,EAAA6B,EAAWQ,IAAYpC,CAAW;AAC7E,GAQM8B,IAA8B,CAACxC,GAAgB+C,MAAkB;AAC/D,QAAA,EAAE,SAAA1D,EAAY,IAAAW,GACdgD,IAASD,IAAME,IAAcC;AACnC,EAAAF,EAAOlC,EAAYzB,CAAO,GAAG8D,IAAkBV,IAA6CW,CAAc,GAC1GJ,EAAOlC,EAAYzB,CAAO,GAAGgE,IAAgBX,IAA2CU,CAAc;AACxG,GAQME,IAAyB,CAACtD,GAAgB+C,MAAkB;AAChE,QAAM,EAAE,SAAA1D,GAAS,SAAAe,GAAS,QAAAD,GAAQ,UAAAkC,GAAU,YAAAC,EAAe,IAAAtC,GACrD,EAAE,OAAAuD,GAAO,OAAAC,GAAO,UAAAC,GAAU,UAAAC,MAAatD,GACvC4C,IAASD,IAAME,IAAcC;AAEnC,EAAIM,KAASC,MACJT,EAAA3D,GAASsE,IAAiB5C,EAAoB,GAC9CiC,EAAA3D,GAASuE,IAAiB5C,EAAqB,IAGpDuC,KAASpD,EAAO,SAAS,KACpB6C,EAAA3D,GAASwE,IAAkBzB,IAA6CgB,CAAc,GAI3Ff,EAAS,UACXA,EAAS,QAAQ,CAASyB,MAAA;AAEpB,IAAAA,KAAcd,EAAAc,GAAOC,GAAiBvC,EAAwC;AAAA,EAAA,CACnF,GAICc,EAAW,UACbA,EAAW,QAAQ,CAAa0B,MAAA;AACvB,IAAAhB,EAAAgB,GAAWD,GAAiB9C,EAAyC;AAAA,EAAA,CAC7E,GAGCyC,KAAUV,EAAOlC,EAAYzB,CAAO,GAAG4E,IAAcxC,EAAmC;AAC9F,GAQMnB,IAAiB,CAACN,MAAmB;AACnC,QAAA,EAAE,QAAAG,GAAQ,SAAAd,EAAY,IAAAW,GACtBK,IAAa6D,EAAc,IAAInF,KAAgB2B,KAAerB,CAAO;AACpE,SAAA8E,GAAc9D,CAAU,IAAI,CAAC,GAAGF,CAAM,EAAE,QAAQE,CAAU,IAAI;AACvE;AAKA,MAAqBb,WAAiB4E,GAAc;AAAA,EAClD,OAAO,WAAWtF;AAAA,EAClB,OAAO,OAAOS;AAAA,EACd,OAAO,cAAcH;AAAA,EAcrB,YAAYuC,GAA8B0C,GAAmC;AAC3E,UAAM1C,GAAQ0C,CAAM;AAGd,UAAA,EAAE,SAAAhF,EAAY,IAAA;AAGpB,SAAK,YAAY4C,EAAM5C,CAAO,IAAI,UAAU,QAC5C,KAAK,QAAQ,GACb,KAAK,UAAU,IAIV,KAAA,SAASiF,GAAuBvF,GAAcM,CAAO;AACpD,UAAA,EAAE,QAAAc,EAAW,IAAA;AAIf,QAAAA,EAAO,SAAS;AAClB;AAGI,UAAAyB,IAAMd,EAAYzB,CAAO;AAE/B,SAAK,WAAW;AAAA,MACd,GAAGwC,EAAiB,IAAI5C,MAAgBI,CAAO;AAAA,MAC/C,GAAGwC,EAAiB,IAAI5C,MAAgBsF,OAAkBlF,EAAQ,QAAQuC,CAAG;AAAA,IAAA,GAG/E,KAAK,YAAYsC,EAAc,IAAItF,gBAA6BS,CAAO,GAGvE,KAAK,aAAa;AAAA,MAChB,GAAI,KAAK,YAAYwC,EAAiB,IAAI7C,MAAkB,KAAK,SAAS,IAAI,CAAC;AAAA,MAC/E,GAAG6C,EAAiB,IAAI7C,MAAkBuF,OAAkBlF,EAAQ,QAAQuC,CAAG;AAAA,IAAA;AAI3E,UAAA,EAAE,SAAAxB,EAAY,IAAA;AAGpB,SAAK,QAAQ,WAAWA,EAAQ,aAAa,KAAOjB,EAAiB,WAAWiB,EAAQ,UAIpFE,EAAe,IAAI,IAAI,MAChBG,EAAAN,EAAO,IAAIO,CAAW,GAE3B,KAAK,WAAW,UAAQmC,EAA0B,MAAM,CAAC,IAI/DS,EAAuB,MAAM,EAAI,GAG7BlD,EAAQ,YAAU,KAAK,MAAM;AAAA,EACnC;AAAA,EAKA,IAAI,OAAO;AACF,WAAAvB;AAAA,EACT;AAAA,EAIA,IAAI,WAAW;AACN,WAAAM;AAAA,EACT;AAAA,EAKA,IAAI,WAAW;AACN,WAAAoC,EAAS,KAAK,SAASrC,CAAW;AAAA,EAC3C;AAAA,EAKA,IAAI,cAAc;AAChB,WAAOgF,EAAc,IAAInF,WAAsBA,UAAqB,KAAK,OAAO,MAAM;AAAA,EACxF;AAAA,EAKA,QAAQ;AACN,UAAM,EAAE,SAAAM,GAAS,SAAAe,GAAS,UAAAoE,GAAU,OAAAvE,MAAU;AAExCY,IAAAA,EAAA,MAAMxB,GAAST,CAAc,GAC/B4F,MACI3D,EAAA,MAAMxB,GAASH,CAAW,GAChCyB,EAAYtB,GAASH,CAAW,IAG5B2B,EAAA;AAAA,MACJxB;AAAA,MACA,MAAM;AAIA,QAAA,KAAK,WAAW,CAAC,KAAK,YAAY,CAAC,KAAK,WAAW0C,EAAuB1C,CAAO,KAC9E,KAAA,GAAGY,IAAQ,CAAC;AAAA,MAErB;AAAA,MACAG,EAAQ;AAAA,MACRxB;AAAA,IAAA;AAAA,EAEJ;AAAA,EAGA,QAAQ;AACA,UAAA,EAAE,SAAAS,GAAS,SAAAe,EAAY,IAAA;AAE7B,IAAI,CAAC,KAAK,YAAYA,EAAQ,aAC5BK,EAASpB,GAASH,CAAW,GACvB2B,EAAA;AAAA,MACJxB;AAAA,MACA,MAAM;AAAA,MAEN;AAAA,MACA;AAAA,MACAH;AAAA,IAAA;AAAA,EAGN;AAAA,EAGA,OAAO;AAED,IAAC,KAAK,eACH,KAAA,GAAG,KAAK,QAAQ,CAAC;AAAA,EAE1B;AAAA,EAGA,OAAO;AAED,IAAC,KAAK,eACH,KAAA,GAAG,KAAK,QAAQ,CAAC;AAAA,EAE1B;AAAA,EAOA,GAAGuF,GAAa;AACd,UAAM,EAAE,SAAApF,GAAS,QAAAc,GAAQ,SAAAC,EAAA,IAAY,MAC/BC,IAAaC,EAAe,IAAI,GAChC0B,IAAMC,EAAM5C,CAAO;AACzB,QAAIqF,IAAOD;AAKX,QAAI,KAAK,eAAepE,MAAeqE,KAAQ7D,EAAM,IAAIxB,GAASJ,CAAW;AAAG;AAIhF,IAAIoB,IAAaqE,KAASrE,MAAe,KAAKqE,MAASvE,EAAO,SAAS,IAChE,KAAA,YAAY6B,IAAM,UAAU,UACxB3B,IAAaqE,KAASrE,MAAeF,EAAO,SAAS,KAAKuE,MAAS,OACvE,KAAA,YAAY1C,IAAM,SAAS;AAE5B,UAAA,EAAE,WAAA9B,EAAc,IAAA;AAGtB,IAAIwE,IAAO,IACTA,IAAOvE,EAAO,SAAS,IACduE,KAAQvE,EAAO,WACjBuE,IAAA;AAIH,UAAAnE,IAAcL,MAAc,SAAS,SAAS,QAC9CM,IAAiBN,MAAc,SAAS,UAAU,OAElDyE,IAAkB;AAAA,MACtB,eAAexE,EAAOuE;AAAA,MACtB,MAAMrE;AAAA,MACN,IAAIqE;AAAA,MACJ,WAAAxE;AAAA,IAAA;AASF,IALA0E,EAAahF,GAAoB+E,CAAe,GAChDC,EAAa9E,GAAmB6E,CAAe,GAG/C/D,EAAcvB,GAASO,CAAkB,GACrC,CAAAA,EAAmB,qBAGvB,KAAK,QAAQ8E,GACb7B,EAA0B,MAAM6B,CAAI,GAEhCG,GAA6B1E,EAAOuE,EAAK,KAAKnD,EAASlC,GAAS,OAAO,IACnEwB,EAAA;AAAA,MACJxB;AAAA,MACA,MAAM;AACJoB,QAAAA,EAASN,EAAOuE,IAAO,GAAG3F,KAAgBwB,GAAa,GACvDuE,GAAO3E,EAAOuE,EAAK,GACnBjE,EAASN,EAAOuE,IAAO,GAAG3F,KAAgByB,GAAgB,GAC1DC,EAASN,EAAOE,IAAa,GAAGtB,KAAgByB,GAAgB,GAEhEuE,GAAqB5E,EAAOuE,IAAO,MAAM3E,GAA6B,IAAI,CAAC;AAAA,MAC7E;AAAA,MACA;AAAA,MACAd;AAAA,IAAA,KAGOwB,EAAAN,EAAOuE,IAAOhE,CAAW,GACtBC,EAAAR,EAAOE,IAAaK,CAAW,GAErCG,EAAA;AAAA,MACJxB;AAAA,MACA,MAAM;AACEwB,QAAAA,EAAA,MAAMxB,GAASJ,CAAW,GAG5BI,KAAWe,EAAQ,YAAY,CAAC,KAAK,YACvC,KAAK,MAAM,GAGbQ,EAAcvB,GAASS,CAAiB;AAAA,MAC1C;AAAA,MACA;AAAA,MACAb;AAAA,IAAA;AAAA,EAGN;AAAA,EAGA,UAAU;AACF,UAAA,EAAE,QAAAkB,EAAW,IAAA,MACb6E,IAAc,CAAC,SAAS,OAAO,QAAQ,MAAM;AAEnD,KAAC,GAAG7E,CAAM,EAAE,QAAQ,CAAC8E,GAAOR,MAAQ;AAC9B,MAAAlD,EAAS0D,GAAOvE,CAAW,KAAGmC,EAA0B,MAAM4B,CAAG,GACrEO,EAAY,QAAQ,CAAKrC,MAAAhC,EAAYsE,GAAO,GAAGlG,KAAgB4D,GAAG,CAAC;AAAA,IAAA,CACpE,GAEDW,EAAuB,IAAI,GAC3B,MAAM,QAAQ;AAAA,EAChB;AACF;"}