{"version":3,"file":"carousel.cjs","sources":["../../src/strings/carouselString.ts","../../src/strings/carouselComponent.ts","../../src/components/carousel.ts"],"sourcesContent":["/** @type {string} */\nconst carouselString = \"carousel\";\nexport default carouselString;\n","/** @type {string} */\nconst carouselComponent = \"Carousel\";\nexport default carouselComponent;\n","/* Native JavaScript for Bootstrap 5 | Carousel\n----------------------------------------------- */\nimport {\n  addClass,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  dragstartEvent,\n  emulateTransitionEnd,\n  getAttribute,\n  getDocument,\n  getElementsByClassName,\n  getElementTransitionDuration,\n  getInstance,\n  hasClass,\n  isElementInScrollRange,\n  isHTMLElement,\n  isRTL,\n  keyArrowLeft,\n  keyArrowRight,\n  keydownEvent,\n  matches,\n  mouseclickEvent,\n  mouseenterEvent,\n  mouseleaveEvent,\n  ObjectAssign,\n  passiveHandler,\n  pointerdownEvent,\n  pointermoveEvent,\n  pointerupEvent,\n  querySelector,\n  querySelectorAll,\n  reflow,\n  removeClass,\n  Timer,\n  touchstartEvent,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport activeClass from \"../strings/activeClass\";\nimport dataBsTarget from \"../strings/dataBsTarget\";\nimport carouselString from \"../strings/carouselString\";\nimport carouselComponent from \"../strings/carouselComponent\";\nimport getTargetElement from \"../util/getTargetElement\";\nimport BaseComponent from \"./base-component\";\nimport type { CarouselEvent, CarouselOptions } from \"../interface/carousel\";\n\ntype CarouselEventProperties = {\n  relatedTarget: HTMLElement;\n  from: number;\n  to: number;\n  direction: \"left\" | \"right\";\n};\n\n// CAROUSEL PRIVATE GC\n// ===================\nconst carouselSelector = `[data-bs-ride=\"${carouselString}\"]`;\nconst carouselItem = `${carouselString}-item`;\nconst dataBsSlideTo = \"data-bs-slide-to\";\nconst dataBsSlide = \"data-bs-slide\";\nconst pausedClass = \"paused\";\n\nconst carouselDefaults: CarouselOptions = {\n  pause: \"hover\",\n  keyboard: false,\n  touch: true,\n  interval: 5000,\n};\n\n/**\n * Static method which returns an existing `Carousel` instance associated\n * to a target `Element`.\n */\nconst getCarouselInstance = (element: HTMLElement) =>\n  getInstance<Carousel>(element, carouselComponent);\n\n/**\n * A `Carousel` initialization callback.\n */\nconst carouselInitCallback = (element: HTMLElement) => new Carousel(element);\n\nlet startX = 0;\nlet currentX = 0;\nlet endX = 0;\n\n// CAROUSEL CUSTOM EVENTS\n// ======================\nconst carouselSlideEvent = createCustomEvent<\n  CarouselEventProperties,\n  CarouselEvent\n>(`slide.bs.${carouselString}`);\nconst carouselSlidEvent = createCustomEvent<\n  CarouselEventProperties,\n  CarouselEvent\n>(`slid.bs.${carouselString}`);\n\n// CAROUSEL EVENT HANDLERS\n// =======================\n/**\n * The `transitionend` event listener of the `Carousel`.\n *\n * @param self the `Carousel` instance\n */\nconst carouselTransitionEndHandler = (self: Carousel) => {\n  const { index, direction, element, slides, options } = self;\n\n  // istanbul ignore else @preserve\n  if (self.isAnimating) {\n    const activeItem = getActiveIndex(self);\n    const orientation = direction === \"left\" ? \"next\" : \"prev\";\n    const directionClass = direction === \"left\" ? \"start\" : \"end\";\n\n    addClass(slides[index], activeClass);\n    removeClass(slides[index], `${carouselItem}-${orientation}`);\n    removeClass(slides[index], `${carouselItem}-${directionClass}`);\n\n    removeClass(slides[activeItem], activeClass);\n    removeClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n    dispatchEvent(element, carouselSlidEvent);\n    Timer.clear(element, dataBsSlide);\n\n    // must check if a previous instance is disposed\n    if (\n      self.cycle && !getDocument(element).hidden && options.interval &&\n      !self.isPaused\n    ) {\n      self.cycle();\n    }\n  }\n};\n\n/**\n * Handles the `mouseenter` events when *options.pause*\n * is set to `hover`.\n */\nfunction carouselPauseHandler(this: HTMLElement) {\n  const self = getCarouselInstance(this);\n  // istanbul ignore else @preserve\n  if (self && !self.isPaused && !Timer.get(this, pausedClass)) {\n    addClass(this, pausedClass);\n  }\n}\n\n/**\n * Handles the `mouseleave` events when *options.pause*\n * is set to `hover`.\n */\nfunction carouselResumeHandler(this: HTMLElement) {\n  const self = getCarouselInstance(this);\n  // istanbul ignore else @preserve\n  if (self && self.isPaused && !Timer.get(this, pausedClass)) {\n    self.cycle();\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` indicators.\n *\n * @param e the `Event` object\n */\nfunction carouselIndicatorHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  const element =\n    (closest(this, carouselSelector) || getTargetElement(this)) as HTMLElement;\n  const self = getCarouselInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self && !self.isAnimating) {\n    const newIndex = +(\n      getAttribute(this, dataBsSlideTo) ||\n      // istanbul ignore next @preserve\n      0\n    );\n\n    // istanbul ignore else @preserve\n    if (\n      this &&\n      !hasClass(this, activeClass) && // event target is not active\n      !Number.isNaN(newIndex)\n    ) {\n      // AND has the specific attribute\n      self.to(newIndex); // do the slide\n    }\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` arrows.\n *\n * @param e the `Event` object\n */\nfunction carouselControlsHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  const element = closest(this, carouselSelector) ||\n    (getTargetElement(this) as HTMLElement);\n  const self = getCarouselInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self && !self.isAnimating) {\n    const orientation = getAttribute(this, dataBsSlide);\n\n    // istanbul ignore else @preserve\n    if (orientation === \"next\") {\n      self.next();\n    } else if (orientation === \"prev\") {\n      self.prev();\n    }\n  }\n}\n\n/**\n * Handles the keyboard `keydown` event for the visible `Carousel` elements.\n *\n * @param e the `Event` object\n */\nconst carouselKeyHandler = (\n  { code, target }: KeyboardEvent & { target: Node },\n) => {\n  const doc = getDocument(target);\n  const [element] = [...querySelectorAll(carouselSelector, doc)].filter((x) =>\n    isElementInScrollRange(x)\n  );\n  const self = getCarouselInstance(element);\n\n  // istanbul ignore next @preserve\n  if (self && !self.isAnimating && !/textarea|input/i.test(target.nodeName)) {\n    const RTL = isRTL(element);\n    const arrowKeyNext = !RTL ? keyArrowRight : keyArrowLeft;\n    const arrowKeyPrev = !RTL ? keyArrowLeft : keyArrowRight;\n\n    // istanbul ignore else @preserve\n    if (code === arrowKeyPrev) self.prev();\n    else if (code === arrowKeyNext) self.next();\n  }\n};\n\n// CAROUSEL TOUCH HANDLERS\n// =======================\n/**\n * Prevents the `touchstart` and `dragstart` events for the `Carousel` element.\n *\n * @param e the `Event` object\n */\nfunction carouselDragHandler(this: HTMLElement, e: DragEvent | TouchEvent) {\n  const { target } = e;\n  const self = getCarouselInstance(this);\n\n  // istanbul ignore next @preserve\n  if (\n    self &&\n    self.isTouch &&\n    ((self.indicator && !self.indicator.contains(target as Node)) ||\n      !self.controls.includes(target as HTMLElement))\n  ) {\n    e.stopImmediatePropagation();\n    e.stopPropagation();\n    e.preventDefault();\n  }\n}\n\n// CAROUSEL POINTER HANDLERS\n// =========================\n/**\n * Handles the `pointerdown` event for the `Carousel` element.\n *\n * @param e the `Event` object\n */\nfunction carouselPointerDownHandler(this: HTMLElement, e: PointerEvent) {\n  const { target } = e;\n  const self = getCarouselInstance(this);\n\n  // istanbul ignore else @preserve\n  if (self && !self.isAnimating && !self.isTouch) {\n    // filter pointer event on controls & indicators\n    const { controls, indicators } = self;\n    // istanbul ignore else @preserve\n    if (\n      ![...controls, ...indicators].every((el) =>\n        el === target || el.contains(target as Node)\n      )\n    ) {\n      startX = e.pageX;\n\n      // istanbul ignore else @preserve\n      if (this.contains(target as Node)) {\n        self.isTouch = true;\n        toggleCarouselTouchHandlers(self, true);\n      }\n    }\n  }\n}\n\n/**\n * Handles the `pointermove` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerMoveHandler = (e: PointerEvent) => {\n  currentX = e.pageX;\n};\n\n/**\n * Handles the `pointerup` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerUpHandler = (e: PointerEvent) => {\n  const { target } = e;\n  const doc = getDocument(target as Node);\n  const self = [...querySelectorAll(carouselSelector, doc)]\n    .map((c) => getCarouselInstance(c) as Carousel)\n    .find((i) => i.isTouch) as Carousel;\n\n  // impossible to satisfy\n  // istanbul ignore else @preserve\n  if (self) {\n    const { element, index } = self;\n    const RTL = isRTL(element);\n    endX = e.pageX;\n\n    self.isTouch = false;\n    toggleCarouselTouchHandlers(self);\n\n    if (\n      !doc.getSelection()?.toString().length &&\n      element.contains(target as HTMLElement) &&\n      Math.abs(startX - endX) > 120\n    ) {\n      // determine next index to slide to\n      // istanbul ignore else @preserve\n      if (currentX < startX) {\n        self.to(index + (RTL ? -1 : 1));\n      } else if (currentX > startX) {\n        self.to(index + (RTL ? 1 : -1));\n      }\n    }\n\n    // reset pointer position\n    startX = 0;\n    currentX = 0;\n    endX = 0;\n  }\n};\n\n// CAROUSEL PRIVATE METHODS\n// ========================\n/**\n * Sets active indicator for the `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param index the index of the new active indicator\n */\nconst activateCarouselIndicator = (self: Carousel, index: number) => {\n  const { indicators } = self;\n  [...indicators].forEach((x) => removeClass(x, activeClass));\n\n  // istanbul ignore else @preserve\n  if (self.indicators[index]) addClass(indicators[index], activeClass);\n};\n\n/**\n * Toggles the pointer event listeners for a given `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param add when `TRUE` event listeners are added\n */\nconst toggleCarouselTouchHandlers = (self: Carousel, add?: boolean) => {\n  const { element } = self;\n  const action = add ? addListener : removeListener;\n  action(\n    getDocument(element),\n    pointermoveEvent,\n    carouselPointerMoveHandler,\n    passiveHandler,\n  );\n  action(\n    getDocument(element),\n    pointerupEvent,\n    carouselPointerUpHandler,\n    passiveHandler,\n  );\n};\n\n/**\n * Returns the index of the current active item.\n *\n * @param self the `Carousel` instance\n * @returns the query result\n */\nconst getActiveIndex = (self: Carousel) => {\n  const { slides, element } = self;\n  const activeItem = querySelector(`.${carouselItem}.${activeClass}`, element);\n  return isHTMLElement(activeItem) ? [...slides].indexOf(activeItem) : -1;\n};\n\n// CAROUSEL DEFINITION\n// ===================\n/** Creates a new `Carousel` instance. */\nexport default class Carousel extends BaseComponent {\n  static selector = carouselSelector;\n  static init = carouselInitCallback;\n  static getInstance = getCarouselInstance;\n  declare options: CarouselOptions;\n  declare direction: \"right\" | \"left\";\n  declare index: number;\n  declare isTouch: boolean;\n  declare slides: HTMLCollectionOf<HTMLElement>;\n  declare controls: HTMLElement[];\n  declare indicator: HTMLElement | null;\n  declare indicators: HTMLElement[];\n\n  /**\n   * @param target mostly a `.carousel` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<CarouselOptions>) {\n    super(target, config);\n\n    // initialization element\n    const { element } = this;\n\n    // additional properties\n    this.direction = isRTL(element) ? \"right\" : \"left\";\n    this.isTouch = false;\n\n    // carousel elements\n    // a LIVE collection is prefferable\n    this.slides = getElementsByClassName(carouselItem, element);\n    const { slides } = this;\n\n    // invalidate when not enough items\n    // no need to go further\n    if (slides.length >= 2) {\n      const activeIndex = getActiveIndex(this);\n      // recover item from disposed instance\n      const transitionItem = [...slides].find((s) =>\n        matches(s, `.${carouselItem}-next,.${carouselItem}-next`)\n      );\n      this.index = activeIndex;\n\n      // external controls must be within same document context\n      const doc = getDocument(element);\n\n      this.controls = [\n        ...querySelectorAll(`[${dataBsSlide}]`, element),\n        ...querySelectorAll(\n          `[${dataBsSlide}][${dataBsTarget}=\"#${element.id}\"]`,\n          doc,\n        ),\n      ].filter((c, i, ar) => i === ar.indexOf(c));\n\n      this.indicator = querySelector(`.${carouselString}-indicators`, element);\n\n      // a LIVE collection is prefferable\n      this.indicators = [\n        ...(this.indicator\n          ? querySelectorAll(`[${dataBsSlideTo}]`, this.indicator)\n          // istanbul ignore next @preserve\n          : []),\n        ...querySelectorAll(\n          `[${dataBsSlideTo}][${dataBsTarget}=\"#${element.id}\"]`,\n          doc,\n        ),\n      ].filter((c, i, ar) => i === ar.indexOf(c));\n\n      // set JavaScript and DATA API options\n      const { options } = this;\n\n      // don't use TRUE as interval, it's actually 0, use the default 5000ms better\n      this.options.interval = options.interval === true\n        ? carouselDefaults.interval\n        : options.interval;\n\n      // set first slide active if none\n      // istanbul ignore next @preserve - impossible to test\n      if (transitionItem) {\n        this.index = [...slides].indexOf(transitionItem);\n      } else if (activeIndex < 0) {\n        this.index = 0;\n        addClass(slides[0], activeClass);\n        if (this.indicators.length) activateCarouselIndicator(this, 0);\n      }\n\n      // istanbul ignore else @preserve\n      if (this.indicators.length) activateCarouselIndicator(this, this.index);\n\n      // attach event handlers\n      this._toggleEventListeners(true);\n\n      // start to cycle if interval is set\n      if (options.interval) this.cycle();\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return carouselComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return carouselDefaults;\n  }\n\n  /**\n   * Check if instance is paused.\n   */\n  get isPaused() {\n    return hasClass(this.element, pausedClass);\n  }\n\n  /**\n   * Check if instance is animating.\n   */\n  get isAnimating() {\n    return querySelector(\n      `.${carouselItem}-next,.${carouselItem}-prev`,\n      this.element,\n    ) !== null;\n  }\n\n  // CAROUSEL PUBLIC METHODS\n  // =======================\n  /** Slide automatically through items. */\n  cycle() {\n    const { element, options, isPaused, index } = this;\n\n    Timer.clear(element, carouselString);\n    if (isPaused) {\n      Timer.clear(element, pausedClass);\n      removeClass(element, pausedClass);\n    }\n\n    Timer.set(\n      element,\n      () => {\n        // it's very important to check self.element\n        // where instance might have been disposed\n        // istanbul ignore else @preserve\n        if (\n          this.element && !this.isPaused && !this.isTouch &&\n          isElementInScrollRange(element)\n        ) {\n          this.to(index + 1);\n        }\n      },\n      options.interval as number,\n      carouselString,\n    );\n  }\n\n  /** Pause the automatic cycle. */\n  pause() {\n    const { element, options } = this;\n    // istanbul ignore else @preserve\n    if (!this.isPaused && options.interval) {\n      addClass(element, pausedClass);\n      Timer.set(\n        element,\n        () => {\n          /* ESLint is now happy */\n        },\n        1,\n        pausedClass,\n      );\n    }\n  }\n\n  /** Slide to the next item. */\n  next() {\n    // istanbul ignore else @preserve\n    if (!this.isAnimating) {\n      this.to(this.index + 1);\n    }\n  }\n\n  /** Slide to the previous item. */\n  prev() {\n    // istanbul ignore else @preserve\n    if (!this.isAnimating) {\n      this.to(this.index - 1);\n    }\n  }\n\n  /**\n   * Jump to the item with the `idx` index.\n   *\n   * @param idx the index of the item to jump to\n   */\n  to(idx: number) {\n    const { element, slides, options } = this;\n    const activeItem = getActiveIndex(this);\n    const RTL = isRTL(element);\n    let next = idx;\n\n    // when controled via methods, make sure to check again\n    // first return if we're on the same item #227\n    // `to()` must be SPAM protected by Timer\n    if (\n      !this.isAnimating && activeItem !== next &&\n      !Timer.get(element, dataBsSlide)\n    ) {\n      // determine transition direction\n      // istanbul ignore else @preserve\n      if (\n        activeItem < next || (activeItem === 0 && next === slides.length - 1)\n      ) {\n        this.direction = RTL ? \"right\" : \"left\"; // next\n      } else if (\n        activeItem > next || (activeItem === slides.length - 1 && next === 0)\n      ) {\n        this.direction = RTL ? \"left\" : \"right\"; // prev\n      }\n      const { direction } = this;\n\n      // find the right next index\n      if (next < 0) {\n        next = slides.length - 1;\n      } else if (next >= slides.length) {\n        next = 0;\n      }\n\n      // orientation, class name, eventProperties\n      const orientation = direction === \"left\" ? \"next\" : \"prev\";\n      const directionClass = direction === \"left\" ? \"start\" : \"end\";\n\n      const eventProperties = {\n        relatedTarget: slides[next],\n        from: activeItem,\n        to: next,\n        direction,\n      };\n\n      // update event properties\n      ObjectAssign(carouselSlideEvent, eventProperties);\n      ObjectAssign(carouselSlidEvent, eventProperties);\n\n      // discontinue when prevented\n      dispatchEvent(element, carouselSlideEvent);\n      if (!carouselSlideEvent.defaultPrevented) {\n        // update index\n        this.index = next;\n        activateCarouselIndicator(this, next);\n\n        if (\n          getElementTransitionDuration(slides[next]) &&\n          hasClass(element, \"slide\")\n        ) {\n          Timer.set(\n            element,\n            () => {\n              addClass(slides[next], `${carouselItem}-${orientation}`);\n              reflow(slides[next]);\n              addClass(slides[next], `${carouselItem}-${directionClass}`);\n              addClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n              // the instance might get diposed mid-animation\n              emulateTransitionEnd(\n                slides[next],\n                () =>\n                  this.slides && this.slides.length &&\n                  carouselTransitionEndHandler(this),\n              );\n            },\n            0,\n            dataBsSlide,\n          );\n        } else {\n          addClass(slides[next], activeClass);\n          removeClass(slides[activeItem], activeClass);\n\n          Timer.set(\n            element,\n            () => {\n              Timer.clear(element, dataBsSlide);\n              // check for element, might have been disposed\n              // istanbul ignore else @preserve\n              if (element && options.interval && !this.isPaused) {\n                this.cycle();\n              }\n\n              dispatchEvent(element, carouselSlidEvent);\n            },\n            0,\n            dataBsSlide,\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Toggles all event listeners for the `Carousel` instance.\n   *\n   * @param add when `TRUE` event listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const { element, options, slides, controls, indicators } = this;\n    const { touch, pause, interval, keyboard } = options;\n    const action = add ? addListener : removeListener;\n\n    if (pause && interval) {\n      action(element, mouseenterEvent, carouselPauseHandler);\n      action(element, mouseleaveEvent, carouselResumeHandler);\n    }\n\n    if (touch && slides.length > 2) {\n      action(\n        element,\n        pointerdownEvent,\n        carouselPointerDownHandler,\n        passiveHandler,\n      );\n      action(element, touchstartEvent, carouselDragHandler, { passive: false });\n      action(element, dragstartEvent, carouselDragHandler, { passive: false });\n    }\n\n    // istanbul ignore else @preserve\n    if (controls.length) {\n      controls.forEach((arrow) => {\n        // istanbul ignore else @preserve\n        if (arrow) action(arrow, mouseclickEvent, carouselControlsHandler);\n      });\n    }\n\n    // istanbul ignore else @preserve\n    if (indicators.length) {\n      indicators.forEach((indicator) => {\n        action(indicator, mouseclickEvent, carouselIndicatorHandler);\n      });\n    }\n\n    if (keyboard) {\n      action(getDocument(element), keydownEvent, carouselKeyHandler);\n    }\n  };\n\n  /** Remove `Carousel` component from target. */\n  dispose() {\n    const { isAnimating } = this;\n\n    const clone = {\n      ...this,\n      isAnimating,\n    };\n    this._toggleEventListeners();\n    super.dispose();\n\n    // istanbul ignore next @preserve - impossible to test in playwright\n    if (clone.isAnimating) {\n      emulateTransitionEnd(clone.slides[clone.index], () => {\n        carouselTransitionEndHandler(clone);\n      });\n    }\n  }\n}\n"],"names":["carouselString","carouselComponent","carouselSelector","carouselItem","dataBsSlideTo","dataBsSlide","pausedClass","carouselDefaults","getCarouselInstance","element","getInstance","carouselInitCallback","Carousel","startX","currentX","endX","carouselSlideEvent","createCustomEvent","carouselSlidEvent","carouselTransitionEndHandler","self","index","direction","slides","options","activeItem","getActiveIndex","orientation","directionClass","addClass","activeClass","removeClass","dispatchEvent","Timer","getDocument","carouselPauseHandler","carouselResumeHandler","carouselIndicatorHandler","e","closest","getTargetElement","newIndex","getAttribute","hasClass","carouselControlsHandler","carouselKeyHandler","code","target","doc","querySelectorAll","x","isElementInScrollRange","RTL","isRTL","arrowKeyNext","keyArrowLeft","keyArrowRight","arrowKeyPrev","carouselDragHandler","carouselPointerDownHandler","controls","indicators","el","toggleCarouselTouchHandlers","carouselPointerMoveHandler","carouselPointerUpHandler","c","i","_a","activateCarouselIndicator","add","action","addListener","removeListener","pointermoveEvent","passiveHandler","pointerupEvent","querySelector","isHTMLElement","BaseComponent","config","__publicField","touch","pause","interval","keyboard","mouseenterEvent","mouseleaveEvent","pointerdownEvent","touchstartEvent","dragstartEvent","arrow","mouseclickEvent","indicator","keydownEvent","getElementsByClassName","activeIndex","transitionItem","s","matches","dataBsTarget","ar","isPaused","idx","next","eventProperties","ObjectAssign","getElementTransitionDuration","reflow","emulateTransitionEnd","isAnimating","clone"],"mappings":"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"}