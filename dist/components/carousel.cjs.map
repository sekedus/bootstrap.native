{"version":3,"file":"carousel.cjs","sources":["../../src/strings/carouselString.ts","../../src/strings/carouselComponent.ts","../../src/components/carousel.ts"],"sourcesContent":["/** @type {string} */\nconst carouselString = 'carousel';\nexport default carouselString;\n","/** @type {string} */\nconst carouselComponent = 'Carousel';\nexport default carouselComponent;\n","/* Native JavaScript for Bootstrap 5 | Carousel\n----------------------------------------------- */\nimport {\n  createCustomEvent,\n  getInstance,\n  dispatchEvent,\n  ObjectAssign,\n  emulateTransitionEnd,\n  passiveHandler,\n  reflow,\n  Timer,\n  getAttribute,\n  getElementsByClassName,\n  querySelectorAll,\n  querySelector,\n  closest,\n  isHTMLElement,\n  isRTL,\n  isElementInScrollRange,\n  getElementTransitionDuration,\n  getDocument,\n  pointerupEvent,\n  pointermoveEvent,\n  pointerdownEvent,\n  keyArrowRight,\n  keyArrowLeft,\n  keydownEvent,\n  mouseclickEvent,\n  mouseleaveEvent,\n  mouseenterEvent,\n  addClass,\n  hasClass,\n  removeClass,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport activeClass from '../strings/activeClass';\nimport dataBsTarget from '../strings/dataBsTarget';\nimport carouselString from '../strings/carouselString';\nimport carouselComponent from '../strings/carouselComponent';\nimport getTargetElement from '../util/getTargetElement';\nimport BaseComponent from './base-component';\nimport type { CarouselEvent, CarouselOptions } from '../interface/carousel';\n\n// CAROUSEL PRIVATE GC\n// ===================\nconst carouselSelector = `[data-bs-ride=\"${carouselString}\"]`;\nconst carouselItem = `${carouselString}-item`;\nconst dataBsSlideTo = 'data-bs-slide-to';\nconst dataBsSlide = 'data-bs-slide';\nconst pausedClass = 'paused';\n\nconst carouselDefaults: CarouselOptions = {\n  pause: 'hover',\n  keyboard: false,\n  touch: true,\n  interval: 5000,\n};\n\n/**\n * Static method which returns an existing `Carousel` instance associated\n * to a target `Element`.\n */\nconst getCarouselInstance = (element: HTMLElement) => getInstance<Carousel>(element, carouselComponent);\n\n/**\n * A `Carousel` initialization callback.\n */\nconst carouselInitCallback = (element: HTMLElement) => new Carousel(element);\n\nlet startX = 0;\nlet currentX = 0;\nlet endX = 0;\n\n// CAROUSEL CUSTOM EVENTS\n// ======================\nconst carouselSlideEvent = createCustomEvent<CarouselEvent>(`slide.bs.${carouselString}`);\nconst carouselSlidEvent = createCustomEvent<CarouselEvent>(`slid.bs.${carouselString}`);\n\n// CAROUSEL EVENT HANDLERS\n// =======================\n/**\n * The `transitionend` event listener of the `Carousel`.\n *\n * @param self the `Carousel` instance\n */\nconst carouselTransitionEndHandler = (self: Carousel) => {\n  const { index, direction, element, slides, options } = self;\n\n  // discontinue disposed instances\n  /* istanbul ignore else */\n  if (self.isAnimating && getCarouselInstance(element)) {\n    const activeItem = getActiveIndex(self);\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    addClass(slides[index], activeClass);\n    removeClass(slides[index], `${carouselItem}-${orientation}`);\n    removeClass(slides[index], `${carouselItem}-${directionClass}`);\n\n    removeClass(slides[activeItem], activeClass);\n    removeClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n    dispatchEvent(element, carouselSlidEvent);\n    Timer.clear(element, dataBsSlide);\n\n    // check for element, might have been disposed\n    if (!getDocument(element).hidden && options.interval && !self.isPaused) {\n      self.cycle();\n    }\n  }\n};\n\n/**\n * Handles the `mouseenter` events when *options.pause*\n * is set to `hover`.\n */\nfunction carouselPauseHandler(this: HTMLElement) {\n  // const element = this;\n  const self = getCarouselInstance(this);\n  /* istanbul ignore else */\n  if (self && !self.isPaused && !Timer.get(this, pausedClass)) {\n    addClass(this, pausedClass);\n  }\n}\n\n/**\n * Handles the `mouseleave` events when *options.pause*\n * is set to `hover`.\n *\n */\nfunction carouselResumeHandler(this: HTMLElement) {\n  // const element = this;\n  const self = getCarouselInstance(this);\n  /* istanbul ignore else */\n  if (self && self.isPaused && !Timer.get(this, pausedClass)) {\n    self.cycle();\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` indicators.\n *\n * @param e the `Event` object\n */\nfunction carouselIndicatorHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  // const indicator = this;\n  const element = (closest(this, carouselSelector) || getTargetElement(this)) as HTMLElement;\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isAnimating) return;\n\n  const newIndex = +(getAttribute(this, dataBsSlideTo) || 0);\n\n  if (\n    this &&\n    !hasClass(this, activeClass) && // event target is not active\n    !Number.isNaN(newIndex)\n  ) {\n    // AND has the specific attribute\n    self.to(newIndex); // do the slide\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` arrows.\n *\n * @param e the `Event` object\n */\nfunction carouselControlsHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  // const control = this;\n  const element = closest(this, carouselSelector) || (getTargetElement(this) as HTMLElement);\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isAnimating) return;\n  const orientation = getAttribute(this, dataBsSlide);\n\n  /* istanbul ignore else */\n  if (orientation === 'next') {\n    self.next();\n  } else if (orientation === 'prev') {\n    self.prev();\n  }\n}\n\n/**\n * Handles the keyboard `keydown` event for the visible `Carousel` elements.\n *\n * @param e the `Event` object\n */\nconst carouselKeyHandler = ({ code, target }: KeyboardEvent & { target: Node }) => {\n  const doc = getDocument(target);\n  const [element] = [...querySelectorAll(carouselSelector, doc)].filter(x => isElementInScrollRange(x));\n  const self = getCarouselInstance(element);\n\n  /* istanbul ignore next */\n  if (!self || self.isAnimating || /textarea|input/i.test(target.nodeName)) return;\n  const RTL = isRTL(element);\n  const arrowKeyNext = !RTL ? keyArrowRight : keyArrowLeft;\n  const arrowKeyPrev = !RTL ? keyArrowLeft : keyArrowRight;\n\n  /* istanbul ignore else */\n  if (code === arrowKeyPrev) self.prev();\n  else if (code === arrowKeyNext) self.next();\n};\n\n// CAROUSEL TOUCH HANDLERS\n// =======================\n/**\n * Handles the `pointerdown` event for the `Carousel` element.\n *\n * @param e the `Event` object\n */\nfunction carouselPointerDownHandler(this: HTMLElement, e: PointerEvent) {\n  // const element = this;\n  const { target } = e;\n  const self = getCarouselInstance(this);\n\n  if (!self || self.isAnimating || self.isTouch) {\n    return;\n  }\n\n  // filter pointer event on controls & indicators\n  const { controls, indicators } = self;\n  if ([...controls, ...indicators].some(el => el === target || el.contains(target as Node))) {\n    return;\n  }\n\n  startX = e.pageX;\n\n  /* istanbul ignore else */\n  if (this.contains(target as Node)) {\n    self.isTouch = true;\n    toggleCarouselTouchHandlers(self, true);\n  }\n}\n\n/**\n * Handles the `pointermove` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerMoveHandler = (e: PointerEvent) => {\n  currentX = e.pageX;\n};\n\n/**\n * Handles the `pointerup` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerUpHandler = (e: PointerEvent) => {\n  const { target } = e;\n  const doc = getDocument(target as Node);\n  const self = [...querySelectorAll(carouselSelector, doc)]\n    .map(c => getCarouselInstance(c) as Carousel)\n    .find(i => i.isTouch) as Carousel;\n\n  // impossible to satisfy\n  /* istanbul ignore next */\n  if (!self) {\n    return;\n  }\n\n  const { element, index } = self;\n  const RTL = isRTL(element);\n\n  self.isTouch = false;\n  toggleCarouselTouchHandlers(self);\n\n  if (doc.getSelection()?.toString().length) {\n    // reset pointer position\n    startX = 0;\n    currentX = 0;\n    endX = 0;\n    return;\n  }\n\n  endX = e.pageX;\n\n  // the event target is outside the carousel context\n  // OR swipe distance is less than 120px\n  /* istanbul ignore else */\n  if (!element.contains(target as HTMLElement) || Math.abs(startX - endX) < 120) {\n    // reset pointer position\n    startX = 0;\n    currentX = 0;\n    endX = 0;\n    return;\n  }\n  // OR determine next index to slide to\n  /* istanbul ignore else */\n  if (currentX < startX) {\n    self.to(index + (RTL ? -1 : 1));\n  } else if (currentX > startX) {\n    self.to(index + (RTL ? 1 : -1));\n  }\n  // reset pointer position\n  startX = 0;\n  currentX = 0;\n  endX = 0;\n};\n\n// CAROUSEL PRIVATE METHODS\n// ========================\n/**\n * Sets active indicator for the `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param pageIndex the index of the new active indicator\n */\nconst activateCarouselIndicator = (self: Carousel, pageIndex: number) => {\n  const { indicators } = self;\n  [...indicators].forEach(x => removeClass(x, activeClass));\n\n  /* istanbul ignore else */\n  if (self.indicators[pageIndex]) addClass(indicators[pageIndex], activeClass);\n};\n\n/**\n * Toggles the pointer event listeners for a given `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param add when `TRUE` event listeners are added\n */\nconst toggleCarouselTouchHandlers = (self: Carousel, add?: boolean) => {\n  const { element } = self;\n  const action = add ? addListener : removeListener;\n  action(getDocument(element), pointermoveEvent, carouselPointerMoveHandler as EventListener, passiveHandler);\n  action(getDocument(element), pointerupEvent, carouselPointerUpHandler as EventListener, passiveHandler);\n};\n\n/**\n * Toggles all event listeners for a given `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param add when `TRUE` event listeners are added\n */\nconst toggleCarouselHandlers = (self: Carousel, add?: boolean) => {\n  const { element, options, slides, controls, indicators } = self;\n  const { touch, pause, interval, keyboard } = options;\n  const action = add ? addListener : removeListener;\n\n  if (pause && interval) {\n    action(element, mouseenterEvent, carouselPauseHandler);\n    action(element, mouseleaveEvent, carouselResumeHandler);\n  }\n\n  if (touch && slides.length > 2) {\n    action(element, pointerdownEvent, carouselPointerDownHandler as EventListener, passiveHandler);\n  }\n\n  /* istanbul ignore else */\n  if (controls.length) {\n    controls.forEach(arrow => {\n      /* istanbul ignore else */\n      if (arrow) action(arrow, mouseclickEvent, carouselControlsHandler as EventListener);\n    });\n  }\n\n  /* istanbul ignore else */\n  if (indicators.length) {\n    indicators.forEach(indicator => {\n      action(indicator, mouseclickEvent, carouselIndicatorHandler as EventListener);\n    });\n  }\n\n  if (keyboard) action(getDocument(element), keydownEvent, carouselKeyHandler as EventListener);\n};\n\n/**\n * Returns the index of the current active item.\n *\n * @param self the `Carousel` instance\n * @returns the query result\n */\nconst getActiveIndex = (self: Carousel) => {\n  const { slides, element } = self;\n  const activeItem = querySelector(`.${carouselItem}.${activeClass}`, element);\n  return isHTMLElement(activeItem) ? [...slides].indexOf(activeItem) : -1;\n};\n\n// CAROUSEL DEFINITION\n// ===================\n/** Creates a new `Carousel` instance. */\nexport default class Carousel extends BaseComponent {\n  static selector = carouselSelector;\n  static init = carouselInitCallback;\n  static getInstance = getCarouselInstance;\n  declare options: CarouselOptions;\n  declare direction: 'right' | 'left';\n  declare index: number;\n  declare isTouch: boolean;\n  declare slides: HTMLCollectionOf<HTMLElement>;\n  declare controls: HTMLElement[];\n  declare indicator: HTMLElement | null;\n  declare indicators: HTMLElement[];\n\n  /**\n   * @param target mostly a `.carousel` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<CarouselOptions>) {\n    super(target, config);\n\n    // initialization element\n    const { element } = this;\n\n    // additional properties\n    this.direction = isRTL(element) ? 'right' : 'left';\n    this.index = 0;\n    this.isTouch = false;\n\n    // carousel elements\n    // a LIVE collection is prefferable\n    this.slides = getElementsByClassName(carouselItem, element);\n    const { slides } = this;\n\n    // invalidate when not enough items\n    // no need to go further\n    if (slides.length < 2) {\n      return;\n    }\n    // external controls must be within same document context\n    const doc = getDocument(element);\n\n    this.controls = [\n      ...querySelectorAll(`[${dataBsSlide}]`, element),\n      ...querySelectorAll(`[${dataBsSlide}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n    ];\n\n    this.indicator = querySelector(`.${carouselString}-indicators`, element);\n\n    // a LIVE collection is prefferable\n    this.indicators = [\n      ...(this.indicator ? querySelectorAll(`[${dataBsSlideTo}]`, this.indicator) : []),\n      ...querySelectorAll(`[${dataBsSlideTo}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n    ];\n\n    // set JavaScript and DATA API options\n    const { options } = this;\n\n    // don't use TRUE as interval, it's actually 0, use the default 5000ms better\n    this.options.interval = options.interval === true ? carouselDefaults.interval : options.interval;\n\n    // set first slide active if none\n    /* istanbul ignore else */\n    if (getActiveIndex(this) < 0) {\n      addClass(slides[0], activeClass);\n      /* istanbul ignore else */\n      if (this.indicators.length) activateCarouselIndicator(this, 0);\n    }\n\n    // attach event handlers\n    toggleCarouselHandlers(this, true);\n\n    // start to cycle if interval is set\n    if (options.interval) this.cycle();\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return carouselComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return carouselDefaults;\n  }\n\n  /**\n   * Check if instance is paused.\n   */\n  get isPaused() {\n    return hasClass(this.element, pausedClass);\n  }\n\n  /**\n   * Check if instance is animating.\n   */\n  get isAnimating() {\n    return querySelector(`.${carouselItem}-next,.${carouselItem}-prev`, this.element) !== null;\n  }\n\n  // CAROUSEL PUBLIC METHODS\n  // =======================\n  /** Slide automatically through items. */\n  cycle() {\n    const { element, options, isPaused, index } = this;\n\n    Timer.clear(element, carouselString);\n    if (isPaused) {\n      Timer.clear(element, pausedClass);\n      removeClass(element, pausedClass);\n    }\n\n    Timer.set(\n      element,\n      () => {\n        // it's very important to check self.element\n        // where instance might have been disposed\n        /* istanbul ignore else */\n        if (this.element && !this.isPaused && !this.isTouch && isElementInScrollRange(element)) {\n          this.to(index + 1);\n        }\n      },\n      options.interval as number,\n      carouselString,\n    );\n  }\n\n  /** Pause the automatic cycle. */\n  pause() {\n    const { element, options } = this;\n    /* istanbul ignore else */\n    if (!this.isPaused && options.interval) {\n      addClass(element, pausedClass);\n      Timer.set(\n        element,\n        () => {\n          /* ESLint is now happy */\n        },\n        1,\n        pausedClass,\n      );\n    }\n  }\n\n  /** Slide to the next item. */\n  next() {\n    /* istanbul ignore else */\n    if (!this.isAnimating) {\n      this.to(this.index + 1);\n    }\n  }\n\n  /** Slide to the previous item. */\n  prev() {\n    /* istanbul ignore else */\n    if (!this.isAnimating) {\n      this.to(this.index - 1);\n    }\n  }\n\n  /**\n   * Jump to the item with the `idx` index.\n   *\n   * @param idx the index of the item to jump to\n   */\n  to(idx: number) {\n    const { element, slides, options } = this;\n    const activeItem = getActiveIndex(this);\n    const RTL = isRTL(element);\n    let next = idx;\n\n    // when controled via methods, make sure to check again\n    // first return if we're on the same item #227\n    // `to()` must be SPAM protected by Timer\n    if (this.isAnimating || activeItem === next || Timer.get(element, dataBsSlide)) return;\n\n    // determine transition direction\n    /* istanbul ignore else */\n    if (activeItem < next || (activeItem === 0 && next === slides.length - 1)) {\n      this.direction = RTL ? 'right' : 'left'; // next\n    } else if (activeItem > next || (activeItem === slides.length - 1 && next === 0)) {\n      this.direction = RTL ? 'left' : 'right'; // prev\n    }\n    const { direction } = this;\n\n    // find the right next index\n    if (next < 0) {\n      next = slides.length - 1;\n    } else if (next >= slides.length) {\n      next = 0;\n    }\n\n    // orientation, class name, eventProperties\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    const eventProperties = {\n      relatedTarget: slides[next],\n      from: activeItem,\n      to: next,\n      direction,\n    };\n\n    // update event properties\n    ObjectAssign(carouselSlideEvent, eventProperties);\n    ObjectAssign(carouselSlidEvent, eventProperties);\n\n    // discontinue when prevented\n    dispatchEvent(element, carouselSlideEvent);\n    if (carouselSlideEvent.defaultPrevented) return;\n\n    // update index\n    this.index = next;\n    activateCarouselIndicator(this, next);\n\n    if (getElementTransitionDuration(slides[next]) && hasClass(element, 'slide')) {\n      Timer.set(\n        element,\n        () => {\n          addClass(slides[next], `${carouselItem}-${orientation}`);\n          reflow(slides[next]);\n          addClass(slides[next], `${carouselItem}-${directionClass}`);\n          addClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n          emulateTransitionEnd(slides[next], () => carouselTransitionEndHandler(this));\n        },\n        0,\n        dataBsSlide,\n      );\n    } else {\n      addClass(slides[next], activeClass);\n      removeClass(slides[activeItem], activeClass);\n\n      Timer.set(\n        element,\n        () => {\n          Timer.clear(element, dataBsSlide);\n          // check for element, might have been disposed\n          /* istanbul ignore else */\n          if (element && options.interval && !this.isPaused) {\n            this.cycle();\n          }\n\n          dispatchEvent(element, carouselSlidEvent);\n        },\n        0,\n        dataBsSlide,\n      );\n    }\n  }\n\n  /** Remove `Carousel` component from target. */\n  dispose() {\n    const { slides } = this;\n    const itemClasses = ['start', 'end', 'prev', 'next'];\n\n    [...slides].forEach((slide, idx) => {\n      if (hasClass(slide, activeClass)) activateCarouselIndicator(this, idx);\n      itemClasses.forEach(c => removeClass(slide, `${carouselItem}-${c}`));\n    });\n\n    toggleCarouselHandlers(this);\n    super.dispose();\n  }\n}\n"],"names":["carouselString","carouselComponent","carouselSelector","carouselItem","dataBsSlideTo","dataBsSlide","pausedClass","carouselDefaults","getCarouselInstance","element","getInstance","carouselInitCallback","Carousel","startX","currentX","endX","carouselSlideEvent","createCustomEvent","carouselSlidEvent","carouselTransitionEndHandler","self","index","direction","slides","options","activeItem","getActiveIndex","orientation","directionClass","addClass","activeClass","removeClass","dispatchEvent","Timer","getDocument","carouselPauseHandler","carouselResumeHandler","carouselIndicatorHandler","e","closest","getTargetElement","newIndex","getAttribute","hasClass","carouselControlsHandler","carouselKeyHandler","code","target","doc","querySelectorAll","x","isElementInScrollRange","RTL","isRTL","arrowKeyNext","keyArrowLeft","keyArrowRight","arrowKeyPrev","carouselPointerDownHandler","controls","indicators","el","toggleCarouselTouchHandlers","carouselPointerMoveHandler","carouselPointerUpHandler","c","i","activateCarouselIndicator","pageIndex","add","action","addListener","removeListener","pointermoveEvent","passiveHandler","pointerupEvent","toggleCarouselHandlers","touch","pause","interval","keyboard","mouseenterEvent","mouseleaveEvent","pointerdownEvent","arrow","mouseclickEvent","indicator","keydownEvent","querySelector","isHTMLElement","BaseComponent","config","getElementsByClassName","dataBsTarget","isPaused","idx","next","eventProperties","ObjectAssign","getElementTransitionDuration","reflow","emulateTransitionEnd","itemClasses","slide"],"mappings":"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"}