{"version":3,"file":"tooltip-d4e567a2.js","sources":["../../src/strings/popoverString.ts","../../src/strings/popoverComponent.ts","../../src/strings/tooltipString.ts","../../src/util/getTipTemplate.ts","../../src/util/tipClassPositions.ts","../../src/util/styleTip.ts","../../src/util/tooltipDefaults.ts","../../src/strings/dataOriginalTitle.ts","../../src/strings/tooltipComponent.ts","../../src/util/setHtml.ts","../../src/util/createTip.ts","../../src/components/tooltip.ts"],"sourcesContent":["/** @type {string} */\nconst popoverString = 'popover';\nexport default popoverString;\n","/** @type {string} */\nconst popoverComponent = 'Popover';\nexport default popoverComponent;\n","/** @type {string} */\nconst tooltipString = 'tooltip';\nexport default tooltipString;\n","import tooltipString from '../strings/tooltipString';\n\n/**\n * Returns a template for Popover / Tooltip.\n *\n * @param tipType the expected markup type\n * @returns the template markup\n */\nconst getTipTemplate = (tipType: string) => {\n  const isTooltip = tipType === tooltipString;\n  const bodyClass = isTooltip ? `${tipType}-inner` : `${tipType}-body`;\n  const header = !isTooltip ? `<h3 class=\"${tipType}-header\"></h3>` : '';\n  const arrow = `<div class=\"${tipType}-arrow\"></div>`;\n  const body = `<div class=\"${bodyClass}\"></div>`;\n  return `<div class=\"${tipType}\" role=\"${tooltipString}\">${header + arrow + body}</div>`;\n};\n\nexport default getTipTemplate;\n","const tipClassPositions = {\n  top: 'top',\n  bottom: 'bottom',\n  left: 'start',\n  right: 'end',\n};\n\nexport default tipClassPositions;\n","import {\n  isHTMLElement,\n  setElementStyle,\n  getDocumentElement,\n  getWindow,\n  getBoundingClientRect,\n  getElementStyle,\n  isRTL,\n  isMedia,\n} from '@thednp/shorty';\n\nimport popoverComponent from '../strings/popoverComponent';\nimport tipClassPositions from './tipClassPositions';\n// import TooltipInterface from '../interface/tooltip';\n// import PopoverInterface from '../interface/popover';\nimport Tooltip from '../components/tooltip';\nimport { popupContainer } from './popupContainer';\n\n// type FakeTip = {\n//   name: string,\n//   element: HTMLElement,\n//   tooltip: HTMLElement,\n//   options: TooltipInterface.Options | PopoverInterface.Options,\n//   arrow: HTMLElement,\n//   offsetParent: ParentNode\n// }\n\n/**\n * Style popovers and tooltips.\n *\n * @param self the `Popover` / `Tooltip` instance\n * @param e event object\n */\nconst styleTip = <T extends Tooltip>(self: T, e?: Event & PointerEvent) => {\n  const tipClasses = /\\b(top|bottom|start|end)+/;\n  const { element, tooltip, options, arrow } = self;\n  if (!tooltip) return;\n  const tipPositions = { ...tipClassPositions };\n\n  const RTL = isRTL(element);\n  if (RTL) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n\n  // reset tooltip style (top: 0, left: 0 works best)\n  setElementStyle(tooltip, {\n    // top: '0px', left: '0px', right: '', bottom: '',\n    top: '',\n    left: '',\n    right: '',\n    bottom: '',\n  });\n  const isPopover = self.name === popoverComponent;\n  const { offsetWidth: tipWidth, offsetHeight: tipHeight } = tooltip;\n  const { clientWidth: htmlcw, clientHeight: htmlch } = getDocumentElement(element);\n  // const { container } = options;\n  let { placement } = options;\n  const { left: parentLeft, right: parentRight, top: parentTop } = getBoundingClientRect(popupContainer, true);\n  const { clientWidth: parentCWidth, offsetWidth: parentOWidth } = popupContainer;\n  const scrollbarWidth = Math.abs(parentCWidth - parentOWidth);\n  // const tipAbsolute = getElementStyle(tooltip, 'position') === 'absolute';\n  const parentPosition = getElementStyle(popupContainer, 'position');\n  // const absoluteParent = parentPosition === 'absolute';\n  const fixedParent = parentPosition === 'fixed';\n  const staticParent = parentPosition === 'static';\n  // const stickyParent = parentPosition === 'sticky';\n  // const isSticky = stickyParent && parentTop === parseFloat(getElementStyle(popupContainer, 'top'));\n  // const absoluteTarget = getElementStyle(element, 'position') === 'absolute';\n  // const stickyFixedParent = ['sticky', 'fixed'].includes(parentPosition);\n  const leftBoundry = RTL && fixedParent ? scrollbarWidth : 0;\n  const rightBoundry = fixedParent\n    ? parentCWidth + parentLeft + (RTL ? scrollbarWidth : 0)\n    : parentCWidth + parentLeft + (htmlcw - parentRight) - 1;\n  const {\n    width: elemWidth,\n    height: elemHeight,\n    left: elemRectLeft,\n    right: elemRectRight,\n    top: elemRectTop,\n  } = getBoundingClientRect(element, true);\n  // console.log(getWindow(tooltip));\n  const win = getWindow(tooltip);\n\n  const scroll = { x: win.scrollX, y: win.scrollY };\n  // const { x, y } = getRectRelativeToOffsetParent(element, win, scroll);\n  const { x, y } = { x: elemRectLeft + scroll.x, y: elemRectTop + scroll.y };\n  // reset arrow style\n  setElementStyle(arrow as HTMLElement, {\n    top: '',\n    left: '',\n    right: '',\n    bottom: '',\n  });\n  let topPosition: number | string = 0;\n  let leftPosition: number | string = 0;\n  let rightPosition: number | string = 0;\n  let arrowTop: number | string = 0;\n  let arrowLeft: number | string = 0;\n  let arrowRight: number | string = 0;\n\n  const arrowWidth = (arrow as HTMLElement).offsetWidth || 0;\n  const arrowHeight = (arrow as HTMLElement).offsetHeight || 0;\n  const arrowAdjust = arrowWidth / 2;\n\n  // check placement\n  let topExceed = elemRectTop - tipHeight - arrowHeight < 0;\n  let bottomExceed = elemRectTop + tipHeight + elemHeight + arrowHeight >= htmlch;\n  let leftExceed = elemRectLeft - tipWidth - arrowWidth < leftBoundry;\n  let rightExceed = elemRectLeft + tipWidth + elemWidth + arrowWidth >= rightBoundry;\n\n  const horizontal = ['left', 'right'];\n  const vertical = ['top', 'bottom'];\n\n  topExceed = horizontal.includes(placement)\n    ? elemRectTop + elemHeight / 2 - tipHeight / 2 - arrowHeight < 0\n    : topExceed;\n  bottomExceed = horizontal.includes(placement)\n    ? elemRectTop + tipHeight / 2 + elemHeight / 2 + arrowHeight >= htmlch\n    : bottomExceed;\n  leftExceed = vertical.includes(placement) ? elemRectLeft + elemWidth / 2 - tipWidth / 2 < leftBoundry : leftExceed;\n  rightExceed = vertical.includes(placement)\n    ? elemRectLeft + tipWidth / 2 + elemWidth / 2 >= rightBoundry\n    : rightExceed;\n\n  // first remove side positions if both left and right limits are exceeded\n  // we usually fall back to top|bottom\n  placement = horizontal.includes(placement) && leftExceed && rightExceed ? 'top' : placement;\n  // second, recompute placement\n  placement = placement === 'top' && topExceed ? 'bottom' : placement;\n  placement = placement === 'bottom' && bottomExceed ? 'top' : placement;\n  placement = placement === 'left' && leftExceed ? 'right' : placement;\n  placement = placement === 'right' && rightExceed ? 'left' : placement;\n\n  // update tooltip/popover class\n  if (!tooltip.className.includes(placement)) {\n    tooltip.className = tooltip.className.replace(tipClasses, tipPositions[placement]);\n  }\n\n  // compute tooltip / popover coordinates\n  /* istanbul ignore else */\n  if (horizontal.includes(placement)) {\n    // secondary|side positions\n    if (placement === 'left') {\n      // LEFT\n      leftPosition = x - tipWidth - (isPopover ? arrowWidth : 0);\n    } else {\n      // RIGHT\n      leftPosition = x + elemWidth + (isPopover ? arrowWidth : 0);\n    }\n\n    // adjust top and arrow\n    if (topExceed) {\n      topPosition = y;\n      // topPosition += isSticky ? -parentTop - scroll.y : 0;\n\n      arrowTop = elemHeight / 2 - arrowWidth;\n    } else if (bottomExceed) {\n      topPosition = y - tipHeight + elemHeight;\n      // topPosition += isSticky ? -parentTop - scroll.y : 0;\n\n      arrowTop = tipHeight - elemHeight / 2 - arrowWidth;\n    } else {\n      topPosition = y - tipHeight / 2 + elemHeight / 2;\n      // topPosition += isSticky ? -parentTop - scroll.y : 0;\n\n      arrowTop = tipHeight / 2 - arrowHeight / 2;\n    }\n  } else if (vertical.includes(placement)) {\n    if (e && isMedia(element)) {\n      let eX = 0;\n      let eY = 0;\n      if (staticParent) {\n        eX = e.pageX;\n        eY = e.pageY;\n      } else {\n        // fixedParent | stickyParent\n        eX = e.clientX - parentLeft + (fixedParent ? scroll.x : 0);\n        eY = e.clientY - parentTop + (fixedParent ? scroll.y : 0);\n      }\n\n      // some weird RTL bug\n      eX -= RTL && fixedParent && scrollbarWidth ? scrollbarWidth : 0;\n\n      if (placement === 'top') {\n        topPosition = eY - tipHeight - arrowWidth;\n      } else {\n        topPosition = eY + arrowWidth;\n      }\n\n      // adjust (left | right) and also the arrow\n      if (e.clientX - tipWidth / 2 < leftBoundry) {\n        leftPosition = 0;\n        arrowLeft = eX - arrowAdjust;\n      } else if (e.clientX + tipWidth / 2 > rightBoundry) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = rightBoundry - eX - arrowAdjust;\n        arrowRight -= fixedParent ? parentLeft + (RTL ? scrollbarWidth : 0) : 0;\n\n        // normal top/bottom\n      } else {\n        leftPosition = eX - tipWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    } else {\n      if (placement === 'top') {\n        topPosition = y - tipHeight - (isPopover ? arrowHeight : 0);\n      } else {\n        // BOTTOM\n        topPosition = y + elemHeight + (isPopover ? arrowHeight : 0);\n      }\n\n      // adjust left | right and also the arrow\n      if (leftExceed) {\n        leftPosition = 0;\n        arrowLeft = x + elemWidth / 2 - arrowAdjust;\n      } else if (rightExceed) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = elemWidth / 2 + rightBoundry - elemRectRight - arrowAdjust;\n      } else {\n        leftPosition = x - tipWidth / 2 + elemWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    }\n  }\n\n  // apply style to tooltip/popover\n  setElementStyle(tooltip, {\n    top: `${topPosition}px`,\n    left: leftPosition === 'auto' ? leftPosition : `${leftPosition}px`,\n    right: rightPosition !== undefined ? `${rightPosition}px` : '',\n  });\n\n  // update arrow placement\n  /* istanbul ignore else */\n  if (isHTMLElement(arrow)) {\n    if (arrowTop !== undefined) {\n      arrow.style.top = `${arrowTop}px`;\n    }\n    if (arrowLeft !== undefined) {\n      arrow.style.left = `${arrowLeft}px`;\n    } else if (arrowRight !== undefined) {\n      arrow.style.right = `${arrowRight}px`;\n    }\n  }\n  // console.log(tooltip, leftPosition, rightPosition, arrowLeft);\n};\n\nexport default styleTip;\n","import getTipTemplate from './getTipTemplate';\nimport tooltipString from '../strings/tooltipString';\nimport { TooltipOptions } from '../interface/tooltip';\n\nconst tooltipDefaults: TooltipOptions = {\n  template: getTipTemplate(tooltipString),\n  title: '',\n  customClass: '',\n  trigger: 'hover focus',\n  placement: 'top',\n  sanitizeFn: undefined,\n  animation: true,\n  delay: 200,\n  container: document.body,\n  content: '',\n  dismissible: false,\n  btnClose: '',\n};\nexport default tooltipDefaults;\n","/**\n * Global namespace for `data-bs-title` attribute.\n */\nconst dataOriginalTitle = 'data-original-title';\nexport default dataOriginalTitle;\n","/** @type {string} */\nconst tooltipComponent = 'Tooltip';\nexport default tooltipComponent;\n","// import {getWindow} from '@thednp/shorty';\nimport { isNode, isArray, isFunction, isString, isNodeList, isHTMLElement } from '@thednp/shorty';\n\n/**\n * Append an existing `Element` to Popover / Tooltip component or HTML\n * markup string to be parsed & sanitized to be used as popover / tooltip content.\n *\n * @param element target\n * @param content the `Element` to append / string\n * @param sanitizeFn a function to sanitize string content\n */\nconst setHtml = (element: Node, content: Node[] | Node | string, sanitizeFn?: (s: string) => string) => {\n  /* istanbul ignore next */\n  if (!isHTMLElement(element) || (isString(content) && !content.length)) return;\n\n  /* istanbul ignore else */\n  if (isString(content)) {\n    let dirty = content.trim(); // fixing #233\n    if (isFunction(sanitizeFn)) dirty = sanitizeFn(dirty);\n\n    // const win = getWindow(element);\n    const domParser = new DOMParser();\n    const tempDocument = domParser.parseFromString(dirty, 'text/html');\n    element.append(...[...tempDocument.body.childNodes]);\n  } else if (isHTMLElement(content)) {\n    element.append(content);\n  } else if (isNodeList(content) || (isArray(content) && content.every(isNode))) {\n    element.append(...[...content]);\n  }\n};\nexport default setHtml;\n","import { createElement, addClass, hasClass, setAttribute, querySelector, isRTL, isHTMLElement } from '@thednp/shorty';\n\nimport tooltipComponent from '../strings/tooltipComponent';\nimport tooltipString from '../strings/tooltipString';\nimport popoverString from '../strings/popoverString';\nimport fadeClass from '../strings/fadeClass';\nimport tipClassPositions from './tipClassPositions';\nimport setHtml from './setHtml';\nimport Tooltip from '../components/tooltip';\nimport Popover from '../components/popover';\n\n/**\n * Creates a new tooltip / popover.\n *\n * @param self the `Tooltip` / `Popover` instance\n */\nconst createTip = (self: Tooltip | Popover) => {\n  const isTooltip = self.name === tooltipComponent;\n\n  const { id, element, options } = self;\n  const { title, placement, template, animation, customClass, sanitizeFn, dismissible, content, btnClose } = options;\n  const tipString = isTooltip ? tooltipString : popoverString;\n  const tipPositions = { ...tipClassPositions };\n  let titleParts: Node[] = [];\n  let contentParts: Node[] = [];\n\n  if (isRTL(element)) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n\n  // set initial popover class\n  const placementClass = `bs-${tipString}-${tipPositions[placement]}`;\n\n  // load template\n  let tooltipTemplate: Node | string;\n  if (isHTMLElement(template)) {\n    tooltipTemplate = template;\n  } else {\n    const htmlMarkup = createElement('div') as HTMLElement;\n    setHtml(htmlMarkup, template, sanitizeFn);\n    tooltipTemplate = htmlMarkup.firstChild as HTMLElement;\n  }\n\n  // set popover markup\n  self.tooltip = isHTMLElement(tooltipTemplate) ? (tooltipTemplate.cloneNode(true) as HTMLElement) : undefined;\n\n  const { tooltip } = self;\n  if (!tooltip) return;\n\n  // set id and role attributes\n  setAttribute(tooltip, 'id', id);\n  setAttribute(tooltip, 'role', tooltipString);\n\n  const bodyClass = isTooltip ? `${tooltipString}-inner` : `${popoverString}-body`;\n  const tooltipHeader = isTooltip ? null : querySelector(`.${popoverString}-header`, tooltip);\n  const tooltipBody = querySelector(`.${bodyClass}`, tooltip);\n\n  // set arrow and enable access for styleTip\n  self.arrow = querySelector(`.${tipString}-arrow`, tooltip) as HTMLElement;\n  const { arrow } = self;\n\n  if (isHTMLElement(title)) titleParts = [title.cloneNode(true)];\n  else {\n    const tempTitle = createElement('div') as Node;\n    setHtml(tempTitle, title, sanitizeFn);\n    titleParts = [...[...tempTitle.childNodes]];\n  }\n\n  if (isHTMLElement(content)) contentParts = [content.cloneNode(true)];\n  else {\n    const tempContent = createElement('div') as Node;\n    setHtml(tempContent, content, sanitizeFn);\n    contentParts = [...[...tempContent.childNodes]];\n  }\n\n  // set dismissible button\n  if (dismissible) {\n    if (title) {\n      if (isHTMLElement(btnClose)) titleParts = [...titleParts, btnClose.cloneNode(true)];\n      else {\n        const tempBtn = createElement('div') as Node;\n        setHtml(tempBtn, btnClose, sanitizeFn);\n        titleParts = [...titleParts, tempBtn.firstChild as Node];\n      }\n    } else {\n      /* istanbul ignore else */\n      if (tooltipHeader) tooltipHeader.remove();\n      if (isHTMLElement(btnClose)) contentParts = [...contentParts, btnClose.cloneNode(true)];\n      else {\n        const tempBtn = createElement('div') as Node;\n        setHtml(tempBtn, btnClose, sanitizeFn);\n        contentParts = [...contentParts, tempBtn.firstChild as Node];\n      }\n    }\n  }\n\n  // fill the template with content from options / data attributes\n  // also sanitize title && content\n  /* istanbul ignore else */\n  if (!isTooltip) {\n    /* istanbul ignore else */\n    if (title && tooltipHeader) setHtml(tooltipHeader, titleParts, sanitizeFn);\n    /* istanbul ignore else */\n    if (content && tooltipBody) setHtml(tooltipBody, contentParts, sanitizeFn);\n    // set btn\n    self.btn = querySelector('.btn-close', tooltip) || undefined;\n  } else if (title && tooltipBody) setHtml(tooltipBody, title, sanitizeFn);\n\n  // Bootstrap 5.2.x\n  addClass(tooltip, 'position-absolute');\n  addClass(arrow, 'position-absolute');\n\n  // set popover animation and placement\n  /* istanbul ignore else */\n  if (!hasClass(tooltip, tipString)) addClass(tooltip, tipString);\n  /* istanbul ignore else */\n  if (animation && !hasClass(tooltip, fadeClass)) addClass(tooltip, fadeClass);\n  /* istanbul ignore else */\n  if (customClass && !hasClass(tooltip, customClass)) {\n    addClass(tooltip, customClass);\n  }\n  /* istanbul ignore else */\n  if (!hasClass(tooltip, placementClass)) addClass(tooltip, placementClass);\n};\n\nexport default createTip;\n","/* Native JavaScript for Bootstrap 5 | Tooltip\n---------------------------------------------- */\nimport {\n  ariaDescribedBy,\n  focusoutEvent,\n  focusinEvent,\n  focusEvent,\n  mousemoveEvent,\n  mouseleaveEvent,\n  mouseenterEvent,\n  mousedownEvent,\n  mouseclickEvent,\n  closest,\n  getUID,\n  getDocument,\n  getWindow,\n  removeAttribute,\n  getAttribute,\n  setAttribute,\n  hasAttribute,\n  touchstartEvent,\n  resizeEvent,\n  scrollEvent,\n  mousehoverEvent,\n  toLowerCase,\n  focus,\n  Timer,\n  emulateTransitionEnd,\n  passiveHandler,\n  dispatchEvent,\n  isApple,\n  isMedia,\n  isFunction,\n  getInstance,\n  ObjectAssign,\n  createCustomEvent,\n  removeClass,\n  hasClass,\n  addClass,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport dataBsToggle from '../strings/dataBsToggle';\nimport dataOriginalTitle from '../strings/dataOriginalTitle';\nimport showClass from '../strings/showClass';\nimport tooltipString from '../strings/tooltipString';\nimport tooltipComponent from '../strings/tooltipComponent';\nimport popoverString from '../strings/popoverString';\nimport popoverComponent from '../strings/popoverComponent';\nimport modalString from '../strings/modalString';\nimport offcanvasString from '../strings/offcanvasString';\n\nimport styleTip from '../util/styleTip';\nimport createTip from '../util/createTip';\nimport { appendPopup, removePopup, hasPopup } from '../util/popupContainer';\n// import isVisibleTip from '../util/isVisibleTip';\n// import getElementContainer from '../util/getElementContainer';\nimport tooltipDefaults from '../util/tooltipDefaults';\nimport BaseComponent from './base-component';\nimport { TooltipOptions, TooltipEvent } from '../interface/tooltip';\nimport { PopoverOptions, PopoverEvent } from '../interface/popover';\n\n// TOOLTIP PRIVATE GC\n// ==================\nconst tooltipSelector = `[${dataBsToggle}=\"${tooltipString}\"],[data-tip=\"${tooltipString}\"]`;\nconst titleAttr = 'title';\n\n/**\n * Static method which returns an existing `Tooltip` instance associated\n * to a target `Element`.\n *\n */\nlet getTooltipInstance = (element: HTMLElement) => getInstance<Tooltip>(element, tooltipComponent);\n\n/**\n * A `Tooltip` initialization callback.\n */\nconst tooltipInitCallback = (element: HTMLElement) => new Tooltip(element);\n\n// TOOLTIP PRIVATE METHODS\n// =======================\n/**\n * Removes the tooltip from the DOM.\n *\n * @param self the `Tooltip` instance\n */\nconst removeTooltip = (self: Tooltip) => {\n  const { element, tooltip } = self;\n  removeAttribute(element, ariaDescribedBy);\n  removePopup(tooltip);\n  // tooltip?.remove();\n};\n\n/**\n * Executes after the instance has been disposed.\n *\n * @param self the `Tooltip` instance\n * @param callback the parent dispose callback\n */\nconst disposeTooltipComplete = (self: Tooltip, callback?: () => void) => {\n  const { element } = self;\n  toggleTooltipHandlers(self);\n\n  /* istanbul ignore else */\n  if (hasAttribute(element, dataOriginalTitle) && self.name === tooltipComponent) {\n    toggleTooltipTitle(self);\n  }\n  /* istanbul ignore else */\n  if (callback) callback();\n};\n\n/**\n * Toggles on/off the special `Tooltip` event listeners.\n *\n * @param self the `Tooltip` instance\n * @param add when `true`, event listeners are added\n */\nconst toggleTooltipAction = (self: Tooltip, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n\n  action(getDocument(element), touchstartEvent, self.handleTouch as EventListener, passiveHandler);\n\n  /* istanbul ignore else */\n  if (!isMedia(element)) {\n    [scrollEvent, resizeEvent].forEach(ev => {\n      action(getWindow(element), ev, self.update, passiveHandler);\n    });\n  }\n};\n\n/**\n * Executes after the tooltip was shown to the user.\n *\n * @param self the `Tooltip` instance\n */\nconst tooltipShownAction = (self: Tooltip) => {\n  const { element } = self;\n  const shownTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`shown.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self, true);\n  dispatchEvent(element, shownTooltipEvent);\n  Timer.clear(element, 'in');\n};\n\n/**\n * Executes after the tooltip was hidden to the user.\n *\n * @param self the `Tooltip` instance\n * @param callback the dispose callback\n */\nconst tooltipHiddenAction = (self: Tooltip, callback?: () => any) => {\n  const { element } = self;\n  const hiddenTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`hidden.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self);\n  removeTooltip(self);\n  dispatchEvent(element, hiddenTooltipEvent);\n  if (isFunction(callback)) callback();\n  Timer.clear(element, 'out');\n};\n\n/**\n * Toggles on/off the `Tooltip` event listeners.\n *\n * @param self the `Tooltip` instance\n * @param add when `true`, event listeners are added\n */\nconst toggleTooltipHandlers = (self: Tooltip, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  // btn is only for dismissible popover\n  const { element, options, btn } = self;\n  const { trigger } = options;\n  const isPopover = self.name !== tooltipComponent;\n  const dismissible = isPopover && (options as PopoverOptions).dismissible ? true : false;\n\n  if (trigger?.includes('manual')) return;\n\n  self.enabled = !!add;\n\n  const triggerOptions = trigger?.split(' ');\n  const elemIsMedia = isMedia(element);\n\n  if (elemIsMedia) {\n    action(element, mousemoveEvent, self.update, passiveHandler);\n  }\n\n  triggerOptions?.forEach(tr => {\n    /* istanbul ignore else */\n    if (elemIsMedia || tr === mousehoverEvent) {\n      action(element, mousedownEvent, self.show);\n      action(element, mouseenterEvent, self.show);\n\n      /* istanbul ignore else */\n      if (dismissible && btn) {\n        action(btn, mouseclickEvent, self.hide);\n      } else {\n        action(element, mouseleaveEvent, self.hide);\n        action(getDocument(element), touchstartEvent, self.handleTouch as EventListener, passiveHandler);\n      }\n    } else if (tr === mouseclickEvent) {\n      action(element, tr, !dismissible ? self.toggle : self.show);\n    } else if (tr === focusEvent) {\n      action(element, focusinEvent, self.show);\n      /* istanbul ignore else */\n      if (!dismissible) action(element, focusoutEvent, self.hide);\n      /* istanbul ignore else */\n      if (isApple) {\n        action(element, mouseclickEvent, () => focus(element));\n      }\n    }\n  });\n};\n\n/**\n * Toggles on/off the `Tooltip` event listeners that hide/update the tooltip.\n *\n * @param self the `Tooltip` instance\n * @param add when `true`, event listeners are added\n */\nconst toggleTooltipOpenHandlers = (self: Tooltip, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n  // const { offsetHeight, scrollHeight } = popupContainer;\n  const parentModal = closest(element, `.${modalString}`);\n  const parentOffcanvas = closest(element, `.${offcanvasString}`);\n\n  /* istanbul ignore else */\n  if (!isMedia(element)) {\n    const win = getWindow(element);\n    // const overflow = offsetHeight !== scrollHeight;\n    // const scrollTarget = overflow || offsetParent !== win ? popupContainer : win;\n    action(win, resizeEvent, self.update, passiveHandler);\n    action(win, scrollEvent, self.update, passiveHandler);\n  }\n\n  // dismiss tooltips inside modal / offcanvas\n  if (parentModal) action(parentModal, `hide.bs.${modalString}`, self.hide);\n  if (parentOffcanvas) action(parentOffcanvas, `hide.bs.${offcanvasString}`, self.hide);\n};\n\n/**\n * Toggles the `title` and `data-original-title` attributes.\n *\n * @param self the `Tooltip` instance\n * @param content when `true`, event listeners are added\n */\nconst toggleTooltipTitle = (self: Tooltip, content?: string) => {\n  // [0 - add, 1 - remove] | [0 - remove, 1 - add]\n  const titleAtt = [dataOriginalTitle, titleAttr];\n  const { element } = self;\n\n  setAttribute(element, titleAtt[content ? 0 : 1], content || getAttribute(element, titleAtt[0]) || '');\n  removeAttribute(element, titleAtt[content ? 1 : 0]);\n};\n\n// TOOLTIP DEFINITION\n// ==================\n/** Creates a new `Tooltip` instance. */\nexport default class Tooltip extends BaseComponent {\n  static selector = tooltipSelector;\n  static init = tooltipInitCallback;\n  static getInstance = getTooltipInstance;\n  static styleTip = styleTip;\n  declare options: TooltipOptions;\n  declare btn?: HTMLElement;\n  declare tooltip?: HTMLElement;\n  declare arrow?: HTMLElement;\n  declare offsetParent?: HTMLElement | Window;\n  declare enabled: boolean;\n  declare id: string;\n\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<TooltipOptions>) {\n    super(target, config);\n\n    const { element } = this;\n    const isTooltip = this.name === tooltipComponent;\n    const tipString = isTooltip ? tooltipString : popoverString;\n    const tipComponent = isTooltip ? tooltipComponent : popoverComponent;\n\n    /* istanbul ignore next: this is to set Popover too */\n    getTooltipInstance = <T extends Tooltip>(elem: HTMLElement) => getInstance<T>(elem, tipComponent);\n\n    // additional properties\n    this.enabled = true;\n    /** Set unique ID for `aria-describedby`. */\n    this.id = `${tipString}-${getUID(element, tipString)}`;\n\n    // instance options\n    const { options } = this;\n\n    // invalidate\n    if ((!options.title && isTooltip) || (!isTooltip && !options.content)) {\n      // throw Error(`${this.name} Error: target has no content set.`);\n      return;\n    }\n\n    // reset default options\n    ObjectAssign(tooltipDefaults, { titleAttr: '' });\n\n    // all functions bind\n    this.handleTouch = this.handleTouch.bind(this);\n    this.update = this.update.bind(this);\n    this.show = this.show.bind(this);\n    this.hide = this.hide.bind(this);\n    this.toggle = this.toggle.bind(this);\n\n    // set title attributes and add event listeners\n    /* istanbul ignore else */\n    if (hasAttribute(element, titleAttr) && isTooltip) {\n      toggleTooltipTitle(this, options.title);\n    }\n\n    // create tooltip here\n    createTip(this);\n\n    // attach events\n    toggleTooltipHandlers(this, true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return tooltipComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return tooltipDefaults;\n  }\n\n  // TOOLTIP PUBLIC METHODS\n  // ======================\n  /**\n   * Shows the tooltip.\n   *\n   * @param e the `Event` object\n   */\n  show(e?: Event) {\n    const { options, tooltip, element, id } = this;\n    const { animation } = options;\n    const outTimer = Timer.get(element, 'out');\n\n    Timer.clear(element, 'out');\n\n    if (tooltip && !outTimer && !hasPopup(tooltip)) {\n      Timer.set(\n        element,\n        () => {\n          const showTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`show.bs.${toLowerCase(this.name)}`);\n          dispatchEvent(element, showTooltipEvent);\n          if (showTooltipEvent.defaultPrevented) return;\n\n          // append to container\n          appendPopup(tooltip);\n\n          setAttribute(element, ariaDescribedBy, `#${id}`);\n\n          this.update(e);\n          toggleTooltipOpenHandlers(this, true);\n\n          /* istanbul ignore else */\n          if (!hasClass(tooltip, showClass)) addClass(tooltip, showClass);\n          /* istanbul ignore else */\n          if (animation) emulateTransitionEnd(tooltip, () => tooltipShownAction(this));\n          else tooltipShownAction(this);\n        },\n        17,\n        'in',\n      );\n    }\n  }\n\n  /**\n   * Hides the tooltip.\n   *\n   * @param e the dispose callback\n   * @param callback the dispose callback\n   */\n  hide(e?: Event, callback?: () => void) {\n    const { options, tooltip, element } = this;\n    const { animation, delay } = options;\n\n    Timer.clear(element, 'in');\n\n    /* istanbul ignore else */\n    if (tooltip && hasPopup(tooltip)) {\n      Timer.set(\n        element,\n        () => {\n          const hideTooltipEvent = createCustomEvent<TooltipEvent | PopoverEvent>(`hide.bs.${toLowerCase(this.name)}`);\n          dispatchEvent(element, hideTooltipEvent);\n\n          if (hideTooltipEvent.defaultPrevented) return;\n\n          this.update(e); // use Event\n          removeClass(tooltip, showClass);\n          toggleTooltipOpenHandlers(this);\n\n          /* istanbul ignore else */\n          if (animation) emulateTransitionEnd(tooltip, () => tooltipHiddenAction(this, callback));\n          else tooltipHiddenAction(this, callback);\n        },\n        delay + 17,\n        'out',\n      );\n    }\n  }\n\n  /**\n   * Updates the tooltip position.\n   *\n   * @param e the `Event` object\n   */\n  update(e?: Event) {\n    styleTip<Tooltip>(this, e as (Event & PointerEvent) | undefined);\n  }\n\n  /**\n   * Toggles the tooltip visibility.\n   *\n   * @param e the `Event` object\n   */\n  toggle(e?: Event) {\n    const { tooltip } = this;\n\n    if (tooltip && !hasPopup(tooltip)) this.show(e);\n    else this.hide();\n  }\n\n  /** Enables the tooltip. */\n  enable() {\n    const { enabled } = this;\n    /* istanbul ignore else */\n    if (!enabled) {\n      toggleTooltipHandlers(this, true);\n      this.enabled = !enabled;\n    }\n  }\n\n  /** Disables the tooltip. */\n  disable() {\n    const { tooltip, options, enabled } = this;\n    const { animation } = options;\n    /* istanbul ignore else */\n    if (enabled) {\n      if (tooltip && hasPopup(tooltip) && animation) {\n        this.hide(undefined, () => toggleTooltipHandlers(this));\n      } else {\n        toggleTooltipHandlers(this);\n      }\n      this.enabled = !enabled;\n    }\n  }\n\n  /** Toggles the `disabled` property. */\n  toggleEnabled() {\n    if (!this.enabled) this.enable();\n    else this.disable();\n  }\n\n  /**\n   * Handles the `touchstart` event listener for `Tooltip`\n   *\n   * @this {Tooltip}\n   * @param {TouchEvent} e the `Event` object\n   */\n  handleTouch({ target }: TouchEvent) {\n    const { tooltip, element } = this;\n\n    /* istanbul ignore next */\n    if (\n      (tooltip && tooltip.contains(target as HTMLElement)) ||\n      target === element ||\n      (target && element.contains(target as HTMLElement))\n    ) {\n      // smile for ESLint\n    } else {\n      this.hide();\n    }\n  }\n\n  /** Removes the `Tooltip` from the target element. */\n  dispose() {\n    const { tooltip, options } = this;\n    const callback = () => disposeTooltipComplete(this, () => super.dispose());\n\n    if (options.animation && tooltip && hasPopup(tooltip)) {\n      this.options.delay = 0; // reset delay\n      this.hide(undefined, callback);\n    } else {\n      callback();\n    }\n  }\n}\n"],"names":["popoverString","popoverComponent","tooltipString","getTipTemplate","tipType","isTooltip","bodyClass","header","arrow","body","tipClassPositions","styleTip","self","e","tipClasses","element","tooltip","options","tipPositions","RTL","isRTL","setElementStyle","isPopover","tipWidth","tipHeight","htmlcw","htmlch","getDocumentElement","placement","parentLeft","parentRight","parentTop","getBoundingClientRect","popupContainer","parentCWidth","parentOWidth","scrollbarWidth","parentPosition","getElementStyle","fixedParent","staticParent","leftBoundry","rightBoundry","elemWidth","elemHeight","elemRectLeft","elemRectRight","elemRectTop","win","getWindow","scroll","x","y","topPosition","leftPosition","rightPosition","arrowTop","arrowLeft","arrowRight","arrowWidth","arrowHeight","arrowAdjust","topExceed","bottomExceed","leftExceed","rightExceed","horizontal","vertical","isMedia","eX","eY","isHTMLElement","tooltipDefaults","dataOriginalTitle","tooltipComponent","setHtml","content","sanitizeFn","isString","dirty","isFunction","tempDocument","isNodeList","isArray","isNode","createTip","id","title","template","animation","customClass","dismissible","btnClose","tipString","titleParts","contentParts","placementClass","tooltipTemplate","htmlMarkup","createElement","setAttribute","tooltipHeader","querySelector","tooltipBody","tempTitle","tempContent","tempBtn","addClass","hasClass","fadeClass","tooltipSelector","dataBsToggle","titleAttr","getTooltipInstance","getInstance","tooltipInitCallback","Tooltip","removeTooltip","removeAttribute","ariaDescribedBy","removePopup","disposeTooltipComplete","callback","toggleTooltipHandlers","hasAttribute","toggleTooltipTitle","toggleTooltipAction","add","action","addListener","removeListener","getDocument","touchstartEvent","passiveHandler","scrollEvent","resizeEvent","ev","tooltipShownAction","shownTooltipEvent","createCustomEvent","toLowerCase","dispatchEvent","Timer","tooltipHiddenAction","hiddenTooltipEvent","btn","trigger","triggerOptions","elemIsMedia","mousemoveEvent","tr","mousehoverEvent","mousedownEvent","mouseenterEvent","mouseclickEvent","mouseleaveEvent","focusEvent","focusinEvent","focusoutEvent","isApple","focus","toggleTooltipOpenHandlers","parentModal","closest","modalString","parentOffcanvas","offcanvasString","titleAtt","getAttribute","BaseComponent","target","config","tipComponent","elem","getUID","ObjectAssign","outTimer","hasPopup","showTooltipEvent","appendPopup","showClass","emulateTransitionEnd","delay","hideTooltipEvent","removeClass","enabled"],"mappings":"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"}