{"version":3,"file":"offcanvas.cjs","sources":["../../src/components/offcanvas.ts"],"sourcesContent":["/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\nimport {\n  addClass,\n  ariaHidden,\n  ariaModal,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  emulateTransitionEnd,\n  focus,\n  getDocument,\n  getDocumentBody,\n  getDocumentElement,\n  getElementTransitionDuration,\n  getInstance,\n  hasClass,\n  keydownEvent,\n  keyEscape,\n  mouseclickEvent,\n  querySelector,\n  querySelectorAll,\n  removeAttribute,\n  removeClass,\n  setAttribute,\n  setElementStyle,\n  toggleFocusTrap,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport dataBsDismiss from '../strings/dataBsDismiss';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport showClass from '../strings/showClass';\nimport offcanvasString from '../strings/offcanvasString';\nimport offcanvasComponent from '../strings/offcanvasComponent';\nimport modalComponent from '../strings/modalComponent';\n\nimport getTargetElement from '../util/getTargetElement';\nimport isVisible from '../util/isVisible';\nimport { setScrollbar } from '../util/scrollbar';\nimport { hasPopup } from '../util/popupContainer';\nimport {\n  appendOverlay,\n  getCurrentOpen,\n  hideOverlay,\n  offcanvasActiveSelector,\n  overlay,\n  removeOverlay,\n  showOverlay,\n  toggleOverlayType,\n} from '../util/backdrop';\nimport BaseComponent from './base-component';\nimport { OffcanvasEvent, OffcanvasOptions } from '../interface/offcanvas';\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\ntype OffCanvasEventProps = {\n  relatedTarget: HTMLElement | undefined;\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n */\nconst getOffcanvasInstance = (element: HTMLElement) => getInstance<Offcanvas>(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n */\nconst offcanvasInitCallback = (element: HTMLElement) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = createCustomEvent<OffCanvasEventProps, OffcanvasEvent>(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = createCustomEvent<OffCanvasEventProps, OffcanvasEvent>(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = createCustomEvent<OffCanvasEventProps, OffcanvasEvent>(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = createCustomEvent<OffCanvasEventProps, OffcanvasEvent>(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param self the `Offcanvas` instance\n */\nconst setOffCanvasScrollbar = (self: Offcanvas) => {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param self the `Offcanvas` instance\n * @param add when *true* listeners are added\n */\nconst toggleOffCanvasDismiss = (self: Offcanvas, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n};\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasShow = (self: Offcanvas) => {\n  const { element, options } = self;\n\n  // istanbul ignore else @preserve\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: 'visible' });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n};\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasHide = (self: Offcanvas) => {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  element.blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n  }\n  emulateTransitionEnd(element, () => hideOffcanvasComplete(self));\n};\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @param e the `Event` object\n */\nconst offcanvasTriggerHandler = (e: MouseEvent) => {\n  const trigger = closest(e.target as HTMLElement, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    self.relatedTarget = trigger;\n    self.toggle();\n    // istanbul ignore else @preserve\n    if (trigger && trigger.tagName === 'A') {\n      e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param e the `Event` object\n */\nconst offcanvasDismissHandler = (e: MouseEvent) => {\n  const { target } = e;\n  const element = querySelector(offcanvasActiveSelector, getDocument(target as Node));\n  const offCanvasDismiss = querySelector(offcanvasDismissSelector, element as HTMLElement | undefined);\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    const { options, triggers } = self;\n    const { backdrop } = options;\n    const trigger = closest(target as HTMLElement, offcanvasToggleSelector);\n    const selection = getDocument(element).getSelection();\n\n    // istanbul ignore else: a filter is required here @preserve\n    if (!overlay.contains(target as HTMLElement) || backdrop !== 'static') {\n      // istanbul ignore else @preserve\n      if (\n        !(selection && selection.toString().length) &&\n        ((!element.contains(target as HTMLElement) &&\n          backdrop &&\n          // istanbul ignore next @preserve\n          (!trigger || triggers.includes(target as HTMLElement))) ||\n          (offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement)))\n      ) {\n        self.relatedTarget =\n          offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement) ? offCanvasDismiss : null;\n        self.hide();\n      }\n\n      // istanbul ignore next @preserve\n      if (trigger && trigger.tagName === 'A') e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst offcanvasKeyDismissHandler = ({ code, target }: KeyboardEvent) => {\n  const element = querySelector(offcanvasActiveSelector, getDocument(target as Node));\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    // istanbul ignore else @preserve\n    if (self.options.keyboard && code === keyEscape) {\n      self.relatedTarget = null;\n      self.hide();\n    }\n  }\n};\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst showOffcanvasComplete = (self: Offcanvas) => {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n  setAttribute(element, 'role', 'dialog');\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n  toggleFocusTrap(element);\n};\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst hideOffcanvasComplete = (self: Offcanvas) => {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, 'true');\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, 'role');\n  setElementStyle(element, { visibility: '' });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget || triggers.find(isVisible);\n  // istanbul ignore else @preserve\n  if (visibleTrigger) focus(visibleTrigger as HTMLElement);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n  toggleFocusTrap(element);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n};\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nexport default class Offcanvas extends BaseComponent {\n  static selector = offcanvasSelector;\n  static init = offcanvasInitCallback;\n  static getInstance = getOffcanvasInstance;\n  declare options: OffcanvasOptions;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: HTMLElement | null;\n\n  /**\n   * @param target usually an `.offcanvas` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<OffcanvasOptions>) {\n    super(target, config);\n\n    // instance element\n    const { element } = this;\n\n    // all the triggering buttons\n    this.triggers = [...querySelectorAll(offcanvasToggleSelector, getDocument(element))].filter(\n      btn => getTargetElement(btn) === element,\n    );\n\n    // additional instance property\n    this.relatedTarget = null;\n\n    // attach event listeners\n    this._toggleEventListeners(true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return offcanvasComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return offcanvasDefaults;\n  }\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const { element, options, relatedTarget } = this;\n    let overlayDelay = 0;\n\n    if (!hasClass(element, showClass)) {\n      showOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      shownOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, showOffcanvasEvent);\n\n      if (!showOffcanvasEvent.defaultPrevented) {\n        // we elegantly hide any opened modal/offcanvas\n        const currentOpen = getCurrentOpen(element);\n        if (currentOpen && currentOpen !== element) {\n          const that =\n            getOffcanvasInstance(currentOpen) ||\n            // istanbul ignore next @preserve\n            getInstance<typeof BaseComponent & { hide: () => void }>(currentOpen, modalComponent);\n\n          // istanbul ignore else @preserve\n          if (that) that.hide();\n        }\n\n        if (options.backdrop) {\n          if (!hasPopup(overlay)) {\n            appendOverlay(element, true);\n          } else {\n            toggleOverlayType();\n          }\n\n          overlayDelay = getElementTransitionDuration(overlay);\n          showOverlay();\n\n          setTimeout(() => beforeOffcanvasShow(this), overlayDelay);\n        } else {\n          beforeOffcanvasShow(this);\n          // istanbul ignore next @preserve - this test was done on Modal\n          if (currentOpen && hasClass(overlay, showClass)) {\n            hideOverlay();\n          }\n        }\n      }\n    }\n  }\n\n  /** Hides the offcanvas from the user. */\n  hide() {\n    const { element, relatedTarget } = this;\n\n    if (hasClass(element, showClass)) {\n      hideOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      hiddenOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, hideOffcanvasEvent);\n      if (!hideOffcanvasEvent.defaultPrevented) {\n        addClass(element, offcanvasTogglingClass);\n        removeClass(element, showClass);\n        beforeOffcanvasHide(this);\n      }\n    }\n  }\n\n  /**\n   * Toggles on/off the `click` event listeners.\n   *\n   * @param self the `Offcanvas` instance\n   * @param add when *true*, listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    this.triggers.forEach(btn => action(btn, mouseclickEvent, offcanvasTriggerHandler));\n  };\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const { element } = this;\n    const isOpen = hasClass(element, showClass);\n    const callback = () => setTimeout(() => super.dispose(), 1);\n\n    this.hide();\n    this._toggleEventListeners();\n\n    if (isOpen) {\n      emulateTransitionEnd(element, callback);\n      // istanbul ignore next @preserve\n    } else {\n      callback();\n    }\n  }\n}\n"],"names":["offcanvasSelector","offcanvasString","offcanvasToggleSelector","dataBsToggle","offcanvasDismissSelector","dataBsDismiss","offcanvasTogglingClass","offcanvasDefaults","getOffcanvasInstance","element","getInstance","offcanvasComponent","offcanvasInitCallback","Offcanvas","showOffcanvasEvent","createCustomEvent","shownOffcanvasEvent","hideOffcanvasEvent","hiddenOffcanvasEvent","setOffCanvasScrollbar","self","clientHeight","scrollHeight","getDocumentElement","setScrollbar","toggleOffCanvasDismiss","add","action","addListener","removeListener","doc","getDocument","keydownEvent","offcanvasKeyDismissHandler","mouseclickEvent","offcanvasDismissHandler","beforeOffcanvasShow","options","setElementStyle","getDocumentBody","addClass","showClass","emulateTransitionEnd","showOffcanvasComplete","beforeOffcanvasHide","currentOpen","getCurrentOpen","hasClass","overlay","hideOverlay","hideOffcanvasComplete","offcanvasTriggerHandler","e","trigger","closest","getTargetElement","target","querySelector","offcanvasActiveSelector","offCanvasDismiss","triggers","backdrop","selection","code","keyEscape","removeClass","removeAttribute","ariaHidden","setAttribute","ariaModal","dispatchEvent","focus","toggleFocusTrap","visibleTrigger","isVisible","removeOverlay","BaseComponent","config","__publicField","btn","querySelectorAll","relatedTarget","overlayDelay","that","modalComponent","hasPopup","toggleOverlayType","appendOverlay","getElementTransitionDuration","showOverlay","isOpen","callback"],"mappings":"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"}