{"version":3,"file":"offcanvas.cjs","sources":["../../src/components/offcanvas.ts"],"sourcesContent":["/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\nimport {\n  ariaHidden,\n  addClass,\n  hasClass,\n  closest,\n  querySelectorAll,\n  querySelector,\n  removeAttribute,\n  setAttribute,\n  keyEscape,\n  keydownEvent,\n  mouseclickEvent,\n  ariaModal,\n  emulateTransitionEnd,\n  dispatchEvent,\n  getElementTransitionDuration,\n  getDocumentBody,\n  getDocumentElement,\n  getDocument,\n  removeClass,\n  setElementStyle,\n  createCustomEvent,\n  focus,\n  getInstance,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport dataBsDismiss from '../strings/dataBsDismiss';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport showClass from '../strings/showClass';\nimport offcanvasString from '../strings/offcanvasString';\nimport offcanvasComponent from '../strings/offcanvasComponent';\nimport modalComponent from '../strings/modalComponent';\n\nimport getTargetElement from '../util/getTargetElement';\nimport isVisible from '../util/isVisible';\nimport { setScrollbar } from '../util/scrollbar';\nimport { hasPopup } from '../util/popupContainer';\nimport {\n  overlay,\n  offcanvasActiveSelector,\n  toggleOverlayType,\n  appendOverlay,\n  showOverlay,\n  hideOverlay,\n  getCurrentOpen,\n  removeOverlay,\n} from '../util/backdrop';\nimport BaseComponent from './base-component';\nimport { OffcanvasOptions, OffcanvasEvent } from '../interface/offcanvas';\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n */\nconst getOffcanvasInstance = (element: HTMLElement) => getInstance<Offcanvas>(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n */\nconst offcanvasInitCallback = (element: HTMLElement) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param self the `Offcanvas` instance\n */\nconst setOffCanvasScrollbar = (self: Offcanvas) => {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param self the `Offcanvas` instance\n * @param add when *true* listeners are added\n */\nconst toggleOffCanvasDismiss = (self: Offcanvas, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n};\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasShow = (self: Offcanvas) => {\n  const { element, options } = self;\n\n  /* istanbul ignore else */\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: 'visible' });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n};\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasHide = (self: Offcanvas) => {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  element.blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n  }\n  emulateTransitionEnd(element, () => hideOffcanvasComplete(self));\n};\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @param e the `Event` object\n */\nconst offcanvasTriggerHandler = (e: MouseEvent) => {\n  const trigger = closest(e.target as HTMLElement, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    self.relatedTarget = trigger;\n    self.toggle();\n    /* istanbul ignore else */\n    if (trigger && trigger.tagName === 'A') {\n      e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param e the `Event` object\n */\nconst offcanvasDismissHandler = (e: MouseEvent) => {\n  const { target } = e;\n  const element = querySelector(offcanvasActiveSelector, getDocument(target as Node));\n  const offCanvasDismiss = querySelector(offcanvasDismissSelector, element as HTMLElement | undefined);\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    const { options, triggers } = self;\n    const { backdrop } = options;\n    const trigger = closest(target as HTMLElement, offcanvasToggleSelector);\n    const selection = getDocument(element).getSelection();\n\n    /* istanbul ignore else: a filter is required here */\n    if (!overlay.contains(target as HTMLElement) || backdrop !== 'static') {\n      /* istanbul ignore else */\n      if (\n        !(selection && selection.toString().length) &&\n        ((!element.contains(target as HTMLElement) &&\n          backdrop &&\n          /* istanbul ignore next */ (!trigger || triggers.includes(target as HTMLElement))) ||\n          (offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement)))\n      ) {\n        self.relatedTarget =\n          offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement) ? offCanvasDismiss : null;\n        self.hide();\n      }\n\n      /* istanbul ignore next */\n      if (trigger && trigger.tagName === 'A') e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst offcanvasKeyDismissHandler = ({ code, target }: KeyboardEvent) => {\n  const element = querySelector(offcanvasActiveSelector, getDocument(target as Node));\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    /* istanbul ignore else */\n    if (self.options.keyboard && code === keyEscape) {\n      self.relatedTarget = null;\n      self.hide();\n    }\n  }\n};\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst showOffcanvasComplete = (self: Offcanvas) => {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n  setAttribute(element, 'role', 'dialog');\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n};\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst hideOffcanvasComplete = (self: Offcanvas) => {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, 'true');\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, 'role');\n  setElementStyle(element, { visibility: '' });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget || triggers.find(isVisible);\n  /* istanbul ignore else */\n  if (visibleTrigger) focus(visibleTrigger as HTMLElement);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n};\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nexport default class Offcanvas extends BaseComponent {\n  static selector = offcanvasSelector;\n  static init = offcanvasInitCallback;\n  static getInstance = getOffcanvasInstance;\n  declare options: OffcanvasOptions;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: HTMLElement | null;\n\n  /**\n   * @param target usually an `.offcanvas` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<OffcanvasOptions>) {\n    super(target, config);\n\n    // instance element\n    const { element } = this;\n\n    // all the triggering buttons\n    this.triggers = [...querySelectorAll(offcanvasToggleSelector, getDocument(element))].filter(\n      btn => getTargetElement(btn) === element,\n    );\n\n    // additional instance property\n    this.relatedTarget = null;\n\n    // attach event listeners\n    this._toggleEventListeners(true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return offcanvasComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return offcanvasDefaults;\n  }\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const { element, options, relatedTarget } = this;\n    let overlayDelay = 0;\n\n    if (!hasClass(element, showClass)) {\n      showOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      shownOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, showOffcanvasEvent);\n\n      if (!showOffcanvasEvent.defaultPrevented) {\n        // we elegantly hide any opened modal/offcanvas\n        const currentOpen = getCurrentOpen(element);\n        if (currentOpen && currentOpen !== element) {\n          const that =\n            getOffcanvasInstance(currentOpen) ||\n            /* istanbul ignore next */\n            getInstance<typeof BaseComponent & { hide: () => void }>(currentOpen, modalComponent);\n          if (that) that.hide();\n        }\n\n        if (options.backdrop) {\n          if (!hasPopup(overlay)) {\n            appendOverlay(element, true);\n          } else {\n            toggleOverlayType();\n          }\n\n          overlayDelay = getElementTransitionDuration(overlay);\n          showOverlay();\n\n          setTimeout(() => beforeOffcanvasShow(this), overlayDelay);\n        } else {\n          beforeOffcanvasShow(this);\n          /* istanbul ignore next - this test was done on Modal */\n          if (currentOpen && hasClass(overlay, showClass)) {\n            hideOverlay();\n          }\n        }\n      }\n    }\n  }\n\n  /** Hides the offcanvas from the user. */\n  hide() {\n    const { element, relatedTarget } = this;\n    // let overlayDelay = 0;\n\n    if (hasClass(element, showClass)) {\n      hideOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      hiddenOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, hideOffcanvasEvent);\n      if (!hideOffcanvasEvent.defaultPrevented) {\n        addClass(element, offcanvasTogglingClass);\n        removeClass(element, showClass);\n        beforeOffcanvasHide(this);\n      }\n    }\n  }\n\n  /**\n   * Toggles on/off the `click` event listeners.\n   *\n   * @param self the `Offcanvas` instance\n   * @param add when *true*, listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    this.triggers.forEach(btn => action(btn, mouseclickEvent, offcanvasTriggerHandler));\n  };\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const clone = { ...this };\n    const { element, options } = clone;\n    const delay = options.backdrop ? getElementTransitionDuration(overlay) : /* istanbul ignore next */ 0;\n    const callback = () => setTimeout(() => super.dispose(), delay + 17);\n    this._toggleEventListeners();\n\n    this.hide();\n    if (hasClass(element, showClass)) {\n      emulateTransitionEnd(element, callback);\n      /* istanbul ignore next */\n    } else {\n      callback();\n    }\n  }\n}\n"],"names":["offcanvasSelector","offcanvasString","offcanvasToggleSelector","dataBsToggle","offcanvasDismissSelector","dataBsDismiss","offcanvasTogglingClass","offcanvasDefaults","getOffcanvasInstance","element","getInstance","offcanvasComponent","offcanvasInitCallback","Offcanvas","showOffcanvasEvent","createCustomEvent","shownOffcanvasEvent","hideOffcanvasEvent","hiddenOffcanvasEvent","setOffCanvasScrollbar","self","clientHeight","scrollHeight","getDocumentElement","setScrollbar","toggleOffCanvasDismiss","add","action","addListener","removeListener","doc","getDocument","keydownEvent","offcanvasKeyDismissHandler","mouseclickEvent","offcanvasDismissHandler","beforeOffcanvasShow","options","setElementStyle","getDocumentBody","addClass","showClass","emulateTransitionEnd","showOffcanvasComplete","beforeOffcanvasHide","currentOpen","getCurrentOpen","hasClass","overlay","hideOverlay","hideOffcanvasComplete","offcanvasTriggerHandler","e","trigger","closest","getTargetElement","target","querySelector","offcanvasActiveSelector","offCanvasDismiss","triggers","backdrop","selection","code","keyEscape","removeClass","removeAttribute","ariaHidden","setAttribute","ariaModal","dispatchEvent","focus","visibleTrigger","isVisible","removeOverlay","BaseComponent","config","__publicField","btn","querySelectorAll","relatedTarget","overlayDelay","that","modalComponent","hasPopup","toggleOverlayType","appendOverlay","getElementTransitionDuration","showOverlay","clone","delay","callback"],"mappings":"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"}