{"version":3,"file":"offcanvas.cjs","sources":["../../src/components/offcanvas.ts"],"sourcesContent":["/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\nimport {\n  addClass,\n  ariaHidden,\n  ariaModal,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  emulateTransitionEnd,\n  focus,\n  getDocument,\n  getDocumentBody,\n  getDocumentElement,\n  getElementTransitionDuration,\n  getInstance,\n  hasClass,\n  keydownEvent,\n  keyEscape,\n  mouseclickEvent,\n  querySelector,\n  querySelectorAll,\n  removeAttribute,\n  removeClass,\n  setAttribute,\n  setElementStyle,\n  toggleFocusTrap,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport dataBsDismiss from \"../strings/dataBsDismiss\";\nimport dataBsToggle from \"../strings/dataBsToggle\";\nimport showClass from \"../strings/showClass\";\nimport offcanvasString from \"../strings/offcanvasString\";\nimport offcanvasComponent from \"../strings/offcanvasComponent\";\nimport modalComponent from \"../strings/modalComponent\";\n\nimport getTargetElement from \"../util/getTargetElement\";\nimport isVisible from \"../util/isVisible\";\nimport { setScrollbar } from \"../util/scrollbar\";\nimport { hasPopup } from \"../util/popupContainer\";\nimport {\n  appendOverlay,\n  getCurrentOpen,\n  hideOverlay,\n  offcanvasActiveSelector,\n  overlay,\n  removeOverlay,\n  showOverlay,\n  toggleOverlayType,\n} from \"../util/backdrop\";\nimport BaseComponent from \"./base-component\";\nimport { OffcanvasEvent, OffcanvasOptions } from \"../interface/offcanvas\";\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\ntype OffCanvasEventProps = {\n  relatedTarget: HTMLElement | undefined;\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n */\nconst getOffcanvasInstance = (element: HTMLElement) =>\n  getInstance<Offcanvas>(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n */\nconst offcanvasInitCallback = (element: HTMLElement) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param self the `Offcanvas` instance\n */\nconst setOffCanvasScrollbar = (self: Offcanvas) => {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param self the `Offcanvas` instance\n * @param add when *true* listeners are added\n */\nconst toggleOffCanvasDismiss = (self: Offcanvas, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n};\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasShow = (self: Offcanvas) => {\n  const { element, options } = self;\n\n  // istanbul ignore else @preserve\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: \"hidden\" });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: \"visible\" });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n};\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasHide = (self: Offcanvas) => {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  element.blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n  }\n  emulateTransitionEnd(element, () => hideOffcanvasComplete(self));\n};\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @param e the `Event` object\n */\nconst offcanvasTriggerHandler = (e: MouseEvent) => {\n  const trigger = closest(e.target as HTMLElement, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    self.relatedTarget = trigger;\n    self.toggle();\n    // istanbul ignore else @preserve\n    if (trigger && trigger.tagName === \"A\") {\n      e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param e the `Event` object\n */\nconst offcanvasDismissHandler = (e: MouseEvent) => {\n  const { target } = e;\n  const element = querySelector(\n    offcanvasActiveSelector,\n    getDocument(target as Node),\n  );\n  const offCanvasDismiss = querySelector(\n    offcanvasDismissSelector,\n    element as HTMLElement | undefined,\n  );\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    const { options, triggers } = self;\n    const { backdrop } = options;\n    const trigger = closest(target as HTMLElement, offcanvasToggleSelector);\n    const selection = getDocument(element).getSelection();\n\n    // istanbul ignore else: a filter is required here @preserve\n    if (!overlay.contains(target as HTMLElement) || backdrop !== \"static\") {\n      // istanbul ignore else @preserve\n      if (\n        !(selection && selection.toString().length) &&\n        ((!element.contains(target as HTMLElement) &&\n          backdrop &&\n          // istanbul ignore next @preserve\n          (!trigger || triggers.includes(target as HTMLElement))) ||\n          (offCanvasDismiss &&\n            offCanvasDismiss.contains(target as HTMLElement)))\n      ) {\n        self.relatedTarget =\n          offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement)\n            ? offCanvasDismiss\n            : null;\n        self.hide();\n      }\n\n      // istanbul ignore next @preserve\n      if (trigger && trigger.tagName === \"A\") e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst offcanvasKeyDismissHandler = ({ code, target }: KeyboardEvent) => {\n  const element = querySelector(\n    offcanvasActiveSelector,\n    getDocument(target as Node),\n  );\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    // istanbul ignore else @preserve\n    if (self.options.keyboard && code === keyEscape) {\n      self.relatedTarget = null;\n      self.hide();\n    }\n  }\n};\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst showOffcanvasComplete = (self: Offcanvas) => {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, \"true\");\n  setAttribute(element, \"role\", \"dialog\");\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n  toggleFocusTrap(element);\n};\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst hideOffcanvasComplete = (self: Offcanvas) => {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, \"true\");\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, \"role\");\n  setElementStyle(element, { visibility: \"\" });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget ||\n    triggers.find(isVisible);\n  // istanbul ignore else @preserve\n  if (visibleTrigger) focus(visibleTrigger as HTMLElement);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n  toggleFocusTrap(element);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n};\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nexport default class Offcanvas extends BaseComponent {\n  static selector = offcanvasSelector;\n  static init = offcanvasInitCallback;\n  static getInstance = getOffcanvasInstance;\n  declare options: OffcanvasOptions;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: HTMLElement | null;\n\n  /**\n   * @param target usually an `.offcanvas` element\n   * @param config instance options\n   */\n  constructor(\n    target: HTMLElement | string,\n    config?: Partial<OffcanvasOptions>,\n  ) {\n    super(target, config);\n\n    // instance element\n    const { element } = this;\n\n    // all the triggering buttons\n    this.triggers = [\n      ...querySelectorAll(offcanvasToggleSelector, getDocument(element)),\n    ].filter(\n      (btn) => getTargetElement(btn) === element,\n    );\n\n    // additional instance property\n    this.relatedTarget = null;\n\n    // attach event listeners\n    this._toggleEventListeners(true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return offcanvasComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return offcanvasDefaults;\n  }\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const { element, options, relatedTarget } = this;\n    let overlayDelay = 0;\n\n    if (!hasClass(element, showClass)) {\n      showOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      shownOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, showOffcanvasEvent);\n\n      if (!showOffcanvasEvent.defaultPrevented) {\n        // we elegantly hide any opened modal/offcanvas\n        const currentOpen = getCurrentOpen(element);\n        if (currentOpen && currentOpen !== element) {\n          const that = getOffcanvasInstance(currentOpen) ||\n            // istanbul ignore next @preserve\n            getInstance<typeof BaseComponent & { hide: () => void }>(\n              currentOpen,\n              modalComponent,\n            );\n\n          // istanbul ignore else @preserve\n          if (that) that.hide();\n        }\n\n        if (options.backdrop) {\n          if (!hasPopup(overlay)) {\n            appendOverlay(element, true);\n          } else {\n            toggleOverlayType();\n          }\n\n          overlayDelay = getElementTransitionDuration(overlay);\n          showOverlay();\n\n          setTimeout(() => beforeOffcanvasShow(this), overlayDelay);\n        } else {\n          beforeOffcanvasShow(this);\n          // istanbul ignore next @preserve - this test was done on Modal\n          if (currentOpen && hasClass(overlay, showClass)) {\n            hideOverlay();\n          }\n        }\n      }\n    }\n  }\n\n  /** Hides the offcanvas from the user. */\n  hide() {\n    const { element, relatedTarget } = this;\n\n    if (hasClass(element, showClass)) {\n      hideOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      hiddenOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, hideOffcanvasEvent);\n      if (!hideOffcanvasEvent.defaultPrevented) {\n        addClass(element, offcanvasTogglingClass);\n        removeClass(element, showClass);\n        beforeOffcanvasHide(this);\n      }\n    }\n  }\n\n  /**\n   * Toggles on/off the `click` event listeners.\n   *\n   * @param self the `Offcanvas` instance\n   * @param add when *true*, listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    this.triggers.forEach((btn) =>\n      action(btn, mouseclickEvent, offcanvasTriggerHandler)\n    );\n  };\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const { element } = this;\n    const isOpen = hasClass(element, showClass);\n    const callback = () => setTimeout(() => super.dispose(), 1);\n\n    this.hide();\n    this._toggleEventListeners();\n\n    if (isOpen) {\n      emulateTransitionEnd(element, callback);\n      // istanbul ignore next @preserve\n    } else {\n      callback();\n    }\n  }\n}\n"],"names":["offcanvasSelector","offcanvasString","offcanvasToggleSelector","dataBsToggle","offcanvasDismissSelector","dataBsDismiss","offcanvasTogglingClass","offcanvasDefaults","getOffcanvasInstance","element","getInstance","offcanvasComponent","offcanvasInitCallback","Offcanvas","showOffcanvasEvent","createCustomEvent","shownOffcanvasEvent","hideOffcanvasEvent","hiddenOffcanvasEvent","setOffCanvasScrollbar","self","clientHeight","scrollHeight","getDocumentElement","setScrollbar","toggleOffCanvasDismiss","add","action","addListener","removeListener","doc","getDocument","keydownEvent","offcanvasKeyDismissHandler","mouseclickEvent","offcanvasDismissHandler","beforeOffcanvasShow","options","setElementStyle","getDocumentBody","addClass","showClass","emulateTransitionEnd","showOffcanvasComplete","beforeOffcanvasHide","currentOpen","getCurrentOpen","hasClass","overlay","hideOverlay","hideOffcanvasComplete","offcanvasTriggerHandler","e","trigger","closest","getTargetElement","target","querySelector","offcanvasActiveSelector","offCanvasDismiss","triggers","backdrop","selection","code","keyEscape","removeClass","removeAttribute","ariaHidden","setAttribute","ariaModal","dispatchEvent","focus","toggleFocusTrap","visibleTrigger","isVisible","removeOverlay","BaseComponent","config","__publicField","btn","querySelectorAll","relatedTarget","overlayDelay","that","modalComponent","hasPopup","toggleOverlayType","appendOverlay","getElementTransitionDuration","showOverlay","isOpen","callback"],"mappings":"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"}