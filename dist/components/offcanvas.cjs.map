{"version":3,"file":"offcanvas.cjs","sources":["../../src/components/offcanvas.ts"],"sourcesContent":["/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\nimport {\n  addClass,\n  ariaHidden,\n  ariaModal,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  emulateTransitionEnd,\n  focus,\n  getDocument,\n  getDocumentBody,\n  getDocumentElement,\n  getElementTransitionDuration,\n  getInstance,\n  hasClass,\n  keydownEvent,\n  keyEscape,\n  mouseclickEvent,\n  MouseEvent,\n  querySelector,\n  querySelectorAll,\n  removeAttribute,\n  removeClass,\n  setAttribute,\n  setElementStyle,\n  toggleFocusTrap,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport dataBsDismiss from \"../strings/dataBsDismiss\";\nimport dataBsToggle from \"../strings/dataBsToggle\";\nimport showClass from \"../strings/showClass\";\nimport offcanvasString from \"../strings/offcanvasString\";\nimport offcanvasComponent from \"../strings/offcanvasComponent\";\nimport modalComponent from \"../strings/modalComponent\";\n\nimport getTargetElement from \"../util/getTargetElement\";\nimport isVisible from \"../util/isVisible\";\nimport { setScrollbar } from \"../util/scrollbar\";\nimport { hasPopup } from \"../util/popupContainer\";\nimport {\n  appendOverlay,\n  getCurrentOpen,\n  hideOverlay,\n  offcanvasActiveSelector,\n  overlay,\n  removeOverlay,\n  showOverlay,\n  toggleOverlayType,\n} from \"../util/backdrop\";\nimport BaseComponent from \"./base-component\";\nimport { OffcanvasEvent, OffcanvasOptions } from \"../interface/offcanvas\";\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\ntype OffCanvasEventProps = {\n  relatedTarget: Element & EventTarget | undefined;\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n */\nconst getOffcanvasInstance = (element: Element) =>\n  getInstance<Offcanvas>(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n */\nconst offcanvasInitCallback = (element: Element) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param self the `Offcanvas` instance\n */\nconst setOffCanvasScrollbar = (self: Offcanvas) => {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param self the `Offcanvas` instance\n * @param add when *true* listeners are added\n */\nconst toggleOffCanvasDismiss = (self: Offcanvas, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n};\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasShow = (self: Offcanvas) => {\n  const { element, options } = self;\n\n  // istanbul ignore else @preserve\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: \"hidden\" });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: \"visible\" });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n};\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasHide = (self: Offcanvas) => {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  (element as HTMLElement).blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n  }\n  emulateTransitionEnd(element, () => hideOffcanvasComplete(self));\n};\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @param e the `Event` object\n */\nconst offcanvasTriggerHandler = (e: MouseEvent<HTMLElement>) => {\n  const trigger = closest(e.target, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore if @preserve\n  if (!self) return;\n\n  self.relatedTarget = trigger;\n  self.toggle();\n\n  // istanbul ignore else @preserve\n  if (trigger?.tagName === \"A\") e.preventDefault();\n};\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param e the `Event` object\n */\nconst offcanvasDismissHandler = (e: MouseEvent<HTMLElement>) => {\n  const { target } = e;\n  const element = querySelector(\n    offcanvasActiveSelector,\n    getDocument(target),\n  );\n  // istanbul ignore else @preserve\n  if (!element) return;\n\n  const offCanvasDismiss = querySelector<HTMLElement>(\n    offcanvasDismissSelector,\n    element,\n  );\n  const self = getOffcanvasInstance(element);\n\n  // istanbul ignore if @preserve\n  if (!self) return;\n\n  const { options, triggers } = self;\n  const { backdrop } = options;\n  const trigger = closest(target, offcanvasToggleSelector);\n  const selection = getDocument(element).getSelection();\n\n  // istanbul ignore if: a filter is required here @preserve\n  if (overlay.contains(target) && backdrop === \"static\") return;\n\n  // istanbul ignore else @preserve\n  if (\n    !(selection && selection.toString().length) &&\n    ((!element.contains(target) &&\n      backdrop &&\n      // istanbul ignore next @preserve\n      (!trigger || triggers.includes(target))) ||\n      (offCanvasDismiss &&\n        offCanvasDismiss.contains(target)))\n  ) {\n    self.relatedTarget = offCanvasDismiss && offCanvasDismiss.contains(target)\n      ? offCanvasDismiss\n      : undefined;\n    self.hide();\n  }\n\n  // istanbul ignore next @preserve\n  if (trigger && trigger.tagName === \"A\") e.preventDefault();\n};\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst offcanvasKeyDismissHandler = ({ code, target }: KeyboardEvent) => {\n  const element = querySelector(\n    offcanvasActiveSelector,\n    getDocument(target as Node),\n  );\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore if @preserve\n  if (!self) return;\n\n  // istanbul ignore else @preserve\n  if (self.options.keyboard && code === keyEscape) {\n    self.relatedTarget = undefined;\n    self.hide();\n  }\n};\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst showOffcanvasComplete = (self: Offcanvas) => {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, \"true\");\n  setAttribute(element, \"role\", \"dialog\");\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n  toggleFocusTrap(element);\n};\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst hideOffcanvasComplete = (self: Offcanvas) => {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, \"true\");\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, \"role\");\n  setElementStyle(element, { visibility: \"\" });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget ||\n    triggers.find(isVisible);\n  // istanbul ignore else @preserve\n  if (visibleTrigger) focus(visibleTrigger);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n  toggleFocusTrap(element);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n};\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nexport default class Offcanvas extends BaseComponent {\n  static selector = offcanvasSelector;\n  static init = offcanvasInitCallback;\n  static getInstance = getOffcanvasInstance;\n  declare element: HTMLElement;\n  declare options: OffcanvasOptions;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: EventTarget & HTMLElement | undefined;\n\n  /**\n   * @param target usually an `.offcanvas` element\n   * @param config instance options\n   */\n  constructor(\n    target: Element | string,\n    config?: Partial<OffcanvasOptions>,\n  ) {\n    super(target, config);\n\n    // instance element\n    const { element } = this;\n\n    // all the triggering buttons\n    this.triggers = [\n      ...querySelectorAll<HTMLElement>(\n        offcanvasToggleSelector,\n        getDocument(element),\n      ),\n    ].filter(\n      (btn) => getTargetElement(btn) === element,\n    );\n\n    // additional instance property\n    this.relatedTarget = undefined;\n\n    // attach event listeners\n    this._toggleEventListeners(true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return offcanvasComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return offcanvasDefaults;\n  }\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const { element, options, relatedTarget } = this;\n    let overlayDelay = 0;\n\n    // istanbul ignore else @preserve\n    if (hasClass(element, showClass)) return;\n\n    showOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    shownOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    dispatchEvent(element, showOffcanvasEvent);\n\n    // istanbul ignore else @preserve\n    if (showOffcanvasEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const that = getOffcanvasInstance(currentOpen) ||\n        // istanbul ignore next @preserve\n        getInstance<typeof BaseComponent & { hide: () => void }>(\n          currentOpen,\n          modalComponent,\n        );\n\n      // istanbul ignore else @preserve\n      if (that) that.hide();\n    }\n\n    if (options.backdrop) {\n      if (!hasPopup(overlay)) appendOverlay(element, true);\n      else toggleOverlayType();\n\n      overlayDelay = getElementTransitionDuration(overlay);\n      showOverlay();\n\n      setTimeout(() => beforeOffcanvasShow(this), overlayDelay);\n    } else {\n      beforeOffcanvasShow(this);\n      // istanbul ignore next @preserve - this test was done on Modal\n      if (currentOpen && hasClass(overlay, showClass)) hideOverlay();\n    }\n  }\n\n  /** Hides the offcanvas from the user. */\n  hide() {\n    const { element, relatedTarget } = this;\n\n    // istanbul ignore else @preserve\n    if (!hasClass(element, showClass)) return;\n\n    hideOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    hiddenOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    dispatchEvent(element, hideOffcanvasEvent);\n\n    // istanbul ignore else @preserve\n    if (hideOffcanvasEvent.defaultPrevented) return;\n\n    addClass(element, offcanvasTogglingClass);\n    removeClass(element, showClass);\n    beforeOffcanvasHide(this);\n  }\n\n  /**\n   * Toggles on/off the `click` event listeners.\n   *\n   * @param self the `Offcanvas` instance\n   * @param add when *true*, listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    this.triggers.forEach((btn) =>\n      action(btn, mouseclickEvent, offcanvasTriggerHandler)\n    );\n  };\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const { element } = this;\n    const isOpen = hasClass(element, showClass);\n    const callback = () => setTimeout(() => super.dispose(), 1);\n\n    this.hide();\n    this._toggleEventListeners();\n\n    if (isOpen) emulateTransitionEnd(element, callback);\n    // istanbul ignore next @preserve\n    else callback();\n  }\n}\n"],"names":["offcanvasSelector","offcanvasString","offcanvasToggleSelector","dataBsToggle","offcanvasDismissSelector","dataBsDismiss","offcanvasTogglingClass","offcanvasDefaults","getOffcanvasInstance","element","getInstance","offcanvasComponent","offcanvasInitCallback","Offcanvas","showOffcanvasEvent","createCustomEvent","shownOffcanvasEvent","hideOffcanvasEvent","hiddenOffcanvasEvent","setOffCanvasScrollbar","self","clientHeight","scrollHeight","getDocumentElement","setScrollbar","toggleOffCanvasDismiss","add","action","addListener","removeListener","doc","getDocument","keydownEvent","offcanvasKeyDismissHandler","mouseclickEvent","offcanvasDismissHandler","beforeOffcanvasShow","options","setElementStyle","getDocumentBody","addClass","showClass","emulateTransitionEnd","showOffcanvasComplete","beforeOffcanvasHide","currentOpen","getCurrentOpen","hasClass","overlay","hideOverlay","hideOffcanvasComplete","offcanvasTriggerHandler","e","trigger","closest","getTargetElement","target","querySelector","offcanvasActiveSelector","offCanvasDismiss","triggers","backdrop","selection","code","keyEscape","removeClass","removeAttribute","ariaHidden","setAttribute","ariaModal","dispatchEvent","focus","toggleFocusTrap","visibleTrigger","isVisible","removeOverlay","BaseComponent","config","querySelectorAll","btn","relatedTarget","overlayDelay","that","modalComponent","hasPopup","toggleOverlayType","appendOverlay","getElementTransitionDuration","showOverlay","isOpen","callback"],"mappings":"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"}