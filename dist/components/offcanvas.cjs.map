{"version":3,"file":"offcanvas.cjs","sources":["../../src/components/offcanvas.ts"],"sourcesContent":["/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\nimport {\n  ariaHidden,\n  addClass,\n  hasClass,\n  closest,\n  querySelectorAll,\n  querySelector,\n  removeAttribute,\n  isFunction,\n  setAttribute,\n  keyEscape,\n  keydownEvent,\n  mouseclickEvent,\n  ariaModal,\n  emulateTransitionEnd,\n  dispatchEvent,\n  getElementTransitionDuration,\n  getDocumentBody,\n  getDocumentElement,\n  getDocument,\n  removeClass,\n  setElementStyle,\n  createCustomEvent,\n  focus,\n  getInstance,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport dataBsDismiss from '../strings/dataBsDismiss';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport showClass from '../strings/showClass';\nimport offcanvasString from '../strings/offcanvasString';\nimport offcanvasComponent from '../strings/offcanvasComponent';\nimport modalComponent from '../strings/modalComponent';\n\nimport getTargetElement from '../util/getTargetElement';\nimport isVisible from '../util/isVisible';\nimport { setScrollbar } from '../util/scrollbar';\nimport { hasPopup } from '../util/popupContainer';\nimport {\n  overlay,\n  offcanvasActiveSelector,\n  toggleOverlayType,\n  appendOverlay,\n  showOverlay,\n  hideOverlay,\n  getCurrentOpen,\n  removeOverlay,\n} from '../util/backdrop';\nimport BaseComponent from './base-component';\nimport { OffcanvasOptions, OffcanvasEvent } from '../interface/offcanvas';\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n */\nconst getOffcanvasInstance = (element: HTMLElement) => getInstance<Offcanvas>(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n */\nconst offcanvasInitCallback = (element: HTMLElement) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = createCustomEvent<OffcanvasEvent>(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param self the `Offcanvas` instance\n */\nconst setOffCanvasScrollbar = (self: Offcanvas) => {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the `click` event listeners.\n *\n * @param self the `Offcanvas` instance\n * @param add when *true*, listeners are added\n */\nconst toggleOffcanvasEvents = (self: Offcanvas, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  self.triggers.forEach(btn => action(btn, mouseclickEvent, offcanvasTriggerHandler as EventListener));\n};\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param self the `Offcanvas` instance\n * @param add when *true* listeners are added\n */\nconst toggleOffCanvasDismiss = (self: Offcanvas, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler as EventListener);\n  action(doc, mouseclickEvent, offcanvasDismissHandler as EventListener);\n};\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasShow = (self: Offcanvas) => {\n  const { element, options } = self;\n\n  /* istanbul ignore else */\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: 'visible' });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n};\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n * @param callback the hide callback\n */\nconst beforeOffcanvasHide = (self: Offcanvas, callback?: () => void) => {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  element.blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => hideOffcanvasComplete(self, callback));\n  } else hideOffcanvasComplete(self, callback);\n};\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @param e the `Event` object\n */\nconst offcanvasTriggerHandler = (e: MouseEvent) => {\n  const trigger = closest(e.target as HTMLElement, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    self.relatedTarget = trigger;\n    self.toggle();\n    /* istanbul ignore else */\n    if (trigger && trigger.tagName === 'A') {\n      e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param e the `Event` object\n */\nconst offcanvasDismissHandler = (e: MouseEvent) => {\n  const { target } = e;\n  const element = querySelector(offcanvasActiveSelector, getDocument(target as Node));\n  const offCanvasDismiss = querySelector(offcanvasDismissSelector, element as HTMLElement | undefined);\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore next: must have a filter */\n  if (!self) return;\n\n  const { options, triggers } = self;\n  const { backdrop } = options;\n  const trigger = closest(target as HTMLElement, offcanvasToggleSelector);\n  const selection = getDocument(element).getSelection();\n\n  if (overlay.contains(target as HTMLElement) && backdrop === 'static') return;\n\n  /* istanbul ignore else */\n  if (\n    !(selection && selection.toString().length) &&\n    ((!element.contains(target as HTMLElement) &&\n      backdrop &&\n      /* istanbul ignore next */ (!trigger || triggers.includes(target as HTMLElement))) ||\n      (offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement)))\n  ) {\n    self.relatedTarget = offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement) ? offCanvasDismiss : null;\n    self.hide();\n  }\n\n  /* istanbul ignore next */\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n};\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst offcanvasKeyDismissHandler = ({ code, target }: KeyboardEvent) => {\n  const element = querySelector(offcanvasActiveSelector, getDocument(target as Node));\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore next: must filter */\n  if (!self) return;\n\n  /* istanbul ignore else */\n  if (self.options.keyboard && code === keyEscape) {\n    self.relatedTarget = null;\n    self.hide();\n  }\n};\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst showOffcanvasComplete = (self: Offcanvas) => {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n  setAttribute(element, 'role', 'dialog');\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n};\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n * @param callback the hide callback\n */\nconst hideOffcanvasComplete = (self: Offcanvas, callback?: () => void) => {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, 'true');\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, 'role');\n  setElementStyle(element, { visibility: '' });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget || triggers.find(isVisible);\n  /* istanbul ignore else */\n  if (visibleTrigger) focus(visibleTrigger as HTMLElement);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n  // callback\n  if (isFunction(callback)) callback();\n};\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nexport default class Offcanvas extends BaseComponent {\n  static selector = offcanvasSelector;\n  static init = offcanvasInitCallback;\n  static getInstance = getOffcanvasInstance;\n  declare options: OffcanvasOptions;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: HTMLElement | null;\n\n  /**\n   * @param target usually an `.offcanvas` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<OffcanvasOptions>) {\n    super(target, config);\n\n    // instance element\n    const { element } = this;\n\n    // all the triggering buttons\n    this.triggers = [...querySelectorAll(offcanvasToggleSelector, getDocument(element))].filter(\n      btn => getTargetElement(btn) === element,\n    );\n\n    // additional instance property\n    this.relatedTarget = null;\n\n    // attach event listeners\n    toggleOffcanvasEvents(this, true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return offcanvasComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return offcanvasDefaults;\n  }\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const { element, options, relatedTarget } = this;\n    let overlayDelay = 0;\n\n    if (hasClass(element, showClass)) return;\n\n    showOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    shownOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    dispatchEvent(element, showOffcanvasEvent);\n    if (showOffcanvasEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const that =\n        getOffcanvasInstance(currentOpen) ||\n        /* istanbul ignore next */\n        getInstance<typeof BaseComponent & { hide: () => void }>(currentOpen, modalComponent);\n      if (that) that.hide();\n    }\n\n    if (options.backdrop) {\n      if (!hasPopup(overlay)) {\n        appendOverlay(element, true);\n      } else {\n        toggleOverlayType();\n      }\n\n      overlayDelay = getElementTransitionDuration(overlay);\n      showOverlay();\n\n      setTimeout(() => beforeOffcanvasShow(this), overlayDelay);\n    } else {\n      beforeOffcanvasShow(this);\n      /* istanbul ignore else */\n      if (currentOpen && hasClass(overlay, showClass)) {\n        hideOverlay();\n      }\n    }\n  }\n\n  /**\n   * Hides the offcanvas from the user.\n   *\n   * @param callback when `true` it will skip animation\n   */\n  hide(callback?: () => void) {\n    const { element, relatedTarget } = this;\n\n    if (!hasClass(element, showClass)) return;\n\n    hideOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    hiddenOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n    dispatchEvent(element, hideOffcanvasEvent);\n    if (hideOffcanvasEvent.defaultPrevented) return;\n\n    addClass(element, offcanvasTogglingClass);\n    removeClass(element, showClass);\n\n    if (!callback) {\n      emulateTransitionEnd(element, () => beforeOffcanvasHide(this, callback));\n    } else beforeOffcanvasHide(this, callback);\n  }\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    toggleOffcanvasEvents(this);\n    this.hide(() => super.dispose());\n  }\n}\n"],"names":["offcanvasSelector","offcanvasString","offcanvasToggleSelector","dataBsToggle","offcanvasDismissSelector","dataBsDismiss","offcanvasTogglingClass","offcanvasDefaults","getOffcanvasInstance","element","getInstance","offcanvasComponent","offcanvasInitCallback","Offcanvas","showOffcanvasEvent","createCustomEvent","shownOffcanvasEvent","hideOffcanvasEvent","hiddenOffcanvasEvent","setOffCanvasScrollbar","self","clientHeight","scrollHeight","getDocumentElement","setScrollbar","toggleOffcanvasEvents","add","action","addListener","removeListener","btn","mouseclickEvent","offcanvasTriggerHandler","toggleOffCanvasDismiss","doc","getDocument","keydownEvent","offcanvasKeyDismissHandler","offcanvasDismissHandler","beforeOffcanvasShow","options","setElementStyle","getDocumentBody","addClass","showClass","emulateTransitionEnd","showOffcanvasComplete","beforeOffcanvasHide","callback","currentOpen","getCurrentOpen","hasClass","overlay","hideOverlay","hideOffcanvasComplete","e","trigger","closest","getTargetElement","target","querySelector","offcanvasActiveSelector","offCanvasDismiss","triggers","backdrop","selection","code","keyEscape","removeClass","removeAttribute","ariaHidden","setAttribute","ariaModal","dispatchEvent","focus","visibleTrigger","isVisible","removeOverlay","isFunction","BaseComponent","config","querySelectorAll","relatedTarget","overlayDelay","that","modalComponent","hasPopup","toggleOverlayType","appendOverlay","getElementTransitionDuration","showOverlay"],"mappings":"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"}