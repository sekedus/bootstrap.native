{"version":3,"file":"scrollspy.mjs","sources":["../../src/strings/scrollspyString.ts","../../src/strings/scrollspyComponent.ts","../../src/components/scrollspy.ts"],"sourcesContent":["/** @type {string} */\nconst scrollspyString = \"scrollspy\";\nexport default scrollspyString;\n","/** @type {string} */\nconst scrollspyComponent = \"ScrollSpy\";\nexport default scrollspyComponent;\n","/* Native JavaScript for Bootstrap 5 | ScrollSpy\n------------------------------------------------ */\nimport {\n  addClass,\n  createCustomEvent,\n  dispatchEvent,\n  getAttribute,\n  getBoundingClientRect,\n  getDocument,\n  getDocumentBody,\n  getDocumentElement,\n  getElementsByTagName,\n  getInstance,\n  hasClass,\n  isHTMLElement,\n  querySelector,\n  removeClass,\n} from \"@thednp/shorty\";\n\nimport PositionObserver from \"@thednp/position-observer\";\n\nimport activeClass from \"../strings/activeClass\";\nimport scrollspyString from \"../strings/scrollspyString\";\nimport scrollspyComponent from \"../strings/scrollspyComponent\";\n\nimport BaseComponent from \"./base-component\";\nimport { ScrollSpyEvent, ScrollSpyOptions } from \"../interface/scrollspy\";\n\n// SCROLLSPY PRIVATE GC\n// ====================\nconst scrollspySelector = '[data-bs-spy=\"scroll\"]';\n\nconst scrollspyDefaults: Partial<ScrollSpyOptions> = {\n  offset: 10,\n  target: undefined,\n};\n\ntype ScrollSpyEventProps = {\n  relatedTarget: HTMLElement;\n};\n\n/**\n * Static method which returns an existing `ScrollSpy` instance associated\n * to a target `Element`.\n */\nconst getScrollSpyInstance = (element: Element) =>\n  getInstance<ScrollSpy>(element, scrollspyComponent);\n\n/**\n * A `ScrollSpy` initialization callback.\n */\nconst scrollspyInitCallback = (element: Element) => new ScrollSpy(element);\n\n// SCROLLSPY CUSTOM EVENT\n// ======================\nconst activateScrollSpy = createCustomEvent<\n  ScrollSpyEventProps,\n  ScrollSpyEvent\n>(`activate.bs.${scrollspyString}`);\n\n// SCROLLSPY PRIVATE METHODS\n// =========================\n/**\n * Update the state of all items.\n *\n * @param self the `ScrollSpy` instance\n */\nconst updateSpyTargets = (self: ScrollSpy) => {\n  const {\n    target,\n    scrollTarget,\n    options,\n    itemsLength,\n    scrollHeight,\n    element,\n    _observer,\n  } = self;\n  const { offset } = options;\n  const isRoot = scrollTarget !== element;\n\n  const links = target && getElementsByTagName<HTMLAnchorElement>(\"A\", target);\n  const doc = getDocument(element);\n  const scrollHEIGHT = scrollTarget.scrollHeight;\n\n  self.scrollTop = scrollTarget.scrollTop;\n\n  // only update items/offsets once or with each mutation\n  // istanbul ignore else @preserve\n  if (\n    links && (scrollHEIGHT !== scrollHeight || itemsLength !== links.length)\n  ) {\n    let href: string | null;\n    let ref: string | undefined;\n    let targetItem: HTMLElement | null;\n    let rect;\n\n    // reset arrays & update\n    self.items = [];\n    self.targets = [];\n    self.offsets = [];\n    self.scrollHeight = scrollHEIGHT;\n    self.maxScroll = self.scrollHeight - getOffsetHeight(self);\n\n    Array.from(links).forEach((link) => {\n      href = getAttribute(link, \"href\");\n      ref = href?.slice(1);\n      targetItem = ref?.length ? doc.getElementById(ref) : null;\n\n      if (targetItem) {\n        self.items.push(link);\n        self.targets.push(targetItem);\n        rect = _observer?.getEntry(targetItem)?.boundingClientRect ||\n          getBoundingClientRect(targetItem);\n        self.offsets.push(\n          (isRoot ? rect.top + self.scrollTop : targetItem.offsetTop) - offset,\n        );\n      }\n    });\n    self.itemsLength = self.items.length;\n  }\n};\n\n/**\n * Toggles on/off the component observer.\n *\n * @param self the ScrollSpy instance\n * @param add when `true`, listener is added\n */\nconst toggleObservers = (\n  { targets, scrollTarget, element, _observer }: ScrollSpy,\n  add?: boolean,\n) => {\n  if (add) {\n    if (scrollTarget === element) {\n      targets?.forEach((targetItem) => _observer.observe(targetItem));\n    } else {\n      _observer.observe(element);\n    }\n  } else _observer.disconnect();\n};\n\n/**\n * Returns the `scrollHeight` property of the scrolling element.\n *\n * @param scrollTarget the `ScrollSpy` instance\n * @return `scrollTarget` height\n */\nconst getScrollHeight = (scrollTarget: Element) => {\n  return scrollTarget.scrollHeight;\n};\n\n/**\n * Returns the height property of the scrolling element.\n *\n * @param params the `ScrollSpy` instance\n */\nconst getOffsetHeight = ({ element, scrollTarget }: ScrollSpy) => {\n  return scrollTarget !== element\n    ? scrollTarget.clientHeight\n    : getBoundingClientRect(element).height;\n};\n\n/**\n * Clear all items of the target.\n *\n * @param target a single item\n */\nconst clear = (target: Element) => {\n  Array.from(getElementsByTagName<HTMLAnchorElement>(\"A\", target)).forEach(\n    (item) => {\n      if (hasClass(item, activeClass)) removeClass(item, activeClass);\n    },\n  );\n};\n\n/**\n * Activates a new item.\n *\n * @param self the `ScrollSpy` instance\n * @param item a single item\n */\nconst activate = (self: ScrollSpy, item: HTMLElement) => {\n  const { target, element } = self;\n\n  // istanbul ignore else @preserve\n  if (isHTMLElement(target)) clear(target);\n\n  self.activeItem = item;\n  addClass(item, activeClass);\n\n  // activate all parents\n  const parents: HTMLElement[] = [];\n  let parentItem = item;\n  while (parentItem !== getDocumentBody(element)) {\n    parentItem = parentItem.parentElement as HTMLElement;\n    if (hasClass(parentItem, \"nav\") || hasClass(parentItem, \"dropdown-menu\")) {\n      parents.push(parentItem);\n    }\n  }\n\n  parents.forEach((menuItem) => {\n    const parentLink = menuItem.previousElementSibling as HTMLElement | null;\n\n    // istanbul ignore else @preserve\n    if (parentLink && !hasClass(parentLink, activeClass)) {\n      addClass(parentLink, activeClass);\n    }\n  });\n\n  // dispatch\n  activateScrollSpy.relatedTarget = item;\n  dispatchEvent(element, activateScrollSpy);\n};\n\n// SCROLLSPY DEFINITION\n// ====================\n/** Returns a new `ScrollSpy` instance. */\nexport default class ScrollSpy extends BaseComponent {\n  static selector = scrollspySelector;\n  static init = scrollspyInitCallback;\n  static getInstance = getScrollSpyInstance;\n  declare element: HTMLElement;\n  declare options: ScrollSpyOptions;\n  declare target: HTMLElement | null;\n  declare scrollTarget: HTMLElement;\n  declare scrollTop: number;\n  declare maxScroll: number;\n  declare scrollHeight: number;\n  declare activeItem: HTMLElement | null;\n  declare items: HTMLElement[];\n  declare targets: HTMLElement[];\n  declare itemsLength: number;\n  declare offsets: number[];\n  declare _observer: PositionObserver;\n\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(\n    target: Element | string,\n    config?: Partial<ScrollSpyOptions>,\n  ) {\n    super(target, config);\n\n    // initialization element & options\n    const { element, options } = this;\n\n    // get target\n    const spyTarget = querySelector(\n      options.target,\n      getDocument(element),\n    );\n\n    // invalidate\n    if (!spyTarget) return;\n    this.target = spyTarget;\n\n    // set initial state\n    this.scrollTarget = element.clientHeight < element.scrollHeight\n      ? element\n      : getDocumentElement(element);\n    this.scrollHeight = getScrollHeight(this.scrollTarget);\n\n    // run an initial burst, we need to know the targets\n    this.refresh();\n\n    // create observer\n    this._observer = new PositionObserver((entries) => {\n      requestAnimationFrame(() => {\n        // istanbul ignore else @preserve\n        if (entries.some((entry) => entry.isVisible)) {\n          this.refresh();\n        }\n      });\n    }, {\n      root: this.scrollTarget,\n    });\n\n    // add event handlers\n    toggleObservers(this, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return scrollspyComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return scrollspyDefaults;\n  }\n  /* eslint-enable */\n\n  // SCROLLSPY PUBLIC METHODS\n  // ========================\n  /** Updates all items. */\n  refresh = () => {\n    const { target } = this;\n    // check if target is visible and invalidate\n    // istanbul ignore if @preserve\n    if (!isHTMLElement(target) || target.offsetHeight === 0) return;\n\n    updateSpyTargets(this);\n\n    const { scrollTop, maxScroll, itemsLength, items, activeItem } = this;\n\n    if (scrollTop >= maxScroll) {\n      const newActiveItem = items[itemsLength - 1];\n\n      // istanbul ignore else @preserve\n      if (activeItem !== newActiveItem) activate(this, newActiveItem);\n      return;\n    }\n\n    const { offsets } = this;\n\n    // istanbul ignore else @preserve\n    if (activeItem && scrollTop < offsets[0] && offsets[0] > 0) {\n      this.activeItem = null;\n      // istanbul ignore else @preserve\n      if (target) clear(target);\n      return;\n    }\n\n    items.forEach((item, i) => {\n      if (\n        activeItem !== item &&\n        scrollTop >= offsets[i] &&\n        (typeof offsets[i + 1] === \"undefined\" || scrollTop < offsets[i + 1])\n      ) {\n        activate(this, item);\n      }\n    });\n  };\n\n  /** Removes `ScrollSpy` from the target element. */\n  dispose() {\n    const clone = { ...this };\n    toggleObservers(clone);\n    super.dispose();\n  }\n}\n"],"names":["scrollspyString","scrollspyComponent","scrollspySelector","scrollspyDefaults","getScrollSpyInstance","element","getInstance","scrollspyInitCallback","ScrollSpy","activateScrollSpy","createCustomEvent","updateSpyTargets","self","target","scrollTarget","options","itemsLength","scrollHeight","_observer","offset","isRoot","links","getElementsByTagName","doc","getDocument","scrollHEIGHT","href","ref","targetItem","rect","getOffsetHeight","link","getAttribute","getBoundingClientRect","toggleObservers","targets","add","getScrollHeight","clear","item","hasClass","activeClass","removeClass","activate","isHTMLElement","addClass","parents","parentItem","getDocumentBody","menuItem","parentLink","dispatchEvent","BaseComponent","config","spyTarget","querySelector","getDocumentElement","PositionObserver","entries","entry","scrollTop","maxScroll","items","activeItem","newActiveItem","offsets","i","clone"],"mappings":"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"}