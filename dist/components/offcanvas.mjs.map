{"version":3,"file":"offcanvas.mjs","sources":["../../src/components/offcanvas.ts"],"sourcesContent":["/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\nimport {\n  addClass,\n  ariaHidden,\n  ariaModal,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  emulateTransitionEnd,\n  focus,\n  getDocument,\n  getDocumentBody,\n  getDocumentElement,\n  getElementTransitionDuration,\n  getInstance,\n  hasClass,\n  keydownEvent,\n  keyEscape,\n  mouseclickEvent,\n  querySelector,\n  querySelectorAll,\n  removeAttribute,\n  removeClass,\n  setAttribute,\n  setElementStyle,\n  toggleFocusTrap,\n} from '@thednp/shorty';\n\nimport { addListener, removeListener } from '@thednp/event-listener';\n\nimport dataBsDismiss from '../strings/dataBsDismiss';\nimport dataBsToggle from '../strings/dataBsToggle';\nimport showClass from '../strings/showClass';\nimport offcanvasString from '../strings/offcanvasString';\nimport offcanvasComponent from '../strings/offcanvasComponent';\nimport modalComponent from '../strings/modalComponent';\n\nimport getTargetElement from '../util/getTargetElement';\nimport isVisible from '../util/isVisible';\nimport { setScrollbar } from '../util/scrollbar';\nimport { hasPopup } from '../util/popupContainer';\nimport {\n  appendOverlay,\n  getCurrentOpen,\n  hideOverlay,\n  offcanvasActiveSelector,\n  overlay,\n  removeOverlay,\n  showOverlay,\n  toggleOverlayType,\n} from '../util/backdrop';\nimport BaseComponent from './base-component';\nimport { OffcanvasEvent, OffcanvasOptions } from '../interface/offcanvas';\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\ntype OffCanvasEventProps = {\n  relatedTarget: HTMLElement | undefined;\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n */\nconst getOffcanvasInstance = (element: HTMLElement) => getInstance<Offcanvas>(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n */\nconst offcanvasInitCallback = (element: HTMLElement) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = createCustomEvent<OffCanvasEventProps, OffcanvasEvent>(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = createCustomEvent<OffCanvasEventProps, OffcanvasEvent>(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = createCustomEvent<OffCanvasEventProps, OffcanvasEvent>(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = createCustomEvent<OffCanvasEventProps, OffcanvasEvent>(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param self the `Offcanvas` instance\n */\nconst setOffCanvasScrollbar = (self: Offcanvas) => {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param self the `Offcanvas` instance\n * @param add when *true* listeners are added\n */\nconst toggleOffCanvasDismiss = (self: Offcanvas, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n};\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasShow = (self: Offcanvas) => {\n  const { element, options } = self;\n\n  // istanbul ignore else @preserve\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: 'visible' });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n};\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasHide = (self: Offcanvas) => {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  element.blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n  }\n  emulateTransitionEnd(element, () => hideOffcanvasComplete(self));\n};\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @param e the `Event` object\n */\nconst offcanvasTriggerHandler = (e: MouseEvent) => {\n  const trigger = closest(e.target as HTMLElement, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    self.relatedTarget = trigger;\n    self.toggle();\n    // istanbul ignore else @preserve\n    if (trigger && trigger.tagName === 'A') {\n      e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param e the `Event` object\n */\nconst offcanvasDismissHandler = (e: MouseEvent) => {\n  const { target } = e;\n  const element = querySelector(offcanvasActiveSelector, getDocument(target as Node));\n  const offCanvasDismiss = querySelector(offcanvasDismissSelector, element as HTMLElement | undefined);\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    const { options, triggers } = self;\n    const { backdrop } = options;\n    const trigger = closest(target as HTMLElement, offcanvasToggleSelector);\n    const selection = getDocument(element).getSelection();\n\n    // istanbul ignore else: a filter is required here @preserve\n    if (!overlay.contains(target as HTMLElement) || backdrop !== 'static') {\n      // istanbul ignore else @preserve\n      if (\n        !(selection && selection.toString().length) &&\n        ((!element.contains(target as HTMLElement) &&\n          backdrop &&\n          // istanbul ignore next @preserve\n          (!trigger || triggers.includes(target as HTMLElement))) ||\n          (offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement)))\n      ) {\n        self.relatedTarget =\n          offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement) ? offCanvasDismiss : null;\n        self.hide();\n      }\n\n      // istanbul ignore next @preserve\n      if (trigger && trigger.tagName === 'A') e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst offcanvasKeyDismissHandler = ({ code, target }: KeyboardEvent) => {\n  const element = querySelector(offcanvasActiveSelector, getDocument(target as Node));\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    // istanbul ignore else @preserve\n    if (self.options.keyboard && code === keyEscape) {\n      self.relatedTarget = null;\n      self.hide();\n    }\n  }\n};\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst showOffcanvasComplete = (self: Offcanvas) => {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n  setAttribute(element, 'role', 'dialog');\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n  toggleFocusTrap(element);\n};\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst hideOffcanvasComplete = (self: Offcanvas) => {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, 'true');\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, 'role');\n  setElementStyle(element, { visibility: '' });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget || triggers.find(isVisible);\n  // istanbul ignore else @preserve\n  if (visibleTrigger) focus(visibleTrigger as HTMLElement);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n  toggleFocusTrap(element);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n};\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nexport default class Offcanvas extends BaseComponent {\n  static selector = offcanvasSelector;\n  static init = offcanvasInitCallback;\n  static getInstance = getOffcanvasInstance;\n  declare options: OffcanvasOptions;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: HTMLElement | null;\n\n  /**\n   * @param target usually an `.offcanvas` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<OffcanvasOptions>) {\n    super(target, config);\n\n    // instance element\n    const { element } = this;\n\n    // all the triggering buttons\n    this.triggers = [...querySelectorAll(offcanvasToggleSelector, getDocument(element))].filter(\n      btn => getTargetElement(btn) === element,\n    );\n\n    // additional instance property\n    this.relatedTarget = null;\n\n    // attach event listeners\n    this._toggleEventListeners(true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return offcanvasComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return offcanvasDefaults;\n  }\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const { element, options, relatedTarget } = this;\n    let overlayDelay = 0;\n\n    if (!hasClass(element, showClass)) {\n      showOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      shownOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, showOffcanvasEvent);\n\n      if (!showOffcanvasEvent.defaultPrevented) {\n        // we elegantly hide any opened modal/offcanvas\n        const currentOpen = getCurrentOpen(element);\n        if (currentOpen && currentOpen !== element) {\n          const that =\n            getOffcanvasInstance(currentOpen) ||\n            // istanbul ignore next @preserve\n            getInstance<typeof BaseComponent & { hide: () => void }>(currentOpen, modalComponent);\n\n          // istanbul ignore else @preserve\n          if (that) that.hide();\n        }\n\n        if (options.backdrop) {\n          if (!hasPopup(overlay)) {\n            appendOverlay(element, true);\n          } else {\n            toggleOverlayType();\n          }\n\n          overlayDelay = getElementTransitionDuration(overlay);\n          showOverlay();\n\n          setTimeout(() => beforeOffcanvasShow(this), overlayDelay);\n        } else {\n          beforeOffcanvasShow(this);\n          // istanbul ignore next @preserve - this test was done on Modal\n          if (currentOpen && hasClass(overlay, showClass)) {\n            hideOverlay();\n          }\n        }\n      }\n    }\n  }\n\n  /** Hides the offcanvas from the user. */\n  hide() {\n    const { element, relatedTarget } = this;\n\n    if (hasClass(element, showClass)) {\n      hideOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      hiddenOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, hideOffcanvasEvent);\n      if (!hideOffcanvasEvent.defaultPrevented) {\n        addClass(element, offcanvasTogglingClass);\n        removeClass(element, showClass);\n        beforeOffcanvasHide(this);\n      }\n    }\n  }\n\n  /**\n   * Toggles on/off the `click` event listeners.\n   *\n   * @param self the `Offcanvas` instance\n   * @param add when *true*, listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    this.triggers.forEach(btn => action(btn, mouseclickEvent, offcanvasTriggerHandler));\n  };\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const { element } = this;\n    const isOpen = hasClass(element, showClass);\n    const callback = () => setTimeout(() => super.dispose(), 1);\n\n    this.hide();\n    this._toggleEventListeners();\n\n    if (isOpen) {\n      emulateTransitionEnd(element, callback);\n      // istanbul ignore next @preserve\n    } else {\n      callback();\n    }\n  }\n}\n"],"names":["offcanvasSelector","offcanvasString","offcanvasToggleSelector","dataBsToggle","offcanvasDismissSelector","dataBsDismiss","offcanvasTogglingClass","offcanvasDefaults","getOffcanvasInstance","element","getInstance","offcanvasComponent","offcanvasInitCallback","Offcanvas","showOffcanvasEvent","createCustomEvent","shownOffcanvasEvent","hideOffcanvasEvent","hiddenOffcanvasEvent","setOffCanvasScrollbar","self","clientHeight","scrollHeight","getDocumentElement","setScrollbar","toggleOffCanvasDismiss","add","action","addListener","removeListener","doc","getDocument","keydownEvent","offcanvasKeyDismissHandler","mouseclickEvent","offcanvasDismissHandler","beforeOffcanvasShow","options","setElementStyle","getDocumentBody","addClass","showClass","emulateTransitionEnd","showOffcanvasComplete","beforeOffcanvasHide","currentOpen","getCurrentOpen","hasClass","overlay","hideOverlay","hideOffcanvasComplete","offcanvasTriggerHandler","e","trigger","closest","getTargetElement","target","querySelector","offcanvasActiveSelector","offCanvasDismiss","triggers","backdrop","selection","code","keyEscape","removeClass","removeAttribute","ariaHidden","setAttribute","ariaModal","dispatchEvent","focus","toggleFocusTrap","visibleTrigger","isVisible","removeOverlay","BaseComponent","config","__publicField","btn","querySelectorAll","relatedTarget","overlayDelay","that","modalComponent","hasPopup","toggleOverlayType","appendOverlay","getElementTransitionDuration","showOverlay","isOpen","callback"],"mappings":"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"}