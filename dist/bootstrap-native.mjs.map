{"version":3,"file":"bootstrap-native.mjs","sources":["../node_modules/.pnpm/@thednp+shorty@2.0.7/node_modules/@thednp/shorty/dist/shorty.mjs","../node_modules/.pnpm/@thednp+event-listener@2.0.6/node_modules/@thednp/event-listener/dist/event-listener.mjs","../src/strings/fadeClass.ts","../src/strings/showClass.ts","../src/strings/dataBsDismiss.ts","../src/strings/alertString.ts","../src/strings/alertComponent.ts","../src/version.ts","../src/components/base-component.ts","../src/components/alert.ts","../src/strings/activeClass.ts","../src/strings/dataBsToggle.ts","../src/strings/buttonString.ts","../src/strings/buttonComponent.ts","../src/components/button.ts","../src/strings/dataBsTarget.ts","../src/strings/carouselString.ts","../src/strings/carouselComponent.ts","../src/strings/dataBsParent.ts","../src/strings/dataBsContainer.ts","../src/util/getTargetElement.ts","../src/components/carousel.ts","../src/strings/collapsingClass.ts","../src/strings/collapseString.ts","../src/strings/collapseComponent.ts","../src/components/collapse.ts","../src/strings/dropdownClasses.ts","../src/strings/dropdownComponent.ts","../src/strings/dropdownMenuClass.ts","../src/util/isEmptyAnchor.ts","../src/components/dropdown.ts","../src/strings/modalString.ts","../src/strings/modalComponent.ts","../src/strings/offcanvasComponent.ts","../src/strings/fixedTopClass.ts","../src/strings/fixedBottomClass.ts","../src/strings/stickyTopClass.ts","../src/strings/positionStickyClass.ts","../src/util/scrollbar.ts","../src/strings/offcanvasString.ts","../src/util/popupContainer.ts","../src/util/backdrop.ts","../src/util/isVisible.ts","../src/components/modal.ts","../src/components/offcanvas.ts","../src/strings/popoverString.ts","../src/strings/popoverComponent.ts","../src/strings/tooltipString.ts","../src/util/getTipTemplate.ts","../src/util/tipClassPositions.ts","../src/util/styleTip.ts","../src/util/tooltipDefaults.ts","../node_modules/.pnpm/@thednp+position-observer@0.0.3/node_modules/@thednp/position-observer/dist/index.mjs","../src/strings/dataOriginalTitle.ts","../src/strings/tooltipComponent.ts","../src/util/setHtml.ts","../src/util/createTip.ts","../src/util/getElementContainer.ts","../src/components/tooltip.ts","../src/components/popover.ts","../src/strings/scrollspyString.ts","../src/strings/scrollspyComponent.ts","../src/components/scrollspy.ts","../src/strings/tabString.ts","../src/strings/tabComponent.ts","../src/components/tab.ts","../src/strings/toastString.ts","../src/strings/toastComponent.ts","../src/components/toast.ts","../src/util/init.ts"],"sourcesContent":["const ariaChecked = \"aria-checked\", ariaDescription = \"aria-description\", ariaDescribedBy = \"aria-describedby\", ariaExpanded = \"aria-expanded\", ariaHasPopup = \"aria-haspopup\", ariaHidden = \"aria-hidden\", ariaLabel = \"aria-label\", ariaLabelledBy = \"aria-labelledby\", ariaModal = \"aria-modal\", ariaPressed = \"aria-pressed\", ariaSelected = \"aria-selected\", ariaValueMin = \"aria-valuemin\", ariaValueMax = \"aria-valuemax\", ariaValueNow = \"aria-valuenow\", ariaValueText = \"aria-valuetext\", abortEvent = \"abort\", beforeunloadEvent = \"beforeunload\", blurEvent = \"blur\", changeEvent = \"change\", contextmenuEvent = \"contextmenu\", DOMContentLoadedEvent = \"DOMContentLoaded\", DOMMouseScrollEvent = \"DOMMouseScroll\", errorEvent = \"error\", focusEvent = \"focus\", focusinEvent = \"focusin\", focusoutEvent = \"focusout\", gesturechangeEvent = \"gesturechange\", gestureendEvent = \"gestureend\", gesturestartEvent = \"gesturestart\", keydownEvent = \"keydown\", keypressEvent = \"keypress\", keyupEvent = \"keyup\", loadEvent = \"load\", mouseclickEvent = \"click\", mousedblclickEvent = \"dblclick\", mousedownEvent = \"mousedown\", mouseupEvent = \"mouseup\", mousehoverEvent = \"hover\", mouseenterEvent = \"mouseenter\", mouseleaveEvent = \"mouseleave\", mouseinEvent = \"mousein\", mouseoutEvent = \"mouseout\", mouseoverEvent = \"mouseover\", mousemoveEvent = \"mousemove\", mousewheelEvent = \"mousewheel\", moveEvent = \"move\", orientationchangeEvent = \"orientationchange\", pointercancelEvent = \"pointercancel\", pointerdownEvent = \"pointerdown\", pointerleaveEvent = \"pointerleave\", pointermoveEvent = \"pointermove\", pointerupEvent = \"pointerup\", readystatechangeEvent = \"readystatechange\", resetEvent = \"reset\", resizeEvent = \"resize\", selectEvent = \"select\", selectendEvent = \"selectend\", selectstartEvent = \"selectstart\", scrollEvent = \"scroll\", submitEvent = \"submit\", touchstartEvent = \"touchstart\", touchmoveEvent = \"touchmove\", touchcancelEvent = \"touchcancel\", touchendEvent = \"touchend\", unloadEvent = \"unload\", nativeEvents = {\n  DOMContentLoaded: DOMContentLoadedEvent,\n  DOMMouseScroll: DOMMouseScrollEvent,\n  abort: abortEvent,\n  beforeunload: beforeunloadEvent,\n  blur: blurEvent,\n  change: changeEvent,\n  click: mouseclickEvent,\n  contextmenu: contextmenuEvent,\n  dblclick: mousedblclickEvent,\n  error: errorEvent,\n  focus: focusEvent,\n  focusin: focusinEvent,\n  focusout: focusoutEvent,\n  gesturechange: gesturechangeEvent,\n  gestureend: gestureendEvent,\n  gesturestart: gesturestartEvent,\n  hover: mousehoverEvent,\n  keydown: keydownEvent,\n  keypress: keypressEvent,\n  keyup: keyupEvent,\n  load: loadEvent,\n  mousedown: mousedownEvent,\n  mousemove: mousemoveEvent,\n  mousein: mouseinEvent,\n  mouseout: mouseoutEvent,\n  mouseenter: mouseenterEvent,\n  mouseleave: mouseleaveEvent,\n  mouseover: mouseoverEvent,\n  mouseup: mouseupEvent,\n  mousewheel: mousewheelEvent,\n  move: moveEvent,\n  orientationchange: orientationchangeEvent,\n  pointercancel: pointercancelEvent,\n  pointerdown: pointerdownEvent,\n  pointerleave: pointerleaveEvent,\n  pointermove: pointermoveEvent,\n  pointerup: pointerupEvent,\n  readystatechange: readystatechangeEvent,\n  reset: resetEvent,\n  resize: resizeEvent,\n  scroll: scrollEvent,\n  select: selectEvent,\n  selectend: selectendEvent,\n  selectstart: selectstartEvent,\n  submit: submitEvent,\n  touchcancel: touchcancelEvent,\n  touchend: touchendEvent,\n  touchmove: touchmoveEvent,\n  touchstart: touchstartEvent,\n  unload: unloadEvent\n}, dragEvent = \"drag\", dragstartEvent = \"dragstart\", dragenterEvent = \"dragenter\", dragleaveEvent = \"dragleave\", dragoverEvent = \"dragover\", dragendEvent = \"dragend\", loadstartEvent = \"loadstart\", mouseSwipeEvents = {\n  start: \"mousedown\",\n  end: \"mouseup\",\n  move: \"mousemove\",\n  cancel: \"mouseleave\"\n}, mouseClickEvents = { down: \"mousedown\", up: \"mouseup\" }, mouseHoverEvents = \"onmouseleave\" in document ? [\"mouseenter\", \"mouseleave\"] : (\n  /* istanbul ignore next @preserve */\n  [\"mouseover\", \"mouseout\"]\n), touchEvents = {\n  start: \"touchstart\",\n  end: \"touchend\",\n  move: \"touchmove\",\n  cancel: \"touchcancel\"\n}, focusEvents = { in: \"focusin\", out: \"focusout\" }, focusableSelector = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex=\"-1\"]', keyboardEventKeys = {\n  Backspace: \"Backspace\",\n  //  8\n  Tab: \"Tab\",\n  //  9\n  Enter: \"Enter\",\n  // 13\n  Shift: \"Shift\",\n  // 16\n  Control: \"Control\",\n  // 17\n  Alt: \"Alt\",\n  // 18\n  Pause: \"Pause\",\n  // 19\n  CapsLock: \"CapsLock\",\n  // 20\n  Escape: \"Escape\",\n  // 27\n  Scape: \"Space\",\n  // 32\n  ArrowLeft: \"ArrowLeft\",\n  // 37\n  ArrowUp: \"ArrowUp\",\n  // 38\n  ArrowRight: \"ArrowRight\",\n  // 39\n  ArrowDown: \"ArrowDown\",\n  // 40\n  Insert: \"Insert\",\n  // 45\n  Delete: \"Delete\",\n  // 46\n  Meta: \"Meta\",\n  // 91 windows key\n  ContextMenu: \"ContextMenu\",\n  // 93\n  ScrollLock: \"ScrollLock\"\n  // 145\n}, keyAlt = \"Alt\", keyArrowDown = \"ArrowDown\", keyArrowUp = \"ArrowUp\", keyArrowLeft = \"ArrowLeft\", keyArrowRight = \"ArrowRight\", keyBackspace = \"Backspace\", keyCapsLock = \"CapsLock\", keyControl = \"Control\", keyDelete = \"Delete\", keyEnter = \"Enter\", keyNumpadEnter = \"NumpadEnter\", keyEscape = \"Escape\", keyInsert = \"Insert\", keyMeta = \"Meta\", keyPause = \"Pause\", keyScrollLock = \"ScrollLock\", keyShift = \"Shift\", keySpace = \"Space\", keyTab = \"Tab\", animationDuration = \"animationDuration\", animationDelay = \"animationDelay\", animationName = \"animationName\", animationEndEvent = \"animationend\", transitionDuration = \"transitionDuration\", transitionDelay = \"transitionDelay\", transitionEndEvent = \"transitionend\", transitionProperty = \"transitionProperty\", addEventListener = \"addEventListener\", removeEventListener = \"removeEventListener\", bezierEasings = {\n  linear: \"linear\",\n  easingSinusoidalIn: \"cubic-bezier(0.47,0,0.745,0.715)\",\n  easingSinusoidalOut: \"cubic-bezier(0.39,0.575,0.565,1)\",\n  easingSinusoidalInOut: \"cubic-bezier(0.445,0.05,0.55,0.95)\",\n  easingQuadraticIn: \"cubic-bezier(0.550,0.085,0.680,0.530)\",\n  easingQuadraticOut: \"cubic-bezier(0.250,0.460,0.450,0.940)\",\n  easingQuadraticInOut: \"cubic-bezier(0.455,0.030,0.515,0.955)\",\n  easingCubicIn: \"cubic-bezier(0.55,0.055,0.675,0.19)\",\n  easingCubicOut: \"cubic-bezier(0.215,0.61,0.355,1)\",\n  easingCubicInOut: \"cubic-bezier(0.645,0.045,0.355,1)\",\n  easingQuarticIn: \"cubic-bezier(0.895,0.03,0.685,0.22)\",\n  easingQuarticOut: \"cubic-bezier(0.165,0.84,0.44,1)\",\n  easingQuarticInOut: \"cubic-bezier(0.77,0,0.175,1)\",\n  easingQuinticIn: \"cubic-bezier(0.755,0.05,0.855,0.06)\",\n  easingQuinticOut: \"cubic-bezier(0.23,1,0.32,1)\",\n  easingQuinticInOut: \"cubic-bezier(0.86,0,0.07,1)\",\n  easingExponentialIn: \"cubic-bezier(0.95,0.05,0.795,0.035)\",\n  easingExponentialOut: \"cubic-bezier(0.19,1,0.22,1)\",\n  easingExponentialInOut: \"cubic-bezier(1,0,0,1)\",\n  easingCircularIn: \"cubic-bezier(0.6,0.04,0.98,0.335)\",\n  easingCircularOut: \"cubic-bezier(0.075,0.82,0.165,1)\",\n  easingCircularInOut: \"cubic-bezier(0.785,0.135,0.15,0.86)\",\n  easingBackIn: \"cubic-bezier(0.6,-0.28,0.735,0.045)\",\n  easingBackOut: \"cubic-bezier(0.175,0.885,0.32,1.275)\",\n  easingBackInOut: \"cubic-bezier(0.68,-0.55,0.265,1.55)\"\n}, offsetHeight = \"offsetHeight\", offsetWidth = \"offsetWidth\", scrollHeight = \"scrollHeight\", scrollWidth = \"scrollWidth\", tabindex = \"tabindex\", userAgentData = navigator.userAgentData, { userAgent: userAgentString } = navigator, userAgent = userAgentString, isMobile = () => {\n  const mobileBrands = /iPhone|iPad|iPod|Android/i;\n  return navigator?.userAgentData?.brands.some(\n    (x) => mobileBrands.test(x.brand)\n  ) || mobileBrands.test(navigator?.userAgent) || !1;\n}, isApple = () => {\n  const appleBrands = /(iPhone|iPod|iPad)/;\n  return navigator?.userAgentData?.brands.some(\n    (x) => appleBrands.test(x.brand)\n  ) || /* istanbul ignore next @preserve */\n  appleBrands.test(\n    navigator?.userAgent\n  ) || !1;\n}, isFirefox = () => navigator?.userAgent?.includes(\"Firefox\") || /* istanbul ignore next @preserve */\n!1, support3DTransform = () => [\"webkitPerspective\", \"perspective\"].some((p) => p in document.head.style), noop = () => {\n}, on = (element, eventName, listener, options) => {\n  const ops = options || !1;\n  element.addEventListener(\n    eventName,\n    listener,\n    ops\n  );\n}, off = (element, eventName, listener, options) => {\n  const ops = options || !1;\n  element.removeEventListener(\n    eventName,\n    listener,\n    ops\n  );\n}, one = (element, eventName, listener, options) => {\n  const handlerWrapper = (e) => {\n    (e.target === element || e.currentTarget === element) && (listener.apply(element, [e]), off(element, eventName, handlerWrapper, options));\n  };\n  on(element, eventName, handlerWrapper, options);\n}, supportPassive = () => {\n  let result = !1;\n  try {\n    const opts = Object.defineProperty({}, \"passive\", {\n      get: () => (result = !0, result)\n    });\n    one(document, DOMContentLoadedEvent, noop, opts);\n  } catch {\n  }\n  return result;\n}, supportTransform = () => [\"webkitTransform\", \"transform\"].some((p) => p in document.head.style), supportTouch = () => \"ontouchstart\" in window || /* istanbul ignore next @preserve */\n\"msMaxTouchPoints\" in navigator, supportAnimation = () => [\"webkitAnimation\", \"animation\"].some((p) => p in document.head.style), supportTransition = () => [\"webkitTransition\", \"transition\"].some((p) => p in document.head.style), getAttribute = (element, att) => element.getAttribute(att), getAttributeNS = (ns, element, att) => element.getAttributeNS(ns, att), hasAttribute = (element, att) => element.hasAttribute(att), hasAttributeNS = (ns, element, att) => element.hasAttributeNS(ns, att), setAttribute = (element, att, value) => element.setAttribute(att, value), setAttributeNS = (ns, element, att, value) => element.setAttributeNS(ns, att, value), removeAttribute = (element, att) => element.removeAttribute(att), removeAttributeNS = (ns, element, att) => element.removeAttributeNS(ns, att), addClass = (element, ...classNAME) => {\n  element.classList.add(...classNAME);\n}, removeClass = (element, ...classNAME) => {\n  element.classList.remove(...classNAME);\n}, hasClass = (element, classNAME) => element.classList.contains(classNAME), { body: documentBody } = document, { documentElement } = document, { head: documentHead } = document, ArrayFrom = (arr) => Array.from(arr), isObject = (obj) => obj != null && typeof obj == \"object\" || !1, isNode = (node) => isObject(node) && typeof node.nodeType == \"number\" && [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].some(\n  (x) => node.nodeType === x\n) || !1, isHTMLElement = (element) => isNode(element) && element.nodeType === 1 || !1, componentData = /* @__PURE__ */ new Map(), Data = {\n  data: componentData,\n  /**\n   * Sets web components data.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   * @param instance the component instance\n   */\n  set: (element, component, instance) => {\n    if (!isHTMLElement(element)) return;\n    componentData.has(component) || componentData.set(component, /* @__PURE__ */ new Map()), componentData.get(component).set(element, instance);\n  },\n  /**\n   * Returns all instances for specified component.\n   *\n   * @param component the component's name or a unique key\n   * @returns all the component instances\n   */\n  getAllFor: (component) => componentData.get(component) || null,\n  /**\n   * Returns the instance associated with the target.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   * @returns the instance\n   */\n  get: (element, component) => {\n    if (!isHTMLElement(element) || !component) return null;\n    const instanceMap = Data.getAllFor(component);\n    return element && instanceMap && instanceMap.get(element) || null;\n  },\n  /**\n   * Removes web components data.\n   *\n   * @param element target element\n   * @param component the component's name or a unique key\n   */\n  remove: (element, component) => {\n    const instanceMap = Data.getAllFor(component);\n    !instanceMap || !isHTMLElement(element) || (instanceMap.delete(element), instanceMap.size === 0 && componentData.delete(component));\n  }\n}, getInstance = (target, component) => Data.get(target, component), isString = (str) => typeof str == \"string\" || !1, isWindow = (obj) => isObject(obj) && obj.constructor.name === \"Window\" || !1, isDocument = (obj) => isNode(obj) && obj.nodeType === 9 || !1, getDocument = (node) => isWindow(node) ? node.document : isDocument(node) ? node : isNode(node) ? node.ownerDocument : globalThis.document, ObjectAssign = (obj, ...source) => Object.assign(obj, ...source), createElement = (param) => {\n  if (!param) return;\n  if (isString(param))\n    return getDocument().createElement(param);\n  const { tagName } = param, newElement = createElement(tagName);\n  if (!newElement) return;\n  const attr = { ...param };\n  return delete attr.tagName, ObjectAssign(newElement, attr);\n}, createElementNS = (ns, param) => {\n  if (!ns || !param) return;\n  if (isString(param))\n    return getDocument().createElementNS(ns, param);\n  const { tagName } = param, newElement = createElementNS(ns, tagName);\n  if (!newElement) return;\n  const attr = { ...param };\n  return delete attr.tagName, ObjectAssign(newElement, attr);\n}, dispatchEvent = (element, event) => element.dispatchEvent(event), distinct = (value, index, arr) => arr.indexOf(value) === index, getElementStyle = (element, property) => {\n  const computedStyle = getComputedStyle(element), prop = property.replace(\"webkit\", \"Webkit\").replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  return computedStyle.getPropertyValue(prop);\n}, getElementAnimationDelay = (element) => {\n  const propertyValue = getElementStyle(element, animationName), durationValue = getElementStyle(element, animationDelay), durationScale = durationValue.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, duration = propertyValue && propertyValue !== \"none\" ? parseFloat(durationValue) * durationScale : 0;\n  return Number.isNaN(duration) ? (\n    /* istanbul ignore next */\n    0\n  ) : duration;\n}, getElementAnimationDuration = (element) => {\n  const propertyValue = getElementStyle(element, animationName), durationValue = getElementStyle(element, animationDuration), durationScale = durationValue.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, duration = propertyValue && propertyValue !== \"none\" ? parseFloat(durationValue) * durationScale : 0;\n  return Number.isNaN(duration) ? (\n    /* istanbul ignore next */\n    0\n  ) : duration;\n}, emulateAnimationEnd = (element, handler) => {\n  let called = 0;\n  const endEvent = new Event(animationEndEvent), duration = getElementAnimationDuration(element), delay = getElementAnimationDelay(element);\n  if (duration) {\n    const animationEndWrapper = (e) => {\n      e.target === element && (handler.apply(element, [e]), element.removeEventListener(animationEndEvent, animationEndWrapper), called = 1);\n    };\n    element.addEventListener(animationEndEvent, animationEndWrapper), setTimeout(() => {\n      called || dispatchEvent(element, endEvent);\n    }, duration + delay + 17);\n  } else\n    handler.apply(element, [endEvent]);\n}, getElementTransitionDelay = (element) => {\n  const propertyValue = getElementStyle(element, transitionProperty), delayValue = getElementStyle(element, transitionDelay), delayScale = delayValue.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, duration = propertyValue && propertyValue !== \"none\" ? parseFloat(delayValue) * delayScale : (\n    /* istanbul ignore next */\n    0\n  );\n  return Number.isNaN(duration) ? (\n    /* istanbul ignore next */\n    0\n  ) : duration;\n}, getElementTransitionDuration = (element) => {\n  const propertyValue = getElementStyle(element, transitionProperty), durationValue = getElementStyle(element, transitionDuration), durationScale = durationValue.includes(\"ms\") ? (\n    /* istanbul ignore next */\n    1\n  ) : 1e3, duration = propertyValue && propertyValue !== \"none\" ? parseFloat(durationValue) * durationScale : (\n    /* istanbul ignore next */\n    0\n  );\n  return Number.isNaN(duration) ? (\n    /* istanbul ignore next */\n    0\n  ) : duration;\n}, emulateTransitionEnd = (element, handler) => {\n  let called = 0;\n  const endEvent = new Event(transitionEndEvent), duration = getElementTransitionDuration(element), delay = getElementTransitionDelay(element);\n  if (duration) {\n    const transitionEndWrapper = (e) => {\n      e.target === element && (handler.apply(element, [e]), element.removeEventListener(transitionEndEvent, transitionEndWrapper), called = 1);\n    };\n    element.addEventListener(transitionEndEvent, transitionEndWrapper), setTimeout(() => {\n      called || dispatchEvent(element, endEvent);\n    }, duration + delay + 17);\n  } else\n    handler.apply(element, [endEvent]);\n}, Float32ArrayFrom = (arr) => Float32Array.from(Array.from(arr)), Float64ArrayFrom = (arr) => Float64Array.from(Array.from(arr)), focus = (element, options) => element.focus(options), normalizeValue = (value) => [\"true\", !0].includes(value) ? !0 : [\"false\", !1].includes(value) ? !1 : [\"null\", \"\", null, void 0].includes(value) ? null : value !== \"\" && !Number.isNaN(+value) ? +value : value, ObjectEntries = (obj) => Object.entries(obj), toLowerCase = (source) => source.toLowerCase(), normalizeOptions = (element, defaultOps, inputOps, ns) => {\n  const INPUT = { ...inputOps }, data = { ...element.dataset }, normalOps = { ...defaultOps }, dataOps = {}, title = \"title\";\n  return ObjectEntries(data).forEach(([k, v]) => {\n    const key = ns && typeof k == \"string\" && k.includes(ns) ? k.replace(ns, \"\").replace(\n      /[A-Z]/g,\n      (match) => toLowerCase(match)\n    ) : (\n      /* istanbul ignore next @preserve */\n      k\n    );\n    dataOps[key] = normalizeValue(v);\n  }), ObjectEntries(INPUT).forEach(([k, v]) => {\n    INPUT[k] = normalizeValue(v);\n  }), ObjectEntries(defaultOps).forEach(([k, v]) => {\n    k in INPUT ? normalOps[k] = INPUT[k] : k in dataOps ? normalOps[k] = dataOps[k] : normalOps[k] = k === title ? getAttribute(element, title) : v;\n  }), normalOps;\n}, ObjectHasOwn = (obj, prop) => isObject(obj) && (Object.hasOwn(obj, prop) || prop in obj), ObjectKeys = (obj) => Object.keys(obj), ObjectValues = (obj) => Object.values(obj), ObjectFromEntries = (entries) => Object.fromEntries(entries), createCustomEvent = (eventType, config) => {\n  const OriginalCustomEvent = new CustomEvent(eventType, {\n    cancelable: !0,\n    bubbles: !0\n  });\n  return isObject(config) && ObjectAssign(OriginalCustomEvent, config), OriginalCustomEvent;\n}, passiveHandler = { passive: !0 }, reflow = (element) => element.offsetHeight, setElementStyle = (element, styles) => {\n  ObjectEntries(styles).forEach(([key, value]) => {\n    if (value && isString(key) && key.includes(\"--\"))\n      element.style.setProperty(key, value);\n    else {\n      const propObject = {};\n      propObject[key] = value, ObjectAssign(element.style, propObject);\n    }\n  });\n}, isMap = (obj) => isObject(obj) && obj.constructor.name === \"Map\" || !1, isNumber = (num) => typeof num == \"number\" || !1, TimeCache = /* @__PURE__ */ new Map(), Timer = {\n  /**\n   * Sets a new timeout timer for an element, or element -> key association.\n   *\n   * @param element target element\n   * @param callback the callback\n   * @param delay the execution delay\n   * @param key a unique key\n   */\n  set: (element, callback, delay, key) => {\n    isHTMLElement(element) && (key && key.length ? (TimeCache.has(element) || TimeCache.set(element, /* @__PURE__ */ new Map()), TimeCache.get(element).set(key, setTimeout(callback, delay))) : TimeCache.set(element, setTimeout(callback, delay)));\n  },\n  /**\n   * Returns the timer associated with the target.\n   *\n   * @param element target element\n   * @param key a unique\n   * @returns the timer\n   */\n  get: (element, key) => {\n    if (!isHTMLElement(element)) return null;\n    const keyTimers = TimeCache.get(element);\n    return key && keyTimers && isMap(keyTimers) ? keyTimers.get(key) || /* istanbul ignore next @preserve */\n    null : isNumber(keyTimers) ? keyTimers : null;\n  },\n  /**\n   * Clears the element's timer.\n   *\n   * @param element target element\n   * @param key a unique key\n   */\n  clear: (element, key) => {\n    if (!isHTMLElement(element)) return;\n    const keyTimers = TimeCache.get(element);\n    key && key.length && isMap(keyTimers) ? (clearTimeout(keyTimers.get(key)), keyTimers.delete(key), keyTimers.size === 0 && TimeCache.delete(element)) : (clearTimeout(keyTimers), TimeCache.delete(element));\n  }\n}, toUpperCase = (source) => source.toUpperCase(), querySelectorAll = (selector, parent) => (isNode(parent) ? parent : getDocument()).querySelectorAll(selector), focusTrapMap = /* @__PURE__ */ new Map();\nfunction handleKeyboardNavigation(event) {\n  const { shiftKey, code } = event, doc = getDocument(this), focusableElements = [\n    ...querySelectorAll(focusableSelector, this)\n  ].filter(\n    (el) => !hasAttribute(el, \"disabled\") && !getAttribute(el, ariaHidden)\n  );\n  if (!focusableElements.length) return;\n  const firstFocusable = focusableElements[0], lastFocusable = focusableElements[focusableElements.length - 1];\n  code === \"Tab\" && (shiftKey && doc.activeElement === firstFocusable ? (lastFocusable.focus(), event.preventDefault()) : !shiftKey && doc.activeElement === lastFocusable && (firstFocusable.focus(), event.preventDefault()));\n}\nconst hasFocusTrap = (target) => focusTrapMap.has(target) === !0, toggleFocusTrap = (target) => {\n  const isCurrentlyTrapped = hasFocusTrap(target);\n  (isCurrentlyTrapped ? off : on)(target, \"keydown\", handleKeyboardNavigation), isCurrentlyTrapped ? focusTrapMap.delete(target) : focusTrapMap.set(target, !0);\n}, getBoundingClientRect = (element, includeScale) => {\n  const { width, height, top, right, bottom, left } = element.getBoundingClientRect();\n  let scaleX = 1, scaleY = 1;\n  if (includeScale && isHTMLElement(element)) {\n    const { offsetWidth: offsetWidth2, offsetHeight: offsetHeight2 } = element;\n    scaleX = offsetWidth2 > 0 ? Math.round(width) / offsetWidth2 : (\n      /* istanbul ignore next @preserve */\n      1\n    ), scaleY = offsetHeight2 > 0 ? Math.round(height) / offsetHeight2 : (\n      /* istanbul ignore next @preserve */\n      1\n    );\n  }\n  return {\n    width: width / scaleX,\n    height: height / scaleY,\n    top: top / scaleY,\n    right: right / scaleX,\n    bottom: bottom / scaleY,\n    left: left / scaleX,\n    x: left / scaleX,\n    y: top / scaleY\n  };\n}, getDocumentBody = (node) => getDocument(node).body, getDocumentElement = (node) => getDocument(node).documentElement, getDocumentHead = (node) => getDocument(node).head, getNodeScroll = (element) => {\n  const isWin = isWindow(element), x = isWin ? element.scrollX : element.scrollLeft, y = isWin ? element.scrollY : element.scrollTop;\n  return { x, y };\n}, isShadowRoot = (element) => isNode(element) && element.constructor.name === \"ShadowRoot\" || !1, getParentNode = (node) => node.nodeName === \"HTML\" ? node : isHTMLElement(node) && node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\nisNode(node) && node.parentNode || // DOM Element detected\nisShadowRoot(node) && node.host || // ShadowRoot detected\ngetDocumentElement(node), isScaledElement = (element) => {\n  if (!isHTMLElement(element)) return !1;\n  const { width, height } = getBoundingClientRect(element), { offsetWidth: offsetWidth2, offsetHeight: offsetHeight2 } = element;\n  return Math.round(width) !== offsetWidth2 || Math.round(height) !== offsetHeight2;\n}, getRectRelativeToOffsetParent = (element, offsetParent, scroll) => {\n  const isParentAnElement = isHTMLElement(offsetParent), rect = getBoundingClientRect(\n    element,\n    isParentAnElement && isScaledElement(offsetParent)\n  ), offsets = { x: 0, y: 0 };\n  if (isParentAnElement) {\n    const offsetRect = getBoundingClientRect(offsetParent, !0);\n    offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;\n  }\n  return {\n    x: rect.left + scroll.x - offsets.x,\n    y: rect.top + scroll.y - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n};\nlet elementUID = 0, elementMapUID = 0;\nconst elementIDMap = /* @__PURE__ */ new Map(), getUID = (element, key) => {\n  let result = key ? elementUID : elementMapUID;\n  if (key) {\n    const elID = getUID(element), elMap = elementIDMap.get(elID) || /* @__PURE__ */ new Map();\n    elementIDMap.has(elID) || elementIDMap.set(elID, elMap), isMap(elMap) && !elMap.has(key) ? (elMap.set(key, result), elementUID += 1) : result = elMap.get(key);\n  } else {\n    const elkey = element.id || element;\n    elementIDMap.has(elkey) ? result = elementIDMap.get(elkey) : (elementIDMap.set(elkey, result), elementMapUID += 1);\n  }\n  return result;\n}, getWindow = (node) => node ? isDocument(node) ? node.defaultView : isNode(node) ? node?.ownerDocument?.defaultView : node : window, isArray = (obj) => Array.isArray(obj) || !1, isCanvas = (element) => isNode(element) && element.nodeName === \"CANVAS\" || !1, isCustomElement = (element) => isHTMLElement(element) && !!element.shadowRoot || !1, isElement = (element) => isNode(element) && [1, 2, 3, 4, 5, 6, 7, 8].some((x) => element.nodeType === x) || !1, isElementInScrollRange = (element) => {\n  if (!isNode(element)) return !1;\n  const { top, bottom } = getBoundingClientRect(element), { clientHeight } = getDocumentElement(element);\n  return top <= clientHeight && bottom >= 0;\n}, isElementInViewport = (element) => {\n  if (!isNode(element)) return !1;\n  const { clientWidth, clientHeight } = getDocumentElement(element), { top, left, bottom, right } = getBoundingClientRect(element, !0);\n  return top >= 0 && left >= 0 && bottom <= clientHeight && right <= clientWidth;\n}, isElementsArray = (obj) => isArray(obj) && obj.every(isHTMLElement) || !1, isFunction = (fn) => typeof fn == \"function\" || !1, isHTMLCollection = (obj) => isObject(obj) && obj.constructor.name === \"HTMLCollection\" || !1, isHTMLImageElement = (element) => isHTMLElement(element) && element.tagName === \"IMG\" || !1, isJSON = (str) => {\n  if (!isString(str)) return !1;\n  try {\n    JSON.parse(str);\n  } catch {\n    return !1;\n  }\n  return !0;\n}, isWeakMap = (obj) => isObject(obj) && obj.constructor.name === \"WeakMap\" || !1, isMedia = (element) => isNode(element) && [\"SVG\", \"Image\", \"Video\", \"Canvas\"].some(\n  (s) => element.constructor.name.includes(s)\n) || !1, isNodeList = (obj) => isObject(obj) && obj.constructor.name === \"NodeList\" || !1, isRTL = (node) => getDocumentElement(node).dir === \"rtl\", isSVGElement = (element) => isNode(element) && element.constructor.name.includes(\"SVG\") || !1, isTableElement = (element) => isNode(element) && [\"TABLE\", \"TD\", \"TH\"].includes(element.nodeName) || !1, closest = (element, selector) => element ? element.closest(selector) || // break out of `ShadowRoot`\nclosest(element.getRootNode().host, selector) : null, querySelector = (selector, parent) => isHTMLElement(selector) ? selector : (isNode(parent) ? parent : getDocument()).querySelector(selector), getElementsByTagName = (selector, parent) => (isNode(parent) ? parent : getDocument()).getElementsByTagName(\n  selector\n), getCustomElements = (parent) => [...getElementsByTagName(\"*\", parent)].filter(isCustomElement), getElementById = (id, context) => getDocument(context).getElementById(id) || null, getElementsByClassName = (selector, parent) => (parent && isNode(parent) ? parent : getDocument()).getElementsByClassName(\n  selector\n), matches = (target, selector) => target.matches(selector), version = \"2.0.7\";\nexport {\n  ArrayFrom,\n  DOMContentLoadedEvent,\n  DOMMouseScrollEvent,\n  Data,\n  Float32ArrayFrom,\n  Float64ArrayFrom,\n  ObjectAssign,\n  ObjectEntries,\n  ObjectFromEntries,\n  ObjectHasOwn,\n  ObjectKeys,\n  ObjectValues,\n  Timer,\n  abortEvent,\n  addClass,\n  addEventListener,\n  animationDelay,\n  animationDuration,\n  animationEndEvent,\n  animationName,\n  ariaChecked,\n  ariaDescribedBy,\n  ariaDescription,\n  ariaExpanded,\n  ariaHasPopup,\n  ariaHidden,\n  ariaLabel,\n  ariaLabelledBy,\n  ariaModal,\n  ariaPressed,\n  ariaSelected,\n  ariaValueMax,\n  ariaValueMin,\n  ariaValueNow,\n  ariaValueText,\n  beforeunloadEvent,\n  bezierEasings,\n  blurEvent,\n  changeEvent,\n  closest,\n  contextmenuEvent,\n  createCustomEvent,\n  createElement,\n  createElementNS,\n  dispatchEvent,\n  distinct,\n  documentBody,\n  documentElement,\n  documentHead,\n  dragEvent,\n  dragendEvent,\n  dragenterEvent,\n  dragleaveEvent,\n  dragoverEvent,\n  dragstartEvent,\n  emulateAnimationEnd,\n  emulateTransitionEnd,\n  errorEvent,\n  focus,\n  focusEvent,\n  focusEvents,\n  focusableSelector,\n  focusinEvent,\n  focusoutEvent,\n  gesturechangeEvent,\n  gestureendEvent,\n  gesturestartEvent,\n  getAttribute,\n  getAttributeNS,\n  getBoundingClientRect,\n  getCustomElements,\n  getDocument,\n  getDocumentBody,\n  getDocumentElement,\n  getDocumentHead,\n  getElementAnimationDelay,\n  getElementAnimationDuration,\n  getElementById,\n  getElementStyle,\n  getElementTransitionDelay,\n  getElementTransitionDuration,\n  getElementsByClassName,\n  getElementsByTagName,\n  getInstance,\n  getNodeScroll,\n  getParentNode,\n  getRectRelativeToOffsetParent,\n  getUID,\n  getWindow,\n  hasAttribute,\n  hasAttributeNS,\n  hasClass,\n  hasFocusTrap,\n  isApple,\n  isArray,\n  isCanvas,\n  isCustomElement,\n  isDocument,\n  isElement,\n  isElementInScrollRange,\n  isElementInViewport,\n  isElementsArray,\n  isFirefox,\n  isFunction,\n  isHTMLCollection,\n  isHTMLElement,\n  isHTMLImageElement,\n  isJSON,\n  isMap,\n  isMedia,\n  isMobile,\n  isNode,\n  isNodeList,\n  isNumber,\n  isObject,\n  isRTL,\n  isSVGElement,\n  isScaledElement,\n  isShadowRoot,\n  isString,\n  isTableElement,\n  isWeakMap,\n  isWindow,\n  keyAlt,\n  keyArrowDown,\n  keyArrowLeft,\n  keyArrowRight,\n  keyArrowUp,\n  keyBackspace,\n  keyCapsLock,\n  keyControl,\n  keyDelete,\n  keyEnter,\n  keyEscape,\n  keyInsert,\n  keyMeta,\n  keyNumpadEnter,\n  keyPause,\n  keyScrollLock,\n  keyShift,\n  keySpace,\n  keyTab,\n  keyboardEventKeys,\n  keydownEvent,\n  keypressEvent,\n  keyupEvent,\n  loadEvent,\n  loadstartEvent,\n  matches,\n  mouseClickEvents,\n  mouseHoverEvents,\n  mouseSwipeEvents,\n  mouseclickEvent,\n  mousedblclickEvent,\n  mousedownEvent,\n  mouseenterEvent,\n  mousehoverEvent,\n  mouseinEvent,\n  mouseleaveEvent,\n  mousemoveEvent,\n  mouseoutEvent,\n  mouseoverEvent,\n  mouseupEvent,\n  mousewheelEvent,\n  moveEvent,\n  nativeEvents,\n  noop,\n  normalizeOptions,\n  normalizeValue,\n  off,\n  offsetHeight,\n  offsetWidth,\n  on,\n  one,\n  orientationchangeEvent,\n  passiveHandler,\n  pointercancelEvent,\n  pointerdownEvent,\n  pointerleaveEvent,\n  pointermoveEvent,\n  pointerupEvent,\n  querySelector,\n  querySelectorAll,\n  readystatechangeEvent,\n  reflow,\n  removeAttribute,\n  removeAttributeNS,\n  removeClass,\n  removeEventListener,\n  resetEvent,\n  resizeEvent,\n  scrollEvent,\n  scrollHeight,\n  scrollWidth,\n  selectEvent,\n  selectendEvent,\n  selectstartEvent,\n  setAttribute,\n  setAttributeNS,\n  setElementStyle,\n  submitEvent,\n  support3DTransform,\n  supportAnimation,\n  supportPassive,\n  supportTouch,\n  supportTransform,\n  supportTransition,\n  tabindex,\n  toLowerCase,\n  toUpperCase,\n  toggleFocusTrap,\n  touchEvents,\n  touchcancelEvent,\n  touchendEvent,\n  touchmoveEvent,\n  touchstartEvent,\n  transitionDelay,\n  transitionDuration,\n  transitionEndEvent,\n  transitionProperty,\n  unloadEvent,\n  userAgent,\n  userAgentData,\n  version\n};\n//# sourceMappingURL=shorty.mjs.map\n","const e = {}, f = (t) => {\n  const { type: c, currentTarget: i } = t;\n  [...e[c]].forEach(([n, s]) => {\n    /* istanbul ignore else @preserve */\n    i === n && [...s].forEach(([o, a]) => {\n      o.apply(n, [t]), typeof a == \"object\" && a.once && r(n, c, o, a);\n    });\n  });\n}, E = (t, c, i, n) => {\n  /* istanbul ignore else @preserve */\n  e[c] || (e[c] = /* @__PURE__ */ new Map());\n  const s = e[c];\n  /* istanbul ignore else @preserve */\n  s.has(t) || s.set(t, /* @__PURE__ */ new Map());\n  const o = s.get(t), { size: a } = o;\n  o.set(i, n);\n  /* istanbul ignore else @preserve */\n  a || t.addEventListener(c, f, n);\n}, r = (t, c, i, n) => {\n  const s = e[c], o = s && s.get(t), a = o && o.get(i), d = a !== void 0 ? a : n;\n  /* istanbul ignore else @preserve */\n  o && o.has(i) && o.delete(i);\n  /* istanbul ignore else @preserve */\n  s && (!o || !o.size) && s.delete(t);\n  /* istanbul ignore else @preserve */\n  (!s || !s.size) && delete e[c];\n  /* istanbul ignore else @preserve */\n  (!o || !o.size) && t.removeEventListener(\n    c,\n    f,\n    d\n  );\n}, g = E, M = r;\nexport {\n  E as addListener,\n  f as globalListener,\n  M as off,\n  g as on,\n  e as registry,\n  r as removeListener\n};\n//# sourceMappingURL=event-listener.mjs.map\n","/**\n * Global namespace for most components `fade` class.\n */\nconst fadeClass = \"fade\";\nexport default fadeClass;\n","/**\n * Global namespace for most components `show` class.\n */\nconst showClass = \"show\";\nexport default showClass;\n","/**\n * Global namespace for most components `dismiss` option.\n */\nconst dataBsDismiss = \"data-bs-dismiss\";\nexport default dataBsDismiss;\n","/** @type {string} */\nconst alertString = \"alert\";\nexport default alertString;\n","/** @type {string} */\nconst alertComponent = \"Alert\";\nexport default alertComponent;\n","import { version } from \"../package.json\";\n\nconst Version = version;\n\nexport default Version;\n","/* Native JavaScript for Bootstrap 5 | Base Component\n----------------------------------------------------- */\nimport {\n  Data,\n  isHTMLElement,\n  isString,\n  normalizeOptions,\n  ObjectKeys,\n  querySelector,\n} from \"@thednp/shorty\";\n\nimport type { BaseOptions } from \"../interface/baseComponent\";\nimport Version from \"../version\";\n\n/** Returns a new `BaseComponent` instance. */\nexport default class BaseComponent {\n  declare element: HTMLElement;\n  declare options?: BaseOptions;\n\n  /**\n   * @param target `HTMLElement` or selector string\n   * @param config component instance options\n   */\n  constructor(target: HTMLElement | string, config?: BaseOptions) {\n    let element: HTMLElement | null;\n\n    try {\n      if (isHTMLElement(target)) {\n        element = target;\n      } else if (isString(target)) {\n        element = querySelector<HTMLElement>(target);\n        // istanbul ignore else @preserve\n        if (!element) throw Error(`\"${target}\" is not a valid selector.`);\n      } else {\n        throw Error(`your target is not an instance of HTMLElement.`);\n      }\n    } catch (e) {\n      throw Error(`${this.name} Error: ${(e as Error).message}`);\n    }\n\n    const prevInstance = Data.get<typeof this>(element, this.name);\n    // istanbul ignore else @preserve\n    if (prevInstance) {\n      // remove previously attached event listeners\n      // to avoid memory leaks\n      prevInstance._toggleEventListeners();\n    }\n\n    this.element = element;\n    this.options = this.defaults && ObjectKeys(this.defaults).length\n      ? normalizeOptions(element, this.defaults, config || {}, \"bs\")\n      // istanbul ignore next @preserve\n      : {};\n\n    Data.set(element, this.name, this);\n  }\n\n  // istanbul ignore next @preserve\n  get version() {\n    return Version;\n  }\n\n  // istanbul ignore next @preserve\n  get name() {\n    return \"BaseComponent\";\n  }\n\n  // istanbul ignore next @preserve\n  get defaults() {\n    return {};\n  }\n\n  /** just to have something to extend from */\n  // istanbul ignore next @preserve coverage wise this isn't important\n  _toggleEventListeners = () => {\n    // do something to please linters\n  };\n\n  /** Removes component from target element. */\n  dispose() {\n    Data.remove<typeof this>(this.element, this.name);\n    ObjectKeys(this).forEach((prop) => {\n      delete this[prop];\n    });\n  }\n}\n","/* Native JavaScript for Bootstrap 5 | Alert\n-------------------------------------------- */\nimport {\n  createCustomEvent,\n  dispatchEvent,\n  emulateTransitionEnd,\n  getInstance,\n  hasClass,\n  mouseclickEvent,\n  querySelector,\n  removeClass,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport fadeClass from \"../strings/fadeClass\";\nimport showClass from \"../strings/showClass\";\nimport dataBsDismiss from \"../strings/dataBsDismiss\";\nimport alertString from \"../strings/alertString\";\nimport alertComponent from \"../strings/alertComponent\";\nimport type { AlertEvent } from \"../interface/alert\";\n\nimport BaseComponent from \"./base-component\";\n\n// ALERT PRIVATE GC\n// ================\nconst alertSelector = `.${alertString}`;\nconst alertDismissSelector = `[${dataBsDismiss}=\"${alertString}\"]`;\n\n/**\n * Static method which returns an existing `Alert` instance associated\n * to a target `Element`.\n */\nconst getAlertInstance = (element: HTMLElement) =>\n  getInstance<Alert>(element, alertComponent);\n\n/**\n * An `Alert` initialization callback.\n */\nconst alertInitCallback = (element: HTMLElement) => new Alert(element);\n\n// ALERT CUSTOM EVENTS\n// ===================\nconst closeAlertEvent = createCustomEvent<Record<string, never>, AlertEvent>(\n  `close.bs.${alertString}`,\n);\nconst closedAlertEvent = createCustomEvent<Record<string, never>, AlertEvent>(\n  `closed.bs.${alertString}`,\n);\n\n// ALERT EVENT HANDLER\n// ===================\n/**\n * Alert `transitionend` callback.\n *\n * @param that target Alert instance\n */\nconst alertTransitionEnd = (self: Alert) => {\n  const { element } = self;\n  dispatchEvent(element, closedAlertEvent);\n\n  self._toggleEventListeners();\n  self.dispose();\n  element.remove();\n};\n\n// ALERT DEFINITION\n// ================\n/** Creates a new Alert instance. */\nexport default class Alert extends BaseComponent {\n  static selector = alertSelector;\n  static init = alertInitCallback;\n  static getInstance = getAlertInstance;\n  dismiss: HTMLElement | null;\n\n  constructor(target: HTMLElement | string) {\n    super(target);\n\n    // the dismiss button\n    this.dismiss = querySelector(alertDismissSelector, this.element);\n\n    // add event listener\n    this._toggleEventListeners(true);\n  }\n\n  /** Returns component name string. */\n  get name() {\n    return alertComponent;\n  }\n\n  // ALERT PUBLIC METHODS\n  // ====================\n  /**\n   * Public method that hides the `.alert` element from the user,\n   * disposes the instance once animation is complete, then\n   * removes the element from the DOM.\n   */\n  close = () => {\n    const { element } = this;\n\n    // istanbul ignore else @preserve\n    if (element && hasClass(element, showClass)) {\n      dispatchEvent(element, closeAlertEvent);\n\n      if (!closeAlertEvent.defaultPrevented) {\n        removeClass(element, showClass);\n\n        if (hasClass(element, fadeClass)) {\n          emulateTransitionEnd(element, () => alertTransitionEnd(this));\n        } else alertTransitionEnd(this);\n      }\n    }\n  };\n  /**\n   * Toggle on / off the `click` event listener.\n   *\n   * @param add when `true`, event listener is added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    const { dismiss, close } = this;\n    // istanbul ignore else @preserve\n    if (dismiss) action(dismiss, mouseclickEvent, close);\n  };\n\n  /** Remove the component from target element. */\n  dispose() {\n    this._toggleEventListeners();\n    super.dispose();\n  }\n}\n","/**\n * Global namespace for most components active class.\n */\nconst activeClass = \"active\";\nexport default activeClass;\n","/**\n * Global namespace for most components `toggle` option.\n */\nconst dataBsToggle = \"data-bs-toggle\";\nexport default dataBsToggle;\n","/** @type {string} */\nconst buttonString = \"button\";\nexport default buttonString;\n","/** @type {string} */\nconst buttonComponent = \"Button\";\nexport default buttonComponent;\n","/* Native JavaScript for Bootstrap 5 | Button\n---------------------------------------------*/\nimport {\n  addClass,\n  ariaPressed,\n  getAttribute,\n  getInstance,\n  hasClass,\n  mouseclickEvent,\n  removeClass,\n  setAttribute,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport activeClass from \"../strings/activeClass\";\nimport dataBsToggle from \"../strings/dataBsToggle\";\nimport buttonString from \"../strings/buttonString\";\nimport buttonComponent from \"../strings/buttonComponent\";\n\nimport BaseComponent from \"./base-component\";\n\n// BUTTON PRIVATE GC\n// =================\nconst buttonSelector = `[${dataBsToggle}=\"${buttonString}\"]`;\n\n/**\n * Static method which returns an existing `Button` instance associated\n * to a target `Element`.\n */\nconst getButtonInstance = (element: HTMLElement) =>\n  getInstance<Button>(element, buttonComponent);\n\n/** A `Button` initialization callback. */\nconst buttonInitCallback = (element: HTMLElement) => new Button(element);\n\n// BUTTON DEFINITION\n// =================\n/** Creates a new `Button` instance. */\nexport default class Button extends BaseComponent {\n  static selector = buttonSelector;\n  static init = buttonInitCallback;\n  static getInstance = getButtonInstance;\n\n  isActive = false;\n\n  /**\n   * @param target usually a `.btn` element\n   */\n  constructor(target: HTMLElement | string) {\n    super(target);\n\n    // initialization element\n    const { element } = this;\n\n    // set initial state\n    this.isActive = hasClass(element, activeClass);\n    setAttribute(element, ariaPressed, String(!!this.isActive));\n\n    // add event listener\n    this._toggleEventListeners(true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return buttonComponent;\n  }\n\n  // BUTTON PUBLIC METHODS\n  // =====================\n  /**\n   * Toggles the state of the target button.\n   *\n   * @param e usually `click` Event object\n   */\n  toggle = (e?: Event) => {\n    if (e) e.preventDefault();\n\n    const { element, isActive } = this;\n    if (!hasClass(element, \"disabled\") && !getAttribute(element, \"disabled\")) {\n      const action = isActive ? removeClass : addClass;\n      action(element, activeClass);\n      setAttribute(element, ariaPressed, isActive ? \"false\" : \"true\");\n      this.isActive = hasClass(element, activeClass);\n    }\n  };\n\n  // BUTTON PRIVATE METHOD\n  // =====================\n  /**\n   * Toggles on/off the `click` event listener.\n   *\n   * @param add when `true`, event listener is added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    action(this.element, mouseclickEvent, this.toggle);\n  };\n\n  /** Removes the `Button` component from the target element. */\n  dispose() {\n    this._toggleEventListeners();\n    super.dispose();\n  }\n}\n","/**\n * Global namespace for most components `target` option.\n */\nconst dataBsTarget = \"data-bs-target\";\nexport default dataBsTarget;\n","/** @type {string} */\nconst carouselString = \"carousel\";\nexport default carouselString;\n","/** @type {string} */\nconst carouselComponent = \"Carousel\";\nexport default carouselComponent;\n","/**\n * Global namespace for most components `parent` option.\n */\nconst dataBsParent = \"data-bs-parent\";\nexport default dataBsParent;\n","/**\n * Global namespace for most components `container` option.\n */\nconst dataBsContainer = \"data-bs-container\";\nexport default dataBsContainer;\n","import {\n  closest,\n  getAttribute,\n  getDocument,\n  querySelector,\n} from \"@thednp/shorty\";\n\nimport dataBsTarget from \"../strings/dataBsTarget\";\nimport dataBsParent from \"../strings/dataBsParent\";\nimport dataBsContainer from \"../strings/dataBsContainer\";\n\n/**\n * Returns the `Element` that THIS one targets\n * via `data-bs-target`, `href`, `data-bs-parent` or `data-bs-container`.\n *\n * @param element the target element\n * @returns the query result\n */\nconst getTargetElement = (element: HTMLElement) => {\n  const targetAttr = [dataBsTarget, dataBsParent, dataBsContainer, \"href\"];\n  const doc = getDocument(element);\n\n  return targetAttr\n    .map((att) => {\n      const attValue = getAttribute(element, att);\n      if (attValue) {\n        return att === dataBsParent\n          ? closest(element, attValue)\n          : querySelector(attValue, doc);\n      }\n      return null;\n    })\n    .filter((x) => x)[0];\n};\n\nexport default getTargetElement;\n","/* Native JavaScript for Bootstrap 5 | Carousel\n----------------------------------------------- */\nimport {\n  addClass,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  dragstartEvent,\n  emulateTransitionEnd,\n  getAttribute,\n  getDocument,\n  getElementsByClassName,\n  getElementTransitionDuration,\n  getInstance,\n  hasClass,\n  isElementInScrollRange,\n  isHTMLElement,\n  isRTL,\n  keyArrowLeft,\n  keyArrowRight,\n  keydownEvent,\n  matches,\n  mouseclickEvent,\n  mouseenterEvent,\n  mouseleaveEvent,\n  ObjectAssign,\n  passiveHandler,\n  pointerdownEvent,\n  pointermoveEvent,\n  pointerupEvent,\n  querySelector,\n  querySelectorAll,\n  reflow,\n  removeClass,\n  Timer,\n  touchstartEvent,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport activeClass from \"../strings/activeClass\";\nimport dataBsTarget from \"../strings/dataBsTarget\";\nimport carouselString from \"../strings/carouselString\";\nimport carouselComponent from \"../strings/carouselComponent\";\nimport getTargetElement from \"../util/getTargetElement\";\nimport BaseComponent from \"./base-component\";\nimport type { CarouselEvent, CarouselOptions } from \"../interface/carousel\";\n\ntype CarouselEventProperties = {\n  relatedTarget: HTMLElement;\n  from: number;\n  to: number;\n  direction: \"left\" | \"right\";\n};\n\n// CAROUSEL PRIVATE GC\n// ===================\nconst carouselSelector = `[data-bs-ride=\"${carouselString}\"]`;\nconst carouselItem = `${carouselString}-item`;\nconst dataBsSlideTo = \"data-bs-slide-to\";\nconst dataBsSlide = \"data-bs-slide\";\nconst pausedClass = \"paused\";\n\nconst carouselDefaults: CarouselOptions = {\n  pause: \"hover\",\n  keyboard: false,\n  touch: true,\n  interval: 5000,\n};\n\n/**\n * Static method which returns an existing `Carousel` instance associated\n * to a target `Element`.\n */\nconst getCarouselInstance = (element: HTMLElement) =>\n  getInstance<Carousel>(element, carouselComponent);\n\n/**\n * A `Carousel` initialization callback.\n */\nconst carouselInitCallback = (element: HTMLElement) => new Carousel(element);\n\nlet startX = 0;\nlet currentX = 0;\nlet endX = 0;\n\n// CAROUSEL CUSTOM EVENTS\n// ======================\nconst carouselSlideEvent = createCustomEvent<\n  CarouselEventProperties,\n  CarouselEvent\n>(`slide.bs.${carouselString}`);\nconst carouselSlidEvent = createCustomEvent<\n  CarouselEventProperties,\n  CarouselEvent\n>(`slid.bs.${carouselString}`);\n\n// CAROUSEL EVENT HANDLERS\n// =======================\n/**\n * The `transitionend` event listener of the `Carousel`.\n *\n * @param self the `Carousel` instance\n */\nconst carouselTransitionEndHandler = (self: Carousel) => {\n  const { index, direction, element, slides, options } = self;\n\n  // istanbul ignore else @preserve\n  if (self.isAnimating) {\n    const activeItem = getActiveIndex(self);\n    const orientation = direction === \"left\" ? \"next\" : \"prev\";\n    const directionClass = direction === \"left\" ? \"start\" : \"end\";\n\n    addClass(slides[index], activeClass);\n    removeClass(slides[index], `${carouselItem}-${orientation}`);\n    removeClass(slides[index], `${carouselItem}-${directionClass}`);\n\n    removeClass(slides[activeItem], activeClass);\n    removeClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n    dispatchEvent(element, carouselSlidEvent);\n    Timer.clear(element, dataBsSlide);\n\n    // must check if a previous instance is disposed\n    if (\n      self.cycle && !getDocument(element).hidden && options.interval &&\n      !self.isPaused\n    ) {\n      self.cycle();\n    }\n  }\n};\n\n/**\n * Handles the `mouseenter` events when *options.pause*\n * is set to `hover`.\n */\nfunction carouselPauseHandler(this: HTMLElement) {\n  const self = getCarouselInstance(this);\n  // istanbul ignore else @preserve\n  if (self && !self.isPaused && !Timer.get(this, pausedClass)) {\n    addClass(this, pausedClass);\n  }\n}\n\n/**\n * Handles the `mouseleave` events when *options.pause*\n * is set to `hover`.\n */\nfunction carouselResumeHandler(this: HTMLElement) {\n  const self = getCarouselInstance(this);\n  // istanbul ignore else @preserve\n  if (self && self.isPaused && !Timer.get(this, pausedClass)) {\n    self.cycle();\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` indicators.\n *\n * @param e the `Event` object\n */\nfunction carouselIndicatorHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  const element =\n    (closest(this, carouselSelector) || getTargetElement(this)) as HTMLElement;\n  const self = getCarouselInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self && !self.isAnimating) {\n    const newIndex = +(\n      getAttribute(this, dataBsSlideTo) ||\n      // istanbul ignore next @preserve\n      0\n    );\n\n    // istanbul ignore else @preserve\n    if (\n      this &&\n      !hasClass(this, activeClass) && // event target is not active\n      !Number.isNaN(newIndex)\n    ) {\n      // AND has the specific attribute\n      self.to(newIndex); // do the slide\n    }\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` arrows.\n *\n * @param e the `Event` object\n */\nfunction carouselControlsHandler(this: HTMLElement, e: MouseEvent) {\n  e.preventDefault();\n  const element = closest(this, carouselSelector) ||\n    (getTargetElement(this) as HTMLElement);\n  const self = getCarouselInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self && !self.isAnimating) {\n    const orientation = getAttribute(this, dataBsSlide);\n\n    // istanbul ignore else @preserve\n    if (orientation === \"next\") {\n      self.next();\n    } else if (orientation === \"prev\") {\n      self.prev();\n    }\n  }\n}\n\n/**\n * Handles the keyboard `keydown` event for the visible `Carousel` elements.\n *\n * @param e the `Event` object\n */\nconst carouselKeyHandler = (\n  { code, target }: KeyboardEvent & { target: Node },\n) => {\n  const doc = getDocument(target);\n  const [element] = [...querySelectorAll(carouselSelector, doc)].filter((x) =>\n    isElementInScrollRange(x)\n  );\n  const self = getCarouselInstance(element);\n\n  // istanbul ignore next @preserve\n  if (self && !self.isAnimating && !/textarea|input/i.test(target.nodeName)) {\n    const RTL = isRTL(element);\n    const arrowKeyNext = !RTL ? keyArrowRight : keyArrowLeft;\n    const arrowKeyPrev = !RTL ? keyArrowLeft : keyArrowRight;\n\n    // istanbul ignore else @preserve\n    if (code === arrowKeyPrev) self.prev();\n    else if (code === arrowKeyNext) self.next();\n  }\n};\n\n// CAROUSEL TOUCH HANDLERS\n// =======================\n/**\n * Prevents the `touchstart` and `dragstart` events for the `Carousel` element.\n *\n * @param e the `Event` object\n */\nfunction carouselDragHandler(this: HTMLElement, e: DragEvent | TouchEvent) {\n  const { target } = e;\n  const self = getCarouselInstance(this);\n\n  // istanbul ignore next @preserve\n  if (\n    self &&\n    self.isTouch &&\n    ((self.indicator && !self.indicator.contains(target as Node)) ||\n      !self.controls.includes(target as HTMLElement))\n  ) {\n    e.stopImmediatePropagation();\n    e.stopPropagation();\n    e.preventDefault();\n  }\n}\n\n// CAROUSEL POINTER HANDLERS\n// =========================\n/**\n * Handles the `pointerdown` event for the `Carousel` element.\n *\n * @param e the `Event` object\n */\nfunction carouselPointerDownHandler(this: HTMLElement, e: PointerEvent) {\n  const { target } = e;\n  const self = getCarouselInstance(this);\n\n  // istanbul ignore else @preserve\n  if (self && !self.isAnimating && !self.isTouch) {\n    // filter pointer event on controls & indicators\n    const { controls, indicators } = self;\n    // istanbul ignore else @preserve\n    if (\n      ![...controls, ...indicators].every((el) =>\n        el === target || el.contains(target as Node)\n      )\n    ) {\n      startX = e.pageX;\n\n      // istanbul ignore else @preserve\n      if (this.contains(target as Node)) {\n        self.isTouch = true;\n        toggleCarouselTouchHandlers(self, true);\n      }\n    }\n  }\n}\n\n/**\n * Handles the `pointermove` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerMoveHandler = (e: PointerEvent) => {\n  currentX = e.pageX;\n};\n\n/**\n * Handles the `pointerup` event for the `Carousel` element.\n *\n * @param e\n */\nconst carouselPointerUpHandler = (e: PointerEvent) => {\n  const { target } = e;\n  const doc = getDocument(target as Node);\n  const self = [...querySelectorAll(carouselSelector, doc)]\n    .map((c) => getCarouselInstance(c) as Carousel)\n    .find((i) => i.isTouch) as Carousel;\n\n  // impossible to satisfy\n  // istanbul ignore else @preserve\n  if (self) {\n    const { element, index } = self;\n    const RTL = isRTL(element);\n    endX = e.pageX;\n\n    self.isTouch = false;\n    toggleCarouselTouchHandlers(self);\n\n    if (\n      !doc.getSelection()?.toString().length &&\n      element.contains(target as HTMLElement) &&\n      Math.abs(startX - endX) > 120\n    ) {\n      // determine next index to slide to\n      // istanbul ignore else @preserve\n      if (currentX < startX) {\n        self.to(index + (RTL ? -1 : 1));\n      } else if (currentX > startX) {\n        self.to(index + (RTL ? 1 : -1));\n      }\n    }\n\n    // reset pointer position\n    startX = 0;\n    currentX = 0;\n    endX = 0;\n  }\n};\n\n// CAROUSEL PRIVATE METHODS\n// ========================\n/**\n * Sets active indicator for the `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param index the index of the new active indicator\n */\nconst activateCarouselIndicator = (self: Carousel, index: number) => {\n  const { indicators } = self;\n  [...indicators].forEach((x) => removeClass(x, activeClass));\n\n  // istanbul ignore else @preserve\n  if (self.indicators[index]) addClass(indicators[index], activeClass);\n};\n\n/**\n * Toggles the pointer event listeners for a given `Carousel` instance.\n *\n * @param self the `Carousel` instance\n * @param add when `TRUE` event listeners are added\n */\nconst toggleCarouselTouchHandlers = (self: Carousel, add?: boolean) => {\n  const { element } = self;\n  const action = add ? addListener : removeListener;\n  action(\n    getDocument(element),\n    pointermoveEvent,\n    carouselPointerMoveHandler,\n    passiveHandler,\n  );\n  action(\n    getDocument(element),\n    pointerupEvent,\n    carouselPointerUpHandler,\n    passiveHandler,\n  );\n};\n\n/**\n * Returns the index of the current active item.\n *\n * @param self the `Carousel` instance\n * @returns the query result\n */\nconst getActiveIndex = (self: Carousel) => {\n  const { slides, element } = self;\n  const activeItem = querySelector(`.${carouselItem}.${activeClass}`, element);\n  return isHTMLElement(activeItem) ? [...slides].indexOf(activeItem) : -1;\n};\n\n// CAROUSEL DEFINITION\n// ===================\n/** Creates a new `Carousel` instance. */\nexport default class Carousel extends BaseComponent {\n  static selector = carouselSelector;\n  static init = carouselInitCallback;\n  static getInstance = getCarouselInstance;\n  declare options: CarouselOptions;\n  declare direction: \"right\" | \"left\";\n  declare index: number;\n  declare isTouch: boolean;\n  declare slides: HTMLCollectionOf<HTMLElement>;\n  declare controls: HTMLElement[];\n  declare indicator: HTMLElement | null;\n  declare indicators: HTMLElement[];\n\n  /**\n   * @param target mostly a `.carousel` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<CarouselOptions>) {\n    super(target, config);\n\n    // initialization element\n    const { element } = this;\n\n    // additional properties\n    this.direction = isRTL(element) ? \"right\" : \"left\";\n    this.isTouch = false;\n\n    // carousel elements\n    // a LIVE collection is prefferable\n    this.slides = getElementsByClassName(carouselItem, element);\n    const { slides } = this;\n\n    // invalidate when not enough items\n    // no need to go further\n    if (slides.length >= 2) {\n      const activeIndex = getActiveIndex(this);\n      // recover item from disposed instance\n      const transitionItem = [...slides].find((s) =>\n        matches(s, `.${carouselItem}-next,.${carouselItem}-next`)\n      );\n      this.index = activeIndex;\n\n      // external controls must be within same document context\n      const doc = getDocument(element);\n\n      this.controls = [\n        ...querySelectorAll(`[${dataBsSlide}]`, element),\n        ...querySelectorAll(\n          `[${dataBsSlide}][${dataBsTarget}=\"#${element.id}\"]`,\n          doc,\n        ),\n      ].filter((c, i, ar) => i === ar.indexOf(c));\n\n      this.indicator = querySelector(`.${carouselString}-indicators`, element);\n\n      // a LIVE collection is prefferable\n      this.indicators = [\n        ...(this.indicator\n          ? querySelectorAll(`[${dataBsSlideTo}]`, this.indicator)\n          // istanbul ignore next @preserve\n          : []),\n        ...querySelectorAll(\n          `[${dataBsSlideTo}][${dataBsTarget}=\"#${element.id}\"]`,\n          doc,\n        ),\n      ].filter((c, i, ar) => i === ar.indexOf(c));\n\n      // set JavaScript and DATA API options\n      const { options } = this;\n\n      // don't use TRUE as interval, it's actually 0, use the default 5000ms better\n      this.options.interval = options.interval === true\n        ? carouselDefaults.interval\n        : options.interval;\n\n      // set first slide active if none\n      // istanbul ignore next @preserve - impossible to test\n      if (transitionItem) {\n        this.index = [...slides].indexOf(transitionItem);\n      } else if (activeIndex < 0) {\n        this.index = 0;\n        addClass(slides[0], activeClass);\n        if (this.indicators.length) activateCarouselIndicator(this, 0);\n      }\n\n      // istanbul ignore else @preserve\n      if (this.indicators.length) activateCarouselIndicator(this, this.index);\n\n      // attach event handlers\n      this._toggleEventListeners(true);\n\n      // start to cycle if interval is set\n      if (options.interval) this.cycle();\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return carouselComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return carouselDefaults;\n  }\n\n  /**\n   * Check if instance is paused.\n   */\n  get isPaused() {\n    return hasClass(this.element, pausedClass);\n  }\n\n  /**\n   * Check if instance is animating.\n   */\n  get isAnimating() {\n    return querySelector(\n      `.${carouselItem}-next,.${carouselItem}-prev`,\n      this.element,\n    ) !== null;\n  }\n\n  // CAROUSEL PUBLIC METHODS\n  // =======================\n  /** Slide automatically through items. */\n  cycle() {\n    const { element, options, isPaused, index } = this;\n\n    Timer.clear(element, carouselString);\n    if (isPaused) {\n      Timer.clear(element, pausedClass);\n      removeClass(element, pausedClass);\n    }\n\n    Timer.set(\n      element,\n      () => {\n        // it's very important to check self.element\n        // where instance might have been disposed\n        // istanbul ignore else @preserve\n        if (\n          this.element && !this.isPaused && !this.isTouch &&\n          isElementInScrollRange(element)\n        ) {\n          this.to(index + 1);\n        }\n      },\n      options.interval as number,\n      carouselString,\n    );\n  }\n\n  /** Pause the automatic cycle. */\n  pause() {\n    const { element, options } = this;\n    // istanbul ignore else @preserve\n    if (!this.isPaused && options.interval) {\n      addClass(element, pausedClass);\n      Timer.set(\n        element,\n        () => {\n          /* ESLint is now happy */\n        },\n        1,\n        pausedClass,\n      );\n    }\n  }\n\n  /** Slide to the next item. */\n  next() {\n    // istanbul ignore else @preserve\n    if (!this.isAnimating) {\n      this.to(this.index + 1);\n    }\n  }\n\n  /** Slide to the previous item. */\n  prev() {\n    // istanbul ignore else @preserve\n    if (!this.isAnimating) {\n      this.to(this.index - 1);\n    }\n  }\n\n  /**\n   * Jump to the item with the `idx` index.\n   *\n   * @param idx the index of the item to jump to\n   */\n  to(idx: number) {\n    const { element, slides, options } = this;\n    const activeItem = getActiveIndex(this);\n    const RTL = isRTL(element);\n    let next = idx;\n\n    // when controled via methods, make sure to check again\n    // first return if we're on the same item #227\n    // `to()` must be SPAM protected by Timer\n    if (\n      !this.isAnimating && activeItem !== next &&\n      !Timer.get(element, dataBsSlide)\n    ) {\n      // determine transition direction\n      // istanbul ignore else @preserve\n      if (\n        activeItem < next || (activeItem === 0 && next === slides.length - 1)\n      ) {\n        this.direction = RTL ? \"right\" : \"left\"; // next\n      } else if (\n        activeItem > next || (activeItem === slides.length - 1 && next === 0)\n      ) {\n        this.direction = RTL ? \"left\" : \"right\"; // prev\n      }\n      const { direction } = this;\n\n      // find the right next index\n      if (next < 0) {\n        next = slides.length - 1;\n      } else if (next >= slides.length) {\n        next = 0;\n      }\n\n      // orientation, class name, eventProperties\n      const orientation = direction === \"left\" ? \"next\" : \"prev\";\n      const directionClass = direction === \"left\" ? \"start\" : \"end\";\n\n      const eventProperties = {\n        relatedTarget: slides[next],\n        from: activeItem,\n        to: next,\n        direction,\n      };\n\n      // update event properties\n      ObjectAssign(carouselSlideEvent, eventProperties);\n      ObjectAssign(carouselSlidEvent, eventProperties);\n\n      // discontinue when prevented\n      dispatchEvent(element, carouselSlideEvent);\n      if (!carouselSlideEvent.defaultPrevented) {\n        // update index\n        this.index = next;\n        activateCarouselIndicator(this, next);\n\n        if (\n          getElementTransitionDuration(slides[next]) &&\n          hasClass(element, \"slide\")\n        ) {\n          Timer.set(\n            element,\n            () => {\n              addClass(slides[next], `${carouselItem}-${orientation}`);\n              reflow(slides[next]);\n              addClass(slides[next], `${carouselItem}-${directionClass}`);\n              addClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n              // the instance might get diposed mid-animation\n              emulateTransitionEnd(\n                slides[next],\n                () =>\n                  this.slides && this.slides.length &&\n                  carouselTransitionEndHandler(this),\n              );\n            },\n            0,\n            dataBsSlide,\n          );\n        } else {\n          addClass(slides[next], activeClass);\n          removeClass(slides[activeItem], activeClass);\n\n          Timer.set(\n            element,\n            () => {\n              Timer.clear(element, dataBsSlide);\n              // check for element, might have been disposed\n              // istanbul ignore else @preserve\n              if (element && options.interval && !this.isPaused) {\n                this.cycle();\n              }\n\n              dispatchEvent(element, carouselSlidEvent);\n            },\n            0,\n            dataBsSlide,\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Toggles all event listeners for the `Carousel` instance.\n   *\n   * @param add when `TRUE` event listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const { element, options, slides, controls, indicators } = this;\n    const { touch, pause, interval, keyboard } = options;\n    const action = add ? addListener : removeListener;\n\n    if (pause && interval) {\n      action(element, mouseenterEvent, carouselPauseHandler);\n      action(element, mouseleaveEvent, carouselResumeHandler);\n    }\n\n    if (touch && slides.length > 2) {\n      action(\n        element,\n        pointerdownEvent,\n        carouselPointerDownHandler,\n        passiveHandler,\n      );\n      action(element, touchstartEvent, carouselDragHandler, { passive: false });\n      action(element, dragstartEvent, carouselDragHandler, { passive: false });\n    }\n\n    // istanbul ignore else @preserve\n    if (controls.length) {\n      controls.forEach((arrow) => {\n        // istanbul ignore else @preserve\n        if (arrow) action(arrow, mouseclickEvent, carouselControlsHandler);\n      });\n    }\n\n    // istanbul ignore else @preserve\n    if (indicators.length) {\n      indicators.forEach((indicator) => {\n        action(indicator, mouseclickEvent, carouselIndicatorHandler);\n      });\n    }\n\n    if (keyboard) {\n      action(getDocument(element), keydownEvent, carouselKeyHandler);\n    }\n  };\n\n  /** Remove `Carousel` component from target. */\n  dispose() {\n    const { isAnimating } = this;\n\n    const clone = {\n      ...this,\n      isAnimating,\n    };\n    this._toggleEventListeners();\n    super.dispose();\n\n    // istanbul ignore next @preserve - impossible to test in playwright\n    if (clone.isAnimating) {\n      emulateTransitionEnd(clone.slides[clone.index], () => {\n        carouselTransitionEndHandler(clone);\n      });\n    }\n  }\n}\n","/**\n * Global namespace for most components `collapsing` class.\n * As used by `Collapse` / `Tab`.\n */\nconst collapsingClass = \"collapsing\";\nexport default collapsingClass;\n","/** @type {string} */\nconst collapseString = \"collapse\";\nexport default collapseString;\n","/** @type {string} */\nconst collapseComponent = \"Collapse\";\nexport default collapseComponent;\n","/* Native JavaScript for Bootstrap 5 | Collapse\n----------------------------------------------- */\nimport {\n  addClass,\n  ariaExpanded,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  emulateTransitionEnd,\n  getDocument,\n  getInstance,\n  hasClass,\n  isHTMLElement,\n  isString,\n  mouseclickEvent,\n  noop,\n  querySelector,\n  querySelectorAll,\n  reflow,\n  removeClass,\n  setAttribute,\n  setElementStyle,\n  Timer,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport dataBsToggle from \"../strings/dataBsToggle\";\nimport collapsingClass from \"../strings/collapsingClass\";\nimport showClass from \"../strings/showClass\";\nimport collapseString from \"../strings/collapseString\";\nimport collapseComponent from \"../strings/collapseComponent\";\n\nimport getTargetElement from \"../util/getTargetElement\";\nimport BaseComponent from \"./base-component\";\nimport type { CollapseEvent, CollapseOptions } from \"../interface/collapse\";\n\n// COLLAPSE GC\n// ===========\nconst collapseSelector = `.${collapseString}`;\nconst collapseToggleSelector = `[${dataBsToggle}=\"${collapseString}\"]`;\nconst collapseDefaults = { parent: null };\n\n/**\n * Static method which returns an existing `Collapse` instance associated\n * to a target `Element`.\n */\nconst getCollapseInstance = (element: HTMLElement) =>\n  getInstance<Collapse>(element, collapseComponent);\n\n/**\n * A `Collapse` initialization callback.\n */\nconst collapseInitCallback = (element: HTMLElement) => new Collapse(element);\n\n// COLLAPSE CUSTOM EVENTS\n// ======================\nconst showCollapseEvent = createCustomEvent<\n  Record<string, never>,\n  CollapseEvent\n>(`show.bs.${collapseString}`);\nconst shownCollapseEvent = createCustomEvent<\n  Record<string, never>,\n  CollapseEvent\n>(`shown.bs.${collapseString}`);\nconst hideCollapseEvent = createCustomEvent<\n  Record<string, never>,\n  CollapseEvent\n>(`hide.bs.${collapseString}`);\nconst hiddenCollapseEvent = createCustomEvent<\n  Record<string, never>,\n  CollapseEvent\n>(`hidden.bs.${collapseString}`);\n\n// COLLAPSE PRIVATE METHODS\n// ========================\n/**\n * Expand the designated `Element`.\n *\n * @param self the `Collapse` instance\n */\nconst expandCollapse = (self: Collapse) => {\n  const { element, parent, triggers } = self;\n\n  dispatchEvent(element, showCollapseEvent);\n  if (!showCollapseEvent.defaultPrevented) {\n    Timer.set(element, noop, 17);\n    if (parent) Timer.set(parent, noop, 17);\n\n    addClass(element, collapsingClass);\n    removeClass(element, collapseString);\n\n    setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n    emulateTransitionEnd(element, () => {\n      Timer.clear(element);\n      if (parent) Timer.clear(parent);\n\n      triggers.forEach((btn) => setAttribute(btn, ariaExpanded, \"true\"));\n\n      removeClass(element, collapsingClass);\n      addClass(element, collapseString);\n      addClass(element, showClass);\n\n      setElementStyle(element, { height: \"\" });\n\n      dispatchEvent(element, shownCollapseEvent);\n    });\n  }\n};\n\n/**\n * Collapse the designated `Element`.\n *\n * @param self the `Collapse` instance\n */\nconst collapseContent = (self: Collapse) => {\n  const { element, parent, triggers } = self;\n\n  dispatchEvent(element, hideCollapseEvent);\n\n  if (!hideCollapseEvent.defaultPrevented) {\n    Timer.set(element, noop, 17);\n    if (parent) Timer.set(parent, noop, 17);\n\n    setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n    removeClass(element, collapseString);\n    removeClass(element, showClass);\n    addClass(element, collapsingClass);\n\n    reflow(element);\n    setElementStyle(element, { height: \"0px\" });\n\n    emulateTransitionEnd(element, () => {\n      Timer.clear(element);\n      // istanbul ignore else @preserve\n      if (parent) Timer.clear(parent);\n\n      triggers.forEach((btn) => setAttribute(btn, ariaExpanded, \"false\"));\n\n      removeClass(element, collapsingClass);\n      addClass(element, collapseString);\n\n      setElementStyle(element, { height: \"\" });\n\n      dispatchEvent(element, hiddenCollapseEvent);\n    });\n  }\n};\n\n// COLLAPSE EVENT HANDLER\n// ======================\n/**\n * Handles the `click` event for the `Collapse` instance.\n *\n * @param e the `Event` object\n */\nconst collapseClickHandler = (e: MouseEvent) => {\n  const { target } = e; // our target is `HTMLElement`\n  const trigger = target &&\n    closest(target as HTMLElement, collapseToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getCollapseInstance(element);\n  // istanbul ignore else @preserve\n  if (self) self.toggle();\n\n  // event target is anchor link #398\n  if (trigger && trigger.tagName === \"A\") e.preventDefault();\n};\n\n// COLLAPSE DEFINITION\n// ===================\n\n/** Returns a new `Colapse` instance. */\nexport default class Collapse extends BaseComponent {\n  static selector = collapseSelector;\n  static init = collapseInitCallback;\n  static getInstance = getCollapseInstance;\n  declare options: CollapseOptions;\n  declare parent: HTMLElement | null;\n  declare triggers: HTMLElement[];\n\n  /**\n   * @param target and `Element` that matches the selector\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<CollapseOptions>) {\n    super(target, config);\n\n    // initialization element\n    const { element, options } = this;\n    const doc = getDocument(element);\n\n    // set triggering elements\n    this.triggers = [...querySelectorAll(collapseToggleSelector, doc)].filter(\n      (btn) => getTargetElement(btn) === element,\n    );\n\n    // set parent accordion\n    this.parent = isHTMLElement(options.parent)\n      ? options.parent\n      : isString(options.parent)\n      ? getTargetElement(element) || querySelector(options.parent, doc)\n      : null;\n\n    // add event listeners\n    this._toggleEventListeners(true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return collapseComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return collapseDefaults;\n  }\n\n  // COLLAPSE PUBLIC METHODS\n  // =======================\n  /** Hides the collapse. */\n  hide() {\n    const { triggers, element } = this;\n    // istanbul ignore else @preserve\n    if (!Timer.get(element)) {\n      collapseContent(this);\n      // istanbul ignore else @preserve\n      if (triggers.length) {\n        triggers.forEach((btn) => addClass(btn, `${collapseString}d`));\n      }\n    }\n  }\n\n  /** Shows the collapse. */\n  show() {\n    const { element, parent, triggers } = this;\n    let activeCollapse;\n    let activeCollapseInstance;\n\n    if (parent) {\n      activeCollapse = [\n        ...querySelectorAll(`.${collapseString}.${showClass}`, parent),\n      ].find((i) => getCollapseInstance(i));\n      activeCollapseInstance = activeCollapse &&\n        getCollapseInstance(activeCollapse);\n    }\n\n    if ((!parent || !Timer.get(parent)) && !Timer.get(element)) {\n      if (activeCollapseInstance && activeCollapse !== element) {\n        collapseContent(activeCollapseInstance);\n        activeCollapseInstance.triggers.forEach((btn) => {\n          addClass(btn, `${collapseString}d`);\n        });\n      }\n\n      expandCollapse(this);\n      // istanbul ignore else @preserve\n      if (triggers.length) {\n        triggers.forEach((btn) => removeClass(btn, `${collapseString}d`));\n      }\n    }\n  }\n\n  /** Toggles the visibility of the collapse. */\n  toggle() {\n    if (!hasClass(this.element, showClass)) this.show();\n    else this.hide();\n  }\n\n  /**\n   * Toggles on/off the event listener(s) of the `Collapse` instance.\n   *\n   * @param add when `true`, the event listener is added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    const { triggers } = this;\n\n    // istanbul ignore else @preserve\n    if (triggers.length) {\n      triggers.forEach((btn) =>\n        action(btn, mouseclickEvent, collapseClickHandler)\n      );\n    }\n  };\n\n  /** Remove the `Collapse` component from the target `Element`. */\n  dispose() {\n    this._toggleEventListeners();\n\n    super.dispose();\n  }\n}\n","/**\n * Global namespace for `Dropdown` types / classes.\n */\nconst dropdownMenuClasses = [\"dropdown\", \"dropup\", \"dropstart\", \"dropend\"];\nexport default dropdownMenuClasses;\n","/** @type {string} */\nconst dropdownComponent = \"Dropdown\";\nexport default dropdownComponent;\n","/**\n * Global namespace for `.dropdown-menu`.\n */\nconst dropdownMenuClass = \"dropdown-menu\";\nexport default dropdownMenuClass;\n","import { closest, getAttribute, hasAttribute } from \"@thednp/shorty\";\n\n/**\n * Checks if an *event.target* or its parent has an `href=\"#\"` value.\n * We need to prevent jumping around onclick, don't we?\n *\n * @param element the target element\n * @returns the query result\n */\nconst isEmptyAnchor = (element: HTMLElement) => {\n  // `EventTarget` must be `HTMLElement`\n  const parentAnchor = closest(element, \"A\");\n  return (\n    (element.tagName === \"A\" &&\n      // anchor href starts with #\n      hasAttribute(element, \"href\") &&\n      (getAttribute(element, \"href\") as string).slice(-1) === \"#\") ||\n    // OR a child of an anchor with href starts with #\n    (parentAnchor &&\n      hasAttribute(parentAnchor, \"href\") &&\n      (getAttribute(parentAnchor, \"href\") as string).slice(-1) === \"#\")\n  );\n};\nexport default isEmptyAnchor;\n","/* Native JavaScript for Bootstrap 5 | Dropdown\n----------------------------------------------- */\nimport {\n  addClass,\n  ariaExpanded,\n  closest,\n  createCustomEvent,\n  CSS4Declaration,\n  dispatchEvent,\n  focus,\n  focusEvent,\n  getAttribute,\n  getBoundingClientRect,\n  getDocument,\n  getDocumentElement,\n  getElementsByClassName,\n  getElementStyle,\n  getInstance,\n  hasClass,\n  isHTMLElement,\n  isRTL,\n  keyArrowDown,\n  keyArrowUp,\n  keydownEvent,\n  keyEscape,\n  keyupEvent,\n  mouseclickEvent,\n  mousedownEvent,\n  ObjectAssign,\n  removeClass,\n  setAttribute,\n  setElementStyle,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport showClass from \"../strings/showClass\";\nimport dataBsToggle from \"../strings/dataBsToggle\";\nimport dropdownClasses from \"../strings/dropdownClasses\";\nimport dropdownComponent from \"../strings/dropdownComponent\";\nimport dropdownMenuClass from \"../strings/dropdownMenuClass\";\n\nimport isEmptyAnchor from \"../util/isEmptyAnchor\";\nimport BaseComponent from \"./base-component\";\nimport type { DropdownEvent, DropdownOptions } from \"../interface/dropdown\";\n\n// DROPDOWN PRIVATE GC\n// ===================\nconst [dropdownString, dropupString, dropstartString, dropendString] =\n  dropdownClasses;\nconst dropdownSelector = `[${dataBsToggle}=\"${dropdownString}\"]`;\n\n/**\n * Static method which returns an existing `Dropdown` instance associated\n * to a target `Element`.\n */\nconst getDropdownInstance = (element: HTMLElement) =>\n  getInstance<Dropdown>(element, dropdownComponent);\n\n/**\n * A `Dropdown` initialization callback.\n */\nconst dropdownInitCallback = (element: HTMLElement) => new Dropdown(element);\n\n// DROPDOWN PRIVATE GC\n// ===================\n// const dropdownMenuStartClass = `${dropdownMenuClass}-start`;\nconst dropdownMenuEndClass = `${dropdownMenuClass}-end`;\nconst verticalClass = [dropdownString, dropupString];\nconst horizontalClass = [dropstartString, dropendString];\nconst menuFocusTags = [\"A\", \"BUTTON\"];\n\nconst dropdownDefaults = {\n  offset: 5, // [number] 5(px)\n  display: \"dynamic\", // [dynamic|static]\n};\n\ntype DropdownEventProps = { relatedTarget: HTMLElement };\n\n// DROPDOWN CUSTOM EVENTS\n// ======================\nconst showDropdownEvent = createCustomEvent<DropdownEventProps, DropdownEvent>(\n  `show.bs.${dropdownString}`,\n);\nconst shownDropdownEvent = createCustomEvent<DropdownEventProps, DropdownEvent>(\n  `shown.bs.${dropdownString}`,\n);\nconst hideDropdownEvent = createCustomEvent<DropdownEventProps, DropdownEvent>(\n  `hide.bs.${dropdownString}`,\n);\nconst hiddenDropdownEvent = createCustomEvent<\n  DropdownEventProps,\n  DropdownEvent\n>(`hidden.bs.${dropdownString}`);\nconst updatedDropdownEvent = createCustomEvent<\n  DropdownEventProps,\n  DropdownEvent\n>(`updated.bs.${dropdownString}`);\n\n// DROPDOWN PRIVATE METHODS\n// ========================\n/**\n * Apply specific style or class names to a `.dropdown-menu` to automatically\n * accomodate the layout and the page scroll.\n *\n * @param self the `Dropdown` instance\n */\nconst styleDropdown = (self: Dropdown) => {\n  const { element, menu, parentElement, options } = self;\n  const { offset } = options;\n\n  // don't apply any style on mobile view\n  // istanbul ignore else @preserve: this test requires a navbar\n  if (getElementStyle(menu, \"position\") !== \"static\") {\n    const RTL = isRTL(element);\n    // const menuStart = hasClass(menu, dropdownMenuStartClass);\n    const menuEnd = hasClass(menu, dropdownMenuEndClass);\n\n    // reset menu offset and position\n    const resetProps = [\"margin\", \"top\", \"bottom\", \"left\", \"right\"];\n    resetProps.forEach((p) => {\n      // menu.style[p] = '';\n      const style: { [key: string]: string } = {};\n      style[p] = \"\";\n      setElementStyle(menu, style);\n    });\n\n    // set initial position class\n    // take into account .btn-group parent as .dropdown\n    // this requires navbar/btn-group/input-group\n    let positionClass = dropdownClasses.find((c) =>\n      hasClass(parentElement, c)\n    ) ||\n      // istanbul ignore next @preserve: fallback position\n      dropdownString;\n\n    const dropdownMargin: { [key: string]: number[] } = {\n      dropdown: [offset, 0, 0],\n      dropup: [0, 0, offset],\n      dropstart: RTL ? [-1, 0, 0, offset] : [-1, offset, 0],\n      dropend: RTL ? [-1, offset, 0] : [-1, 0, 0, offset],\n    };\n\n    const dropdownPosition: { [key: string]: Partial<CSS4Declaration> } = {\n      dropdown: { top: \"100%\" },\n      dropup: { top: \"auto\", bottom: \"100%\" },\n      dropstart: RTL\n        ? { left: \"100%\", right: \"auto\" }\n        : { left: \"auto\", right: \"100%\" },\n      dropend: RTL\n        ? { left: \"auto\", right: \"100%\" }\n        : { left: \"100%\", right: \"auto\" },\n      menuStart: RTL\n        ? { right: \"0\", left: \"auto\" }\n        : { right: \"auto\", left: \"0\" },\n      menuEnd: RTL\n        ? { right: \"auto\", left: \"0\" }\n        : { right: \"0\", left: \"auto\" },\n    };\n\n    const { offsetWidth: menuWidth, offsetHeight: menuHeight } = menu;\n\n    const { clientWidth, clientHeight } = getDocumentElement(element);\n    const {\n      left: targetLeft,\n      top: targetTop,\n      width: targetWidth,\n      height: targetHeight,\n    } = getBoundingClientRect(element);\n\n    // dropstart | dropend\n    const leftFullExceed = targetLeft - menuWidth - offset < 0;\n    // dropend\n    const rightFullExceed =\n      targetLeft + menuWidth + targetWidth + offset >= clientWidth;\n    // dropstart | dropend\n    const bottomExceed = targetTop + menuHeight + offset >= clientHeight;\n    // dropdown\n    const bottomFullExceed =\n      targetTop + menuHeight + targetHeight + offset >= clientHeight;\n    // dropup\n    const topExceed = targetTop - menuHeight - offset < 0;\n    // dropdown / dropup\n    const leftExceed = ((!RTL && menuEnd) || (RTL && !menuEnd)) &&\n      targetLeft + targetWidth - menuWidth < 0;\n    const rightExceed = ((RTL && menuEnd) || (!RTL && !menuEnd)) &&\n      targetLeft + menuWidth >= clientWidth;\n\n    // recompute position\n    // handle RTL as well\n    if (\n      horizontalClass.includes(positionClass) && leftFullExceed &&\n      rightFullExceed\n    ) {\n      positionClass = dropdownString;\n    }\n    if (\n      positionClass === dropstartString &&\n      (!RTL ? leftFullExceed : rightFullExceed)\n    ) {\n      positionClass = dropendString;\n    }\n    if (\n      positionClass === dropendString &&\n      (RTL ? leftFullExceed : rightFullExceed)\n    ) {\n      positionClass = dropstartString;\n    }\n    if (positionClass === dropupString && topExceed && !bottomFullExceed) {\n      positionClass = dropdownString;\n    }\n    if (positionClass === dropdownString && bottomFullExceed && !topExceed) {\n      positionClass = dropupString;\n    }\n\n    // override position for horizontal classes\n    if (horizontalClass.includes(positionClass) && bottomExceed) {\n      ObjectAssign(dropdownPosition[positionClass], {\n        top: \"auto\",\n        bottom: 0,\n      });\n    }\n\n    // override position for vertical classes\n    if (verticalClass.includes(positionClass) && (leftExceed || rightExceed)) {\n      // don't realign when menu is wider than window\n      // in both RTL and non-RTL readability is KING\n      let posAjust:\n        | { left: \"auto\" | number; right: \"auto\" | number }\n        | undefined = { left: \"auto\", right: \"auto\" };\n      // istanbul ignore else @preserve\n      if (!leftExceed && rightExceed && !RTL) {\n        posAjust = { left: \"auto\", right: 0 };\n      }\n      // istanbul ignore else @preserve\n      if (leftExceed && !rightExceed && RTL) {\n        posAjust = { left: 0, right: \"auto\" };\n      }\n      // istanbul ignore else @preserve\n      if (posAjust) {\n        ObjectAssign(dropdownPosition[positionClass], posAjust);\n      }\n    }\n\n    const margins: number[] = dropdownMargin[positionClass];\n    setElementStyle(menu, {\n      ...dropdownPosition[positionClass],\n      margin: `${margins.map((x) => (x ? `${x}px` : x)).join(\" \")}`,\n    });\n\n    // override dropdown-menu-start | dropdown-menu-end\n    if (verticalClass.includes(positionClass) && menuEnd) {\n      // istanbul ignore else @preserve\n      if (menuEnd) {\n        const endAdjust = (!RTL && leftExceed) || (RTL && rightExceed)\n          ? \"menuStart\"\n          // istanbul ignore next @preserve\n          : \"menuEnd\";\n        setElementStyle(menu, dropdownPosition[endAdjust]);\n      }\n    }\n    // trigger updated event\n    dispatchEvent(parentElement, updatedDropdownEvent);\n  }\n};\n\n/**\n * Returns an `Array` of focusable items in the given dropdown-menu.\n *\n * @param menu the target menu\n * @returns all children of the dropdown menu\n */\nconst getMenuItems = (menu: HTMLElement) => {\n  return [...menu.children]\n    .map((c) => {\n      if (c && menuFocusTags.includes(c.tagName)) return c;\n      const { firstElementChild } = c;\n      if (\n        firstElementChild && menuFocusTags.includes(firstElementChild.tagName)\n      ) {\n        return firstElementChild;\n      }\n      return null;\n    })\n    .filter((c) => c);\n};\n\n/**\n * Toggles on/off the listeners for the events that close the dropdown\n * as well as event that request a new position for the dropdown.\n *\n * @param {Dropdown} self the `Dropdown` instance\n */\nconst toggleDropdownDismiss = (self: Dropdown) => {\n  const { element, options, menu } = self;\n  const action = self.open ? addListener : removeListener;\n  const doc = getDocument(element);\n\n  action(doc, mouseclickEvent, dropdownDismissHandler);\n  action(doc, focusEvent, dropdownDismissHandler);\n  action(doc, keydownEvent, dropdownPreventScroll);\n  action(doc, keyupEvent, dropdownKeyHandler);\n\n  // istanbul ignore else @preserve\n  if (options.display === \"dynamic\") {\n    if (self.open) self._observer.observe(menu);\n    else self._observer.disconnect();\n  }\n};\n\n/**\n * Returns the currently open `.dropdown` element.\n *\n * @param element target\n * @returns the query result\n */\nconst getCurrentOpenDropdown = (\n  element: HTMLElement,\n): HTMLElement | undefined => {\n  const currentParent = [...dropdownClasses, \"btn-group\", \"input-group\"]\n    .map((c) =>\n      getElementsByClassName(`${c} ${showClass}`, getDocument(element))\n    )\n    .find((x) => x.length);\n\n  if (currentParent && currentParent.length) {\n    return [...(currentParent[0].children as HTMLCollectionOf<HTMLElement>)]\n      .find((x) =>\n        dropdownClasses.some((c) => c === getAttribute(x, dataBsToggle))\n      );\n  }\n  return undefined;\n};\n\n// DROPDOWN EVENT HANDLERS\n// =======================\n/**\n * Handles the `click` event for the `Dropdown` instance.\n *\n * @param e event object\n */\nconst dropdownDismissHandler = (e: MouseEvent) => {\n  const { target, type } = e;\n\n  // istanbul ignore else @preserve\n  if (target && isHTMLElement(target)) {\n    // some weird FF bug #409\n    const element = getCurrentOpenDropdown(target);\n    const self = element && getDropdownInstance(element);\n\n    // istanbul ignore else @preserve\n    if (self) {\n      const { parentElement, menu } = self;\n\n      const isForm = parentElement &&\n        parentElement.contains(target) &&\n        (target.tagName === \"form\" || closest(target, \"form\") !== null);\n\n      if (\n        [mouseclickEvent, mousedownEvent].includes(type) &&\n        isEmptyAnchor(target)\n      ) {\n        e.preventDefault();\n      }\n\n      // istanbul ignore else @preserve\n      if (\n        !isForm && type !== focusEvent && target !== element && target !== menu\n      ) {\n        self.hide();\n      }\n    }\n  }\n};\n\n/**\n * Handles `click` event listener for `Dropdown`.\n *\n * @param e event object\n */\nconst dropdownClickHandler = (e: MouseEvent) => {\n  const { target } = e;\n  const element = target && closest(target as HTMLElement, dropdownSelector);\n  const self = element && getDropdownInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    e.stopPropagation();\n    self.toggle();\n    // istanbul ignore else @preserve\n    if (element && isEmptyAnchor(element)) e.preventDefault();\n  }\n};\n\n/**\n * Prevents scroll when dropdown-menu is visible.\n *\n * @param e event object\n */\nconst dropdownPreventScroll = (e: KeyboardEvent) => {\n  // istanbul ignore else @preserve\n  if ([keyArrowDown, keyArrowUp].includes(e.code)) e.preventDefault();\n};\n\n/**\n * Handles keyboard `keydown` events for `Dropdown`.\n *\n * @param e keyboard key\n */\nfunction dropdownKeyHandler(this: HTMLElement, e: KeyboardEvent) {\n  const { code } = e;\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n  const { activeElement } = (element && getDocument(element)) as Document;\n\n  // istanbul ignore else @preserve\n  if (self && activeElement) {\n    const { menu, open } = self;\n    const menuItems = getMenuItems(menu);\n\n    // arrow up & down\n    if (\n      menuItems && menuItems.length && [keyArrowDown, keyArrowUp].includes(code)\n    ) {\n      let idx = menuItems.indexOf(activeElement);\n      // istanbul ignore else @preserve\n      if (activeElement === element) {\n        idx = 0;\n      } else if (code === keyArrowUp) {\n        idx = idx > 1 ? idx - 1 : 0;\n      } else if (code === keyArrowDown) {\n        idx = idx < menuItems.length - 1 ? idx + 1 : idx;\n      }\n      // istanbul ignore else @preserve\n      if (menuItems[idx]) focus(menuItems[idx] as HTMLElement);\n    }\n\n    if (keyEscape === code && open) {\n      self.toggle();\n      focus(element);\n    }\n  }\n}\n\n/** Handles dropdown layout changes during resize / scroll. */\nfunction dropdownIntersectionHandler(target: HTMLElement) {\n  const element = getCurrentOpenDropdown(target);\n  const self = element && getDropdownInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self && self.open) styleDropdown(self);\n}\n\n// DROPDOWN DEFINITION\n// ===================\n/** Returns a new Dropdown instance. */\nexport default class Dropdown extends BaseComponent {\n  static selector = dropdownSelector;\n  static init = dropdownInitCallback;\n  static getInstance = getDropdownInstance;\n  declare options: DropdownOptions;\n  declare open: boolean;\n  declare parentElement: HTMLElement;\n  declare menu: HTMLElement;\n  declare _observer: IntersectionObserver;\n\n  /**\n   * @param target Element or string selector\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<DropdownOptions>) {\n    super(target, config);\n\n    // initialization element\n    const { parentElement } = this.element;\n    const [menu] = getElementsByClassName(\n      dropdownMenuClass,\n      parentElement as ParentNode,\n    );\n\n    // invalidate when dropdown-menu is missing\n    if (menu) {\n      // set targets\n      this.parentElement = parentElement as HTMLElement;\n      this.menu = menu;\n      this._observer = new IntersectionObserver(\n        ([entry]) => dropdownIntersectionHandler(entry.target as HTMLElement),\n        { threshold: 1 },\n      );\n\n      // add event listener\n      this._toggleEventListeners(true);\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return dropdownComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return dropdownDefaults;\n  }\n\n  // DROPDOWN PUBLIC METHODS\n  // =======================\n  /** Shows/hides the dropdown menu to the user. */\n  toggle() {\n    if (this.open) this.hide();\n    else this.show();\n  }\n\n  /** Shows the dropdown menu to the user. */\n  show() {\n    const { element, open, menu, parentElement } = this;\n\n    // istanbul ignore else @preserve\n    if (!open) {\n      const currentElement = getCurrentOpenDropdown(element);\n      const currentInstance = currentElement &&\n        getDropdownInstance(currentElement);\n      if (currentInstance) currentInstance.hide();\n\n      // dispatch event\n      [showDropdownEvent, shownDropdownEvent, updatedDropdownEvent].forEach(\n        (e) => {\n          e.relatedTarget = element;\n        },\n      );\n\n      dispatchEvent(parentElement, showDropdownEvent);\n      if (!showDropdownEvent.defaultPrevented) {\n        addClass(menu, showClass);\n        addClass(parentElement, showClass);\n        setAttribute(element, ariaExpanded, \"true\");\n\n        // change menu position\n        styleDropdown(this);\n\n        this.open = !open;\n\n        focus(element); // focus the element\n        toggleDropdownDismiss(this);\n        dispatchEvent(parentElement, shownDropdownEvent);\n      }\n    }\n  }\n\n  /** Hides the dropdown menu from the user. */\n  hide() {\n    const { element, open, menu, parentElement } = this;\n\n    // istanbul ignore else @preserve\n    if (open) {\n      [hideDropdownEvent, hiddenDropdownEvent].forEach((e) => {\n        e.relatedTarget = element;\n      });\n\n      dispatchEvent(parentElement, hideDropdownEvent);\n      if (!hideDropdownEvent.defaultPrevented) {\n        removeClass(menu, showClass);\n        removeClass(parentElement, showClass);\n        setAttribute(element, ariaExpanded, \"false\");\n\n        this.open = !open;\n        // only re-attach handler if the instance is not disposed\n        toggleDropdownDismiss(this);\n        dispatchEvent(parentElement, hiddenDropdownEvent);\n      }\n    }\n  }\n\n  /**\n   * Toggles on/off the `click` event listener of the `Dropdown`.\n   *\n   * @param add when `true`, it will add the event listener\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    action(this.element, mouseclickEvent, dropdownClickHandler);\n  };\n\n  /** Removes the `Dropdown` component from the target element. */\n  dispose() {\n    if (this.open) this.hide();\n\n    this._toggleEventListeners();\n    super.dispose();\n  }\n}\n","/** @type {string} */\nconst modalString = \"modal\";\nexport default modalString;\n","/** @type {string} */\nconst modalComponent = \"Modal\";\nexport default modalComponent;\n","/** @type {string} */\nconst offcanvasComponent = \"Offcanvas\";\nexport default offcanvasComponent;\n","/**\n * Global namespace for components `fixed-top` class.\n */\nconst fixedTopClass = \"fixed-top\";\nexport default fixedTopClass;\n","/**\n * Global namespace for components `fixed-bottom` class.\n */\nconst fixedBottomClass = \"fixed-bottom\";\nexport default fixedBottomClass;\n","/**\n * Global namespace for components `sticky-top` class.\n */\nconst stickyTopClass = \"sticky-top\";\nexport default stickyTopClass;\n","/**\n * Global namespace for components `position-sticky` class.\n */\nconst positionStickyClass = \"position-sticky\";\nexport default positionStickyClass;\n","import {\n  getDocumentBody,\n  getDocumentElement,\n  getElementsByClassName,\n  getElementStyle,\n  getWindow,\n  hasClass,\n  setElementStyle,\n} from \"@thednp/shorty\";\n\nimport fixedTopClass from \"../strings/fixedTopClass\";\nimport fixedBottomClass from \"../strings/fixedBottomClass\";\nimport stickyTopClass from \"../strings/stickyTopClass\";\nimport positionStickyClass from \"../strings/positionStickyClass\";\n\nconst getFixedItems = (parent?: ParentNode) => [\n  ...getElementsByClassName(fixedTopClass, parent),\n  ...getElementsByClassName(fixedBottomClass, parent),\n  ...getElementsByClassName(stickyTopClass, parent),\n  ...getElementsByClassName(positionStickyClass, parent),\n  ...getElementsByClassName(\"is-fixed\", parent),\n];\n\n/**\n * Removes *padding* and *overflow* from the `<body>`\n * and all spacing from fixed items.\n *\n * @param element the target modal/offcanvas\n */\nexport const resetScrollbar = (element?: HTMLElement) => {\n  const bd = getDocumentBody(element);\n  setElementStyle(bd, {\n    paddingRight: \"\",\n    overflow: \"\",\n  });\n\n  const fixedItems = getFixedItems(bd);\n\n  // istanbul ignore else @preserve\n  if (fixedItems.length) {\n    fixedItems.forEach((fixed) => {\n      setElementStyle(fixed, {\n        paddingRight: \"\",\n        marginRight: \"\",\n      });\n    });\n  }\n};\n\n/**\n * Returns the scrollbar width if the body does overflow\n * the window.\n *\n * @param element target element\n * @returns the scrollbar width value\n */\nexport const measureScrollbar = (element: HTMLElement) => {\n  const { clientWidth } = getDocumentElement(element);\n  const { innerWidth } = getWindow(element);\n  return Math.abs(innerWidth - clientWidth);\n};\n\n/**\n * Sets the `<body>` and fixed items style when modal / offcanvas\n * is shown to the user.\n *\n * @param element the target modal/offcanvas\n * @param overflow body does overflow or not\n */\nexport const setScrollbar = (element: HTMLElement, overflow?: boolean) => {\n  const bd = getDocumentBody(element);\n  const bodyPad = parseInt(getElementStyle(bd, \"paddingRight\"), 10);\n  const isOpen = getElementStyle(bd, \"overflow\") === \"hidden\";\n  const sbWidth = isOpen && bodyPad ? 0 : measureScrollbar(element);\n  const fixedItems = getFixedItems(bd);\n\n  // istanbul ignore else @preserve\n  if (overflow) {\n    setElementStyle(bd, {\n      overflow: \"hidden\",\n      paddingRight: `${bodyPad + sbWidth}px`,\n    });\n\n    // istanbul ignore else @preserve\n    if (fixedItems.length) {\n      fixedItems.forEach((fixed) => {\n        const itemPadValue = getElementStyle(fixed, \"paddingRight\");\n        fixed.style.paddingRight = `${parseInt(itemPadValue, 10) + sbWidth}px`;\n        // istanbul ignore else @preserve\n        if (\n          [stickyTopClass, positionStickyClass].some((c) => hasClass(fixed, c))\n        ) {\n          const itemMValue = getElementStyle(fixed, \"marginRight\");\n          fixed.style.marginRight = `${parseInt(itemMValue, 10) - sbWidth}px`;\n        }\n      });\n    }\n  }\n};\n","/** @type {string} */\nconst offcanvasString = \"offcanvas\";\nexport default offcanvasString;\n","import { createElement, getDocumentBody, isNode } from \"@thednp/shorty\";\n\n// the default container for Modal, Offcanvas, Popover and Tooltip\nconst popupContainer = createElement({\n  tagName: \"div\",\n  className: \"popup-container\",\n}) as HTMLElement;\n\nconst appendPopup = (target: HTMLElement, customContainer?: ParentNode) => {\n  const containerIsBody = isNode(customContainer) &&\n    customContainer.nodeName === \"BODY\";\n  const lookup = isNode(customContainer) && !containerIsBody\n    ? customContainer\n    : popupContainer;\n  const BODY = containerIsBody ? customContainer : getDocumentBody(target);\n\n  // istanbul ignore else @preserve\n  if (isNode(target)) {\n    if (lookup === popupContainer) {\n      BODY.append(popupContainer);\n    }\n    lookup.append(target);\n  }\n};\n\nconst removePopup = (target: HTMLElement, customContainer?: ParentNode) => {\n  const containerIsBody = isNode(customContainer) &&\n    customContainer.nodeName === \"BODY\";\n  const lookup = isNode(customContainer) && !containerIsBody\n    ? customContainer\n    : popupContainer;\n\n  // istanbul ignore else @preserve\n  if (isNode(target)) {\n    target.remove();\n\n    if (lookup === popupContainer && !popupContainer.children.length) {\n      popupContainer.remove();\n    }\n  }\n};\n\nconst hasPopup = (target: HTMLElement, customContainer?: ParentNode) => {\n  const lookup = isNode(customContainer) && customContainer.nodeName !== \"BODY\"\n    ? customContainer\n    : popupContainer;\n  return isNode(target) && lookup.contains(target);\n};\n\nexport { appendPopup, hasPopup, popupContainer, removePopup };\n","import {\n  addClass,\n  createElement,\n  getDocument,\n  getDocumentBody,\n  hasClass,\n  querySelector,\n  reflow,\n  removeClass,\n} from \"@thednp/shorty\";\n\nimport fadeClass from \"../strings/fadeClass\";\nimport showClass from \"../strings/showClass\";\nimport modalString from \"../strings/modalString\";\nimport offcanvasString from \"../strings/offcanvasString\";\nimport { resetScrollbar } from \"./scrollbar\";\nimport { appendPopup, removePopup } from \"./popupContainer\";\n\nconst backdropString = \"backdrop\";\nconst modalBackdropClass = `${modalString}-${backdropString}`;\nconst offcanvasBackdropClass = `${offcanvasString}-${backdropString}`;\nconst modalActiveSelector = `.${modalString}.${showClass}`;\nconst offcanvasActiveSelector = `.${offcanvasString}.${showClass}`;\n\n// any document would suffice\nconst overlay = createElement(\"div\") as HTMLElement;\n\n/**\n * Returns the current active modal / offcancas element.\n *\n * @param element the context element\n * @returns the requested element\n */\nconst getCurrentOpen = (element?: HTMLElement): HTMLElement | null => {\n  return querySelector(\n    `${modalActiveSelector},${offcanvasActiveSelector}`,\n    getDocument(element),\n  );\n};\n\n/**\n * Toogles from a Modal overlay to an Offcanvas, or vice-versa.\n *\n * @param isModal\n */\nconst toggleOverlayType = (isModal?: boolean) => {\n  const targetClass = isModal ? modalBackdropClass : offcanvasBackdropClass;\n  [modalBackdropClass, offcanvasBackdropClass].forEach((c) => {\n    removeClass(overlay, c);\n  });\n  addClass(overlay, targetClass);\n};\n\n/**\n * Append the overlay to DOM.\n *\n * @param element\n * @param hasFade\n * @param isModal\n */\nconst appendOverlay = (\n  element: HTMLElement,\n  hasFade: boolean,\n  isModal?: boolean,\n) => {\n  toggleOverlayType(isModal);\n  appendPopup(overlay, getDocumentBody(element));\n  if (hasFade) addClass(overlay, fadeClass);\n};\n\n/**\n * Shows the overlay to the user.\n */\nconst showOverlay = () => {\n  if (!hasClass(overlay, showClass)) {\n    addClass(overlay, showClass);\n    reflow(overlay);\n  }\n};\n\n/**\n * Hides the overlay from the user.\n */\nconst hideOverlay = () => {\n  removeClass(overlay, showClass);\n};\n\n/**\n * Removes the overlay from DOM.\n *\n * @param element\n */\nconst removeOverlay = (element?: HTMLElement): void => {\n  if (!getCurrentOpen(element)) {\n    removeClass(overlay, fadeClass);\n    removePopup(overlay, getDocumentBody(element));\n    resetScrollbar(element);\n  }\n};\n\nexport {\n  appendOverlay,\n  getCurrentOpen,\n  hideOverlay,\n  modalActiveSelector,\n  modalBackdropClass,\n  offcanvasActiveSelector,\n  offcanvasBackdropClass,\n  overlay,\n  removeOverlay,\n  showOverlay,\n  toggleOverlayType,\n};\n","import { getElementStyle, isHTMLElement } from \"@thednp/shorty\";\n\n/**\n * @param element target\n * @returns the check result\n */\nconst isVisible = (element: HTMLElement) => {\n  return isHTMLElement(element) &&\n    getElementStyle(element, \"visibility\") !== \"hidden\" &&\n    element.offsetParent !== null;\n};\nexport default isVisible;\n","/* Native JavaScript for Bootstrap 5 | Modal\n-------------------------------------------- */\nimport {\n  addClass,\n  ariaHidden,\n  ariaModal,\n  closest,\n  createCustomEvent,\n  CSS4Declaration,\n  dispatchEvent,\n  emulateTransitionEnd,\n  focus,\n  getDocument,\n  getDocumentBody,\n  getDocumentElement,\n  getElementTransitionDuration,\n  getInstance,\n  hasClass,\n  isRTL,\n  KeyboardEvent,\n  keydownEvent,\n  keyEscape,\n  mouseclickEvent,\n  MouseEvent,\n  querySelector,\n  querySelectorAll,\n  removeAttribute,\n  removeClass,\n  setAttribute,\n  setElementStyle,\n  Timer,\n  toggleFocusTrap,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport dataBsToggle from \"../strings/dataBsToggle\";\nimport dataBsDismiss from \"../strings/dataBsDismiss\";\nimport fadeClass from \"../strings/fadeClass\";\nimport showClass from \"../strings/showClass\";\nimport modalString from \"../strings/modalString\";\nimport modalComponent from \"../strings/modalComponent\";\nimport offcanvasComponent from \"../strings/offcanvasComponent\";\nimport getTargetElement from \"../util/getTargetElement\";\nimport { measureScrollbar, setScrollbar } from \"../util/scrollbar\";\nimport {\n  appendOverlay,\n  getCurrentOpen,\n  hideOverlay,\n  modalActiveSelector,\n  overlay,\n  removeOverlay,\n  showOverlay,\n  toggleOverlayType,\n} from \"../util/backdrop\";\nimport isVisible from \"../util/isVisible\";\nimport BaseComponent from \"./base-component\";\nimport { ModalEvent, ModalOptions } from \"../interface/modal\";\nimport { hasPopup } from \"../util/popupContainer\";\n\n// MODAL PRIVATE GC\n// ================\nconst modalSelector = `.${modalString}`;\nconst modalToggleSelector = `[${dataBsToggle}=\"${modalString}\"]`;\nconst modalDismissSelector = `[${dataBsDismiss}=\"${modalString}\"]`;\nconst modalStaticClass = `${modalString}-static`;\n\nconst modalDefaults = {\n  backdrop: true,\n  keyboard: true,\n};\n\ntype ModalEventProps = {\n  relatedTarget: HTMLElement | undefined;\n};\n\n/**\n * Static method which returns an existing `Modal` instance associated\n * to a target `Element`.\n */\nconst getModalInstance = (element: HTMLElement) =>\n  getInstance<Modal>(element, modalComponent);\n\n/**\n * A `Modal` initialization callback.\n */\nconst modalInitCallback = (element: HTMLElement) => new Modal(element);\n\n// MODAL CUSTOM EVENTS\n// ===================\nconst showModalEvent = createCustomEvent<ModalEventProps, ModalEvent>(\n  `show.bs.${modalString}`,\n);\nconst shownModalEvent = createCustomEvent<ModalEventProps, ModalEvent>(\n  `shown.bs.${modalString}`,\n);\nconst hideModalEvent = createCustomEvent<ModalEventProps, ModalEvent>(\n  `hide.bs.${modalString}`,\n);\nconst hiddenModalEvent = createCustomEvent<ModalEventProps, ModalEvent>(\n  `hidden.bs.${modalString}`,\n);\n\n// MODAL PRIVATE METHODS\n// =====================\n/**\n * Applies special style for the `<body>` and fixed elements\n * when a modal instance is shown to the user.\n *\n * @param self the `Modal` instance\n */\nconst setModalScrollbar = (self: Modal) => {\n  const { element } = self;\n  const scrollbarWidth = measureScrollbar(element);\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  const { clientHeight: modalHeight, scrollHeight: modalScrollHeight } =\n    element;\n  const modalOverflow = modalHeight !== modalScrollHeight;\n\n  // istanbul ignore next @preserve: impossible to test?\n  if (!modalOverflow && scrollbarWidth) {\n    const pad = !isRTL(element)\n      ? \"paddingRight\"\n      // istanbul ignore next @preserve\n      : \"paddingLeft\";\n    const padStyle = { [pad]: `${scrollbarWidth}px` } as Partial<\n      CSS4Declaration\n    >;\n    setElementStyle(element, padStyle);\n  }\n  setScrollbar(element, modalOverflow || clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the listeners of events that close the modal.\n *\n * @param self the `Modal` instance\n * @param add when `true`, event listeners are added\n */\nconst toggleModalDismiss = (self: Modal, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n  action(element, mouseclickEvent, modalDismissHandler);\n  action(getDocument(element), keydownEvent, modalKeyHandler);\n\n  if (add) self._observer.observe(element);\n  else self._observer.disconnect();\n};\n\n/**\n * Executes after a modal is hidden to the user.\n *\n * @param self the `Modal` instance\n */\nconst afterModalHide = (self: Modal) => {\n  const { triggers, element, relatedTarget } = self;\n  removeOverlay(element);\n  setElementStyle(element, { paddingRight: \"\", display: \"\" });\n  toggleModalDismiss(self);\n\n  const focusElement = showModalEvent.relatedTarget || triggers.find(isVisible);\n  // istanbul ignore else @preserve\n  if (focusElement) focus(focusElement as HTMLElement);\n\n  hiddenModalEvent.relatedTarget = relatedTarget as HTMLElement | undefined;\n  dispatchEvent(element, hiddenModalEvent);\n  toggleFocusTrap(element);\n};\n\n/**\n * Executes after a modal is shown to the user.\n *\n * @param self the `Modal` instance\n */\nconst afterModalShow = (self: Modal) => {\n  const { element, relatedTarget } = self;\n  focus(element);\n  toggleModalDismiss(self, true);\n\n  shownModalEvent.relatedTarget = relatedTarget as HTMLElement | undefined;\n  dispatchEvent(element, shownModalEvent);\n  toggleFocusTrap(element);\n};\n\n/**\n * Executes before a modal is shown to the user.\n *\n * @param self the `Modal` instance\n */\nconst beforeModalShow = (self: Modal) => {\n  const { element, hasFade } = self;\n  setElementStyle(element, { display: \"block\" });\n  setModalScrollbar(self);\n  // istanbul ignore else @preserve\n  if (!getCurrentOpen(element)) {\n    setElementStyle(getDocumentBody(element), { overflow: \"hidden\" });\n  }\n\n  addClass(element, showClass);\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, \"true\");\n\n  if (hasFade) emulateTransitionEnd(element, () => afterModalShow(self));\n  else afterModalShow(self);\n};\n\n/**\n * Executes before a modal is hidden to the user.\n *\n * @param self the `Modal` instance\n */\nconst beforeModalHide = (self: Modal) => {\n  const { element, options, hasFade } = self;\n\n  // callback can also be the transitionEvent object, we wanna make sure it's not\n  // call is not forced and overlay is visible\n  if (\n    options.backdrop && hasFade && hasClass(overlay, showClass) &&\n    !getCurrentOpen(element)\n  ) {\n    // AND no modal is visible\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => afterModalHide(self));\n  } else {\n    afterModalHide(self);\n  }\n};\n\n// MODAL EVENT HANDLERS\n// ====================\n/**\n * Handles the `click` event listener for modal.\n *\n * @param e the `Event` object\n */\nconst modalClickHandler = (e: MouseEvent<HTMLElement>) => {\n  const { target } = e;\n\n  const trigger = target && closest(target, modalToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getModalInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    // istanbul ignore else @preserve\n    if (trigger && trigger.tagName === \"A\") e.preventDefault();\n    self.relatedTarget = trigger;\n    self.toggle();\n  }\n};\n\n/**\n * Handles the `keydown` event listener for modal\n * to hide the modal when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst modalKeyHandler = ({ code, target }: KeyboardEvent<HTMLElement>) => {\n  const element = querySelector(modalActiveSelector, getDocument(target));\n  const self = element && getModalInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    const { options } = self;\n    // istanbul ignore else @preserve\n    if (\n      options.keyboard &&\n      code === keyEscape && // the keyboard option is enabled and the key is 27\n      hasClass(element, showClass)\n    ) {\n      // the modal is not visible\n      self.relatedTarget = null;\n      self.hide();\n    }\n  }\n};\n\n/**\n * Handles the `click` event listeners that hide the modal.\n *\n * @param e the `Event` object\n */\nconst modalDismissHandler = (e: MouseEvent<HTMLElement>) => {\n  const { currentTarget } = e;\n  const self = currentTarget && getModalInstance(currentTarget);\n\n  // this timer is needed\n  // istanbul ignore else @preserve\n  if (self && currentTarget && !Timer.get(currentTarget)) {\n    const { options, isStatic, modalDialog } = self;\n    const { backdrop } = options;\n    const { target } = e;\n\n    const selectedText = getDocument(currentTarget)?.getSelection()?.toString()\n      .length;\n    const targetInsideDialog = modalDialog.contains(target);\n    const dismiss = target && closest(target, modalDismissSelector);\n\n    // istanbul ignore else @preserve\n    if (isStatic && !targetInsideDialog) {\n      Timer.set(\n        currentTarget,\n        () => {\n          addClass(currentTarget, modalStaticClass);\n          emulateTransitionEnd(modalDialog, () => staticTransitionEnd(self));\n        },\n        17,\n      );\n    } else if (\n      dismiss || (!selectedText && !isStatic && !targetInsideDialog && backdrop)\n    ) {\n      self.relatedTarget = dismiss || null;\n      self.hide();\n      e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the `transitionend` event listeners for `Modal`.\n *\n * @param self the `Modal` instance\n */\nconst staticTransitionEnd = (self: Modal) => {\n  const { element, modalDialog } = self;\n  const duration = (getElementTransitionDuration(modalDialog) || 0) + 17;\n  removeClass(element, modalStaticClass);\n  // user must wait for zoom out transition\n  Timer.set(element, () => Timer.clear(element), duration);\n};\n\n// MODAL DEFINITION\n// ================\n/** Returns a new `Modal` instance. */\nexport default class Modal extends BaseComponent {\n  static selector = modalSelector;\n  static init = modalInitCallback;\n  static getInstance = getModalInstance;\n  declare options: ModalOptions;\n  declare modalDialog: HTMLElement;\n  declare triggers: HTMLElement[];\n  declare isStatic: boolean;\n  declare hasFade: boolean;\n  declare relatedTarget: HTMLElement | null;\n  declare _observer: ResizeObserver;\n\n  /**\n   * @param target usually the `.modal` element\n   * @param config instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<ModalOptions>) {\n    super(target, config);\n\n    // the modal\n    const { element } = this;\n\n    // the modal-dialog\n    const modalDialog = querySelector(`.${modalString}-dialog`, element);\n\n    // istanbul ignore else @preserve\n    if (modalDialog) {\n      this.modalDialog = modalDialog;\n      // modal can have multiple triggering elements\n      this.triggers = [\n        ...querySelectorAll(modalToggleSelector, getDocument(element)),\n      ].filter(\n        (btn) => getTargetElement(btn) === element,\n      );\n\n      // additional internals\n      this.isStatic = this.options.backdrop === \"static\";\n      this.hasFade = hasClass(element, fadeClass);\n      this.relatedTarget = null;\n      this._observer = new ResizeObserver(() => this.update());\n\n      // attach event listeners\n      this._toggleEventListeners(true);\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return modalComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return modalDefaults;\n  }\n\n  // MODAL PUBLIC METHODS\n  // ====================\n  /** Toggles the visibility of the modal. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the modal to the user. */\n  show() {\n    const { element, options, hasFade, relatedTarget } = this;\n    const { backdrop } = options;\n    let overlayDelay = 0;\n\n    // istanbul ignore else @preserve\n    if (!hasClass(element, showClass)) {\n      showModalEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, showModalEvent);\n      if (!showModalEvent.defaultPrevented) {\n        // we elegantly hide any opened modal/offcanvas\n        const currentOpen = getCurrentOpen(element);\n\n        // istanbul ignore else @preserve\n        if (currentOpen && currentOpen !== element) {\n          const that = getModalInstance(currentOpen) ||\n            // istanbul ignore next @preserve\n            getInstance<typeof BaseComponent & { hide: () => void }>(\n              currentOpen,\n              offcanvasComponent,\n            );\n          // istanbul ignore else @preserve\n          if (that) that.hide();\n        }\n        if (backdrop) {\n          if (!hasPopup(overlay)) {\n            appendOverlay(element, hasFade, true);\n          } else {\n            toggleOverlayType(true);\n          }\n\n          overlayDelay = getElementTransitionDuration(overlay);\n          showOverlay();\n\n          setTimeout(() => beforeModalShow(this), overlayDelay);\n        } else {\n          beforeModalShow(this);\n          // istanbul ignore else @preserve\n          if (currentOpen && hasClass(overlay, showClass)) {\n            hideOverlay();\n          }\n        }\n      }\n    }\n  }\n\n  /** Hide the modal from the user. */\n  hide() {\n    const { element, hasFade, relatedTarget } = this;\n\n    // istanbul ignore else @preserve\n    if (hasClass(element, showClass)) {\n      hideModalEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, hideModalEvent);\n\n      // istanbul ignore else @preserve\n      if (!hideModalEvent.defaultPrevented) {\n        removeClass(element, showClass);\n        setAttribute(element, ariaHidden, \"true\");\n        removeAttribute(element, ariaModal);\n\n        if (hasFade) {\n          emulateTransitionEnd(element, () => beforeModalHide(this));\n        } else {\n          beforeModalHide(this);\n        }\n      }\n    }\n  }\n\n  /**\n   * Updates the modal layout.\n   */\n  update = () => {\n    // istanbul ignore else @preserve\n    if (hasClass(this.element, showClass)) setModalScrollbar(this);\n  };\n\n  /**\n   * Toggles on/off the `click` event listener of the `Modal` instance.\n   *\n   * @param add when `true`, event listener(s) is/are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    const { triggers } = this;\n\n    // istanbul ignore else @preserve\n    if (triggers.length) {\n      triggers.forEach((btn) =>\n        action(btn, mouseclickEvent, modalClickHandler)\n      );\n    }\n  };\n\n  /** Removes the `Modal` component from target element. */\n  dispose() {\n    const clone = { ...this };\n    const { modalDialog, hasFade } = clone;\n    const callback = () => setTimeout(() => super.dispose(), 17);\n\n    this.hide();\n    this._toggleEventListeners();\n\n    if (hasFade) {\n      // use transitionend callback\n      emulateTransitionEnd(modalDialog, callback);\n    } else {\n      callback();\n    }\n  }\n}\n","/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\nimport {\n  addClass,\n  ariaHidden,\n  ariaModal,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  emulateTransitionEnd,\n  focus,\n  getDocument,\n  getDocumentBody,\n  getDocumentElement,\n  getElementTransitionDuration,\n  getInstance,\n  hasClass,\n  keydownEvent,\n  keyEscape,\n  mouseclickEvent,\n  querySelector,\n  querySelectorAll,\n  removeAttribute,\n  removeClass,\n  setAttribute,\n  setElementStyle,\n  toggleFocusTrap,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport dataBsDismiss from \"../strings/dataBsDismiss\";\nimport dataBsToggle from \"../strings/dataBsToggle\";\nimport showClass from \"../strings/showClass\";\nimport offcanvasString from \"../strings/offcanvasString\";\nimport offcanvasComponent from \"../strings/offcanvasComponent\";\nimport modalComponent from \"../strings/modalComponent\";\n\nimport getTargetElement from \"../util/getTargetElement\";\nimport isVisible from \"../util/isVisible\";\nimport { setScrollbar } from \"../util/scrollbar\";\nimport { hasPopup } from \"../util/popupContainer\";\nimport {\n  appendOverlay,\n  getCurrentOpen,\n  hideOverlay,\n  offcanvasActiveSelector,\n  overlay,\n  removeOverlay,\n  showOverlay,\n  toggleOverlayType,\n} from \"../util/backdrop\";\nimport BaseComponent from \"./base-component\";\nimport { OffcanvasEvent, OffcanvasOptions } from \"../interface/offcanvas\";\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\ntype OffCanvasEventProps = {\n  relatedTarget: HTMLElement | undefined;\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n */\nconst getOffcanvasInstance = (element: HTMLElement) =>\n  getInstance<Offcanvas>(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n */\nconst offcanvasInitCallback = (element: HTMLElement) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = createCustomEvent<\n  OffCanvasEventProps,\n  OffcanvasEvent\n>(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param self the `Offcanvas` instance\n */\nconst setOffCanvasScrollbar = (self: Offcanvas) => {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n};\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param self the `Offcanvas` instance\n * @param add when *true* listeners are added\n */\nconst toggleOffCanvasDismiss = (self: Offcanvas, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n};\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasShow = (self: Offcanvas) => {\n  const { element, options } = self;\n\n  // istanbul ignore else @preserve\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: \"hidden\" });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: \"visible\" });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n};\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst beforeOffcanvasHide = (self: Offcanvas) => {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  element.blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n  }\n  emulateTransitionEnd(element, () => hideOffcanvasComplete(self));\n};\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @param e the `Event` object\n */\nconst offcanvasTriggerHandler = (e: MouseEvent) => {\n  const trigger = closest(e.target as HTMLElement, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    self.relatedTarget = trigger;\n    self.toggle();\n    // istanbul ignore else @preserve\n    if (trigger && trigger.tagName === \"A\") {\n      e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param e the `Event` object\n */\nconst offcanvasDismissHandler = (e: MouseEvent) => {\n  const { target } = e;\n  const element = querySelector(\n    offcanvasActiveSelector,\n    getDocument(target as Node),\n  );\n  const offCanvasDismiss = querySelector(\n    offcanvasDismissSelector,\n    element as HTMLElement | undefined,\n  );\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    const { options, triggers } = self;\n    const { backdrop } = options;\n    const trigger = closest(target as HTMLElement, offcanvasToggleSelector);\n    const selection = getDocument(element).getSelection();\n\n    // istanbul ignore else: a filter is required here @preserve\n    if (!overlay.contains(target as HTMLElement) || backdrop !== \"static\") {\n      // istanbul ignore else @preserve\n      if (\n        !(selection && selection.toString().length) &&\n        ((!element.contains(target as HTMLElement) &&\n          backdrop &&\n          // istanbul ignore next @preserve\n          (!trigger || triggers.includes(target as HTMLElement))) ||\n          (offCanvasDismiss &&\n            offCanvasDismiss.contains(target as HTMLElement)))\n      ) {\n        self.relatedTarget =\n          offCanvasDismiss && offCanvasDismiss.contains(target as HTMLElement)\n            ? offCanvasDismiss\n            : null;\n        self.hide();\n      }\n\n      // istanbul ignore next @preserve\n      if (trigger && trigger.tagName === \"A\") e.preventDefault();\n    }\n  }\n};\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param e the `Event` object\n */\nconst offcanvasKeyDismissHandler = ({ code, target }: KeyboardEvent) => {\n  const element = querySelector(\n    offcanvasActiveSelector,\n    getDocument(target as Node),\n  );\n  const self = element && getOffcanvasInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    // istanbul ignore else @preserve\n    if (self.options.keyboard && code === keyEscape) {\n      self.relatedTarget = null;\n      self.hide();\n    }\n  }\n};\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst showOffcanvasComplete = (self: Offcanvas) => {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, \"true\");\n  setAttribute(element, \"role\", \"dialog\");\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n  toggleFocusTrap(element);\n};\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param self the `Offcanvas` instance\n */\nconst hideOffcanvasComplete = (self: Offcanvas) => {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, \"true\");\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, \"role\");\n  setElementStyle(element, { visibility: \"\" });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget ||\n    triggers.find(isVisible);\n  // istanbul ignore else @preserve\n  if (visibleTrigger) focus(visibleTrigger as HTMLElement);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n  toggleFocusTrap(element);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n};\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nexport default class Offcanvas extends BaseComponent {\n  static selector = offcanvasSelector;\n  static init = offcanvasInitCallback;\n  static getInstance = getOffcanvasInstance;\n  declare options: OffcanvasOptions;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: HTMLElement | null;\n\n  /**\n   * @param target usually an `.offcanvas` element\n   * @param config instance options\n   */\n  constructor(\n    target: HTMLElement | string,\n    config?: Partial<OffcanvasOptions>,\n  ) {\n    super(target, config);\n\n    // instance element\n    const { element } = this;\n\n    // all the triggering buttons\n    this.triggers = [\n      ...querySelectorAll(offcanvasToggleSelector, getDocument(element)),\n    ].filter(\n      (btn) => getTargetElement(btn) === element,\n    );\n\n    // additional instance property\n    this.relatedTarget = null;\n\n    // attach event listeners\n    this._toggleEventListeners(true);\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return offcanvasComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return offcanvasDefaults;\n  }\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    if (hasClass(this.element, showClass)) this.hide();\n    else this.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const { element, options, relatedTarget } = this;\n    let overlayDelay = 0;\n\n    if (!hasClass(element, showClass)) {\n      showOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      shownOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, showOffcanvasEvent);\n\n      if (!showOffcanvasEvent.defaultPrevented) {\n        // we elegantly hide any opened modal/offcanvas\n        const currentOpen = getCurrentOpen(element);\n        if (currentOpen && currentOpen !== element) {\n          const that = getOffcanvasInstance(currentOpen) ||\n            // istanbul ignore next @preserve\n            getInstance<typeof BaseComponent & { hide: () => void }>(\n              currentOpen,\n              modalComponent,\n            );\n\n          // istanbul ignore else @preserve\n          if (that) that.hide();\n        }\n\n        if (options.backdrop) {\n          if (!hasPopup(overlay)) {\n            appendOverlay(element, true);\n          } else {\n            toggleOverlayType();\n          }\n\n          overlayDelay = getElementTransitionDuration(overlay);\n          showOverlay();\n\n          setTimeout(() => beforeOffcanvasShow(this), overlayDelay);\n        } else {\n          beforeOffcanvasShow(this);\n          // istanbul ignore next @preserve - this test was done on Modal\n          if (currentOpen && hasClass(overlay, showClass)) {\n            hideOverlay();\n          }\n        }\n      }\n    }\n  }\n\n  /** Hides the offcanvas from the user. */\n  hide() {\n    const { element, relatedTarget } = this;\n\n    if (hasClass(element, showClass)) {\n      hideOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      hiddenOffcanvasEvent.relatedTarget = relatedTarget || undefined;\n      dispatchEvent(element, hideOffcanvasEvent);\n      if (!hideOffcanvasEvent.defaultPrevented) {\n        addClass(element, offcanvasTogglingClass);\n        removeClass(element, showClass);\n        beforeOffcanvasHide(this);\n      }\n    }\n  }\n\n  /**\n   * Toggles on/off the `click` event listeners.\n   *\n   * @param self the `Offcanvas` instance\n   * @param add when *true*, listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    this.triggers.forEach((btn) =>\n      action(btn, mouseclickEvent, offcanvasTriggerHandler)\n    );\n  };\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const { element } = this;\n    const isOpen = hasClass(element, showClass);\n    const callback = () => setTimeout(() => super.dispose(), 1);\n\n    this.hide();\n    this._toggleEventListeners();\n\n    if (isOpen) {\n      emulateTransitionEnd(element, callback);\n      // istanbul ignore next @preserve\n    } else {\n      callback();\n    }\n  }\n}\n","/** @type {string} */\nconst popoverString = \"popover\";\nexport default popoverString;\n","/** @type {string} */\nconst popoverComponent = \"Popover\";\nexport default popoverComponent;\n","/** @type {string} */\nconst tooltipString = \"tooltip\";\nexport default tooltipString;\n","import tooltipString from \"../strings/tooltipString\";\n\n/**\n * Returns a template for Popover / Tooltip.\n *\n * @param tipType the expected markup type\n * @returns the template markup\n */\nconst getTipTemplate = (tipType: string) => {\n  const isTooltip = tipType === tooltipString;\n  const bodyClass = isTooltip ? `${tipType}-inner` : `${tipType}-body`;\n  const header = !isTooltip ? `<h3 class=\"${tipType}-header\"></h3>` : \"\";\n  const arrow = `<div class=\"${tipType}-arrow\"></div>`;\n  const body = `<div class=\"${bodyClass}\"></div>`;\n  return `<div class=\"${tipType}\" role=\"${tooltipString}\">${\n    header + arrow + body\n  }</div>`;\n};\n\nexport default getTipTemplate;\n","const tipClassPositions = {\n  top: \"top\",\n  bottom: \"bottom\",\n  left: \"start\",\n  right: \"end\",\n};\n\nexport default tipClassPositions;\n","import {\n  createCustomEvent,\n  dispatchEvent,\n  getBoundingClientRect,\n  getDocumentElement,\n  getElementStyle,\n  isHTMLElement,\n  isRTL,\n  setElementStyle,\n  toLowerCase,\n} from \"@thednp/shorty\";\n\nimport popoverComponent from \"../strings/popoverComponent\";\nimport tipClassPositions from \"./tipClassPositions\";\nimport Tooltip from \"../components/tooltip\";\nimport type { TooltipEvent } from \"../interface/tooltip\";\nimport type { PopoverEvent } from \"../interface/popover\";\n\n/**\n * Style popovers and tooltips.\n *\n * @param self the `Popover` / `Tooltip` instance\n */\nconst styleTip = <T extends Tooltip>(self: T) => {\n  const tipClasses = /\\b(top|bottom|start|end)+/;\n  const { element, tooltip, container, options, arrow } = self;\n\n  // istanbul ignore else @preserve\n  if (tooltip) {\n    const tipPositions = { ...tipClassPositions };\n    const RTL = isRTL(element);\n\n    // reset tooltip style (top: 0, left: 0 works best)\n    setElementStyle(tooltip, {\n      // top: '0px', left: '0px', right: '', bottom: '',\n      top: \"\",\n      left: \"\",\n      right: \"\",\n      bottom: \"\",\n    });\n    const isPopover = self.name === popoverComponent;\n    const { offsetWidth: tipWidth, offsetHeight: tipHeight } = tooltip;\n    const { clientWidth: htmlcw, clientHeight: htmlch, offsetWidth: htmlow } =\n      getDocumentElement(element);\n    let { placement } = options;\n    const { clientWidth: parentCWidth, offsetWidth: parentOWidth } =\n      container as HTMLElement;\n    const parentPosition = getElementStyle(\n      container as HTMLElement,\n      \"position\",\n    );\n    const fixedParent = parentPosition === \"fixed\";\n    const scrollbarWidth = fixedParent\n      ? Math.abs(parentCWidth - parentOWidth)\n      : Math.abs(htmlcw - htmlow);\n    const leftBoundry = RTL && fixedParent\n      // istanbul ignore next @preserve\n      ? scrollbarWidth\n      : 0;\n    const rightBoundry = htmlcw - (!RTL ? scrollbarWidth : 0) - 1;\n    const {\n      width: elemWidth,\n      height: elemHeight,\n      left: elemRectLeft,\n      right: elemRectRight,\n      top: elemRectTop,\n    } = getBoundingClientRect(element, true);\n    const { x, y } = {\n      x: elemRectLeft,\n      y: elemRectTop,\n    };\n    // reset arrow style\n    setElementStyle(arrow as HTMLElement, {\n      top: \"\",\n      left: \"\",\n      right: \"\",\n      bottom: \"\",\n    });\n    let topPosition: number | string = 0;\n    let bottomPosition: number | string = \"\";\n    let leftPosition: number | string = 0;\n    let rightPosition: number | string = \"\";\n    let arrowTop: number | string = \"\";\n    let arrowLeft: number | string = \"\";\n    let arrowRight: number | string = \"\";\n\n    const arrowWidth = (arrow as HTMLElement).offsetWidth || 0;\n    const arrowHeight = (arrow as HTMLElement).offsetHeight || 0;\n    const arrowAdjust = arrowWidth / 2;\n\n    // check placement\n    let topExceed = elemRectTop - tipHeight - arrowHeight < 0;\n    let bottomExceed =\n      elemRectTop + tipHeight + elemHeight + arrowHeight >= htmlch;\n    let leftExceed = elemRectLeft - tipWidth - arrowWidth < leftBoundry;\n    let rightExceed =\n      elemRectLeft + tipWidth + elemWidth + arrowWidth >= rightBoundry;\n\n    const horizontals = [\"left\", \"right\"];\n    const verticals = [\"top\", \"bottom\"];\n\n    topExceed = horizontals.includes(placement)\n      ? elemRectTop + elemHeight / 2 - tipHeight / 2 - arrowHeight < 0\n      : topExceed;\n    bottomExceed = horizontals.includes(placement)\n      ? elemRectTop + tipHeight / 2 + elemHeight / 2 + arrowHeight >= htmlch\n      : bottomExceed;\n    leftExceed = verticals.includes(placement)\n      ? elemRectLeft + elemWidth / 2 - tipWidth / 2 < leftBoundry\n      : leftExceed;\n    rightExceed = verticals.includes(placement)\n      ? elemRectLeft + tipWidth / 2 + elemWidth / 2 >= rightBoundry\n      : rightExceed;\n\n    // first remove side positions if both left and right limits are exceeded\n    // we usually fall back to top|bottom\n    placement = horizontals.includes(placement) && leftExceed && rightExceed\n      ? \"top\"\n      : placement;\n    // recompute placement\n    placement = placement === \"top\" && topExceed ? \"bottom\" : placement;\n    placement = placement === \"bottom\" && bottomExceed ? \"top\" : placement;\n    placement = placement === \"left\" && leftExceed ? \"right\" : placement;\n    placement = placement === \"right\" && rightExceed\n      ? \"left\"\n      // istanbul ignore next @preserve\n      : placement;\n\n    // update tooltip/popover class\n    if (!tooltip.className.includes(placement)) {\n      tooltip.className = tooltip.className.replace(\n        tipClasses,\n        tipPositions[placement],\n      );\n    }\n\n    // compute tooltip / popover coordinates\n    // istanbul ignore else @preserve\n    if (horizontals.includes(placement)) {\n      // secondary|side positions\n      if (placement === \"left\") {\n        // LEFT\n        leftPosition = x - tipWidth - (isPopover ? arrowWidth : 0);\n      } else {\n        // RIGHT\n        leftPosition = x + elemWidth + (isPopover ? arrowWidth : 0);\n      }\n\n      // adjust top and arrow\n      if (topExceed && bottomExceed) {\n        topPosition = 0;\n        bottomPosition = 0;\n        arrowTop = elemRectTop + elemHeight / 2 - arrowHeight / 2;\n      } else if (topExceed) {\n        topPosition = y;\n        bottomPosition = \"\";\n        arrowTop = elemHeight / 2 - arrowWidth;\n      } else if (bottomExceed) {\n        topPosition = y - tipHeight + elemHeight;\n        bottomPosition = \"\";\n        arrowTop = tipHeight - elemHeight / 2 - arrowWidth;\n      } else {\n        topPosition = y - tipHeight / 2 + elemHeight / 2;\n        arrowTop = tipHeight / 2 - arrowHeight / 2;\n      }\n    } else if (verticals.includes(placement)) {\n      if (placement === \"top\") {\n        topPosition = y - tipHeight - (isPopover ? arrowHeight : 0);\n      } else {\n        // BOTTOM\n        topPosition = y + elemHeight + (isPopover ? arrowHeight : 0);\n      }\n\n      // adjust left | right and also the arrow\n      if (leftExceed) {\n        leftPosition = 0;\n        arrowLeft = x + elemWidth / 2 - arrowAdjust;\n      } else if (rightExceed) {\n        leftPosition = \"auto\";\n        rightPosition = 0;\n        arrowRight = elemWidth / 2 + rightBoundry - elemRectRight - arrowAdjust;\n      } else {\n        leftPosition = x - tipWidth / 2 + elemWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    }\n\n    // apply style to tooltip/popover\n    setElementStyle(tooltip, {\n      top: `${topPosition}px`,\n      bottom: bottomPosition === \"\" ? \"\" : `${bottomPosition}px`,\n      left: leftPosition === \"auto\" ? leftPosition : `${leftPosition}px`,\n      right: rightPosition !== \"\" ? `${rightPosition}px` : \"\",\n    });\n\n    // update arrow placement\n    // istanbul ignore else @preserve\n    if (isHTMLElement(arrow)) {\n      if (arrowTop !== \"\") {\n        arrow.style.top = `${arrowTop}px`;\n      }\n      if (arrowLeft !== \"\") {\n        arrow.style.left = `${arrowLeft}px`;\n      } else if (arrowRight !== \"\") {\n        arrow.style.right = `${arrowRight}px`;\n      }\n    }\n    const updatedTooltipEvent = createCustomEvent<\n      Record<string, unknown>,\n      TooltipEvent | PopoverEvent\n    >(\n      `updated.bs.${toLowerCase(self.name)}`,\n    );\n    dispatchEvent(element, updatedTooltipEvent);\n  }\n};\n\nexport default styleTip;\n","import getTipTemplate from \"./getTipTemplate\";\nimport tooltipString from \"../strings/tooltipString\";\nimport { TooltipOptions } from \"../interface/tooltip\";\n\nconst tooltipDefaults: TooltipOptions = {\n  template: getTipTemplate(tooltipString),\n  title: \"\",\n  customClass: \"\",\n  trigger: \"hover focus\",\n  placement: \"top\",\n  sanitizeFn: undefined,\n  animation: true,\n  delay: 200,\n  container: document.body,\n  content: \"\",\n  dismissible: false,\n  btnClose: \"\",\n};\nexport default tooltipDefaults;\n","const p = (i) => i != null && typeof i == \"object\" || !1, k = (i) => p(i) && typeof i.nodeType == \"number\" && [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].some(\n  (t) => i.nodeType === t\n) || !1, _ = (i) => k(i) && i.nodeType === 1 || !1, B = (i) => typeof i == \"function\" || !1, m = \"PositionObserver Error\";\nclass x {\n  entries;\n  _tick;\n  _root;\n  _callback;\n  /**\n   * The constructor takes two arguments, a `callback`, which is called\n   * whenever the position of an observed element changes and an `options` object.\n   * The callback function should take an array of `PositionObserverEntry` objects\n   * as its only argument, but it's not required.\n   *\n   * @param callback the callback that applies to all targets of this observer\n   * @param options the options of this observer\n   */\n  constructor(t, n) {\n    if (!B(t))\n      throw new Error(`${m}: ${t} is not a function.`);\n    this.entries = [], this._callback = t, this._root = _(n?.root) ? n.root : document?.documentElement, this._tick = 0;\n  }\n  /**\n   * Start observing the position of the specified element.\n   * If the element is not currently attached to the DOM,\n   * it will NOT be added to the entries.\n   * @param target\n   */\n  observe = (t) => {\n    if (!_(t))\n      throw new Error(\n        `${m}: ${t} is not an instance of HTMLElement.`\n      );\n    if (!this._root.contains(t)) return;\n    const { clientWidth: n, clientHeight: o } = this._root, h = t.getBoundingClientRect(), { left: l, top: u, bottom: e, right: s, width: r, height: c } = h, a = u > 1 - c && l > 1 - r && e <= o + c - 1 && s <= n + r - 1;\n    this.entries.push({ target: t, boundingBox: h, isVisible: a }), this._tick || (this._tick = requestAnimationFrame(this._runCallback));\n  };\n  /**\n   * Stop observing the position of the specified element.\n   * @param target\n   */\n  unobserve = (t) => {\n    const n = this.entries.findIndex((o) => o.target === t);\n    this.entries.splice(n, 1);\n  };\n  /**\n   * Private method responsible for all the heavy duty.\n   */\n  _runCallback = () => {\n    if (!this.entries.length) return;\n    const t = [], { clientWidth: n, clientHeight: o } = this._root;\n    this.entries.forEach((h, l) => {\n      const { target: u, boundingBox: e } = h, s = u.getBoundingClientRect(), { left: r, top: c, bottom: a, right: d, width: b, height: f } = s;\n      if (e.left !== r || e.top !== c || e.right !== d || e.bottom !== a) {\n        const g = c > 1 - f && r > 1 - b && a <= o + f - 1 && d <= n + b - 1;\n        this.entries[l].boundingBox = s, this.entries[l].isVisible = g, t.push({ target: u, boundingBox: s, isVisible: g });\n      }\n    }), t.length && this._callback(t), requestAnimationFrame(this._runCallback);\n  };\n  /**\n   * Immediately stop observing all elements.\n   */\n  disconnect = () => {\n    cancelAnimationFrame(this._tick), this.entries.length = 0, this._tick = 0;\n  };\n}\nexport {\n  x as default\n};\n//# sourceMappingURL=index.mjs.map\n","/**\n * Global namespace for `data-bs-title` attribute.\n */\nconst dataOriginalTitle = \"data-original-title\";\nexport default dataOriginalTitle;\n","/** @type {string} */\nconst tooltipComponent = \"Tooltip\";\nexport default tooltipComponent;\n","import {\n  isArray,\n  isFunction,\n  isHTMLElement,\n  isNode,\n  isNodeList,\n  isString,\n} from \"@thednp/shorty\";\n\n/**\n * Append an existing `Element` to Popover / Tooltip component or HTML\n * markup string to be parsed & sanitized to be used as popover / tooltip content.\n *\n * @param element target\n * @param content the `Element` to append / string\n * @param sanitizeFn a function to sanitize string content\n */\nconst setHtml = (\n  element: HTMLElement,\n  content: Node[] | Node | string,\n  sanitizeFn?: (s: string) => string,\n) => {\n  // istanbul ignore else @preserve\n  if (isString(content) && content.length) {\n    let dirty = content.trim(); // fixing #233\n    if (isFunction(sanitizeFn)) dirty = sanitizeFn(dirty);\n\n    const domParser = new DOMParser();\n    const tempDocument = domParser.parseFromString(dirty, \"text/html\");\n    element.append(...[...tempDocument.body.childNodes]);\n  } else if (isHTMLElement(content)) {\n    element.append(content);\n  } else if (\n    isNodeList(content) || (isArray(content) && content.every(isNode))\n  ) {\n    element.append(...[...content]);\n  }\n};\nexport default setHtml;\n","import {\n  addClass,\n  createElement,\n  hasClass,\n  isHTMLElement,\n  isRTL,\n  querySelector,\n  setAttribute,\n} from \"@thednp/shorty\";\n\nimport tooltipComponent from \"../strings/tooltipComponent\";\nimport tooltipString from \"../strings/tooltipString\";\nimport popoverString from \"../strings/popoverString\";\nimport fadeClass from \"../strings/fadeClass\";\nimport tipClassPositions from \"./tipClassPositions\";\nimport setHtml from \"./setHtml\";\nimport Tooltip from \"../components/tooltip\";\nimport Popover from \"../components/popover\";\n\n/**\n * Creates a new tooltip / popover.\n *\n * @param self the `Tooltip` / `Popover` instance\n */\nconst createTip = (self: Tooltip | Popover) => {\n  const isTooltip = self.name === tooltipComponent;\n\n  const { id, element, options } = self;\n  const {\n    title,\n    placement,\n    template,\n    animation,\n    customClass,\n    sanitizeFn,\n    dismissible,\n    content,\n    btnClose,\n  } = options;\n  const tipString = isTooltip ? tooltipString : popoverString;\n  const tipPositions = { ...tipClassPositions };\n  let titleParts: Node[] = [];\n  let contentParts: Node[] = [];\n\n  if (isRTL(element)) {\n    tipPositions.left = \"end\";\n    tipPositions.right = \"start\";\n  }\n\n  // set initial popover class\n  const placementClass = `bs-${tipString}-${tipPositions[placement]}`;\n\n  // load template\n  let tooltipTemplate: Node | string;\n  if (isHTMLElement(template)) {\n    tooltipTemplate = template;\n  } else {\n    const htmlMarkup = createElement(\"div\") as HTMLElement;\n    setHtml(htmlMarkup, template, sanitizeFn);\n    tooltipTemplate = htmlMarkup.firstChild as HTMLElement;\n  }\n\n  // set popover markup\n  self.tooltip = isHTMLElement(tooltipTemplate)\n    ? (tooltipTemplate.cloneNode(true) as HTMLElement)\n    // istanbul ignore next @preserve\n    : undefined;\n\n  const { tooltip } = self;\n  // istanbul ignore else @preserve\n  if (tooltip) {\n    // set id and role attributes\n    setAttribute(tooltip, \"id\", id);\n    setAttribute(tooltip, \"role\", tooltipString);\n\n    const bodyClass = isTooltip\n      ? `${tooltipString}-inner`\n      : `${popoverString}-body`;\n    const tooltipHeader = isTooltip\n      ? null\n      : querySelector(`.${popoverString}-header`, tooltip);\n    const tooltipBody = querySelector(`.${bodyClass}`, tooltip);\n\n    // set arrow and enable access for styleTip\n    self.arrow = querySelector(`.${tipString}-arrow`, tooltip) as HTMLElement;\n    const { arrow } = self;\n\n    if (isHTMLElement(title)) titleParts = [title.cloneNode(true)];\n    else {\n      const tempTitle = createElement(\"div\") as HTMLElement;\n      setHtml(tempTitle, title, sanitizeFn);\n      titleParts = [...[...tempTitle.childNodes]];\n    }\n\n    if (isHTMLElement(content)) contentParts = [content.cloneNode(true)];\n    else {\n      const tempContent = createElement(\"div\") as HTMLElement;\n      setHtml(tempContent, content, sanitizeFn);\n      contentParts = [...[...tempContent.childNodes]];\n    }\n\n    // set dismissible button\n    if (dismissible) {\n      if (title) {\n        if (isHTMLElement(btnClose)) {\n          titleParts = [...titleParts, btnClose.cloneNode(true)];\n        } else {\n          const tempBtn = createElement(\"div\") as HTMLElement;\n          setHtml(tempBtn, btnClose, sanitizeFn);\n          titleParts = [...titleParts, tempBtn.firstChild as Node];\n        }\n      } else {\n        // istanbul ignore else @preserve\n        if (tooltipHeader) tooltipHeader.remove();\n        if (isHTMLElement(btnClose)) {\n          contentParts = [...contentParts, btnClose.cloneNode(true)];\n        } else {\n          const tempBtn = createElement(\"div\") as HTMLElement;\n          setHtml(tempBtn, btnClose, sanitizeFn);\n          contentParts = [...contentParts, tempBtn.firstChild as Node];\n        }\n      }\n    }\n\n    // fill the template with content from options / data attributes\n    // also sanitize title && content\n    // istanbul ignore else @preserve\n    if (!isTooltip) {\n      // istanbul ignore else @preserve\n      if (title && tooltipHeader) {\n        setHtml(tooltipHeader, titleParts, sanitizeFn);\n      }\n      // istanbul ignore else @preserve\n      if (content && tooltipBody) {\n        setHtml(tooltipBody, contentParts, sanitizeFn);\n      }\n      // set btn\n      self.btn = querySelector(\".btn-close\", tooltip) || undefined;\n    } else if (title && tooltipBody) setHtml(tooltipBody, title, sanitizeFn);\n\n    // Bootstrap 5.2.x\n    // addClass(tooltip, 'position-absolute');\n    addClass(tooltip, \"position-fixed\");\n    addClass(arrow, \"position-absolute\");\n\n    // set popover animation and placement\n    // istanbul ignore else @preserve\n    if (!hasClass(tooltip, tipString)) addClass(tooltip, tipString);\n    // istanbul ignore else @preserve\n    if (animation && !hasClass(tooltip, fadeClass)) {\n      addClass(tooltip, fadeClass);\n    }\n    // istanbul ignore else @preserve\n    if (customClass && !hasClass(tooltip, customClass)) {\n      addClass(tooltip, customClass);\n    }\n    // istanbul ignore else @preserve\n    if (!hasClass(tooltip, placementClass)) addClass(tooltip, placementClass);\n  }\n};\n\nexport default createTip;\n","import {\n  getDocument,\n  getElementStyle,\n  getParentNode,\n  isShadowRoot,\n  isTableElement,\n} from \"@thednp/shorty\";\n\n/**\n * Returns an `HTMLElement` to be used as default value for *options.container*\n * for `Tooltip` / `Popover` components.\n *\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param element the target\n * @returns the query result\n */\nconst getElementContainer = (element: HTMLElement): ParentNode => {\n  const majorBlockTags = [\"HTML\", \"BODY\"];\n  const containers: ParentNode[] = [];\n  let { parentNode } = element as Node;\n\n  while (parentNode && !majorBlockTags.includes(parentNode.nodeName)) {\n    parentNode = getParentNode(parentNode) as ParentNode;\n    // istanbul ignore else @preserve\n    if (!(isShadowRoot(parentNode) || isTableElement(parentNode))) {\n      containers.push(parentNode);\n    }\n  }\n\n  return (\n    containers.find((c, i) => {\n      if (\n        getElementStyle(c as HTMLElement, \"position\") !== \"relative\" &&\n        containers.slice(i + 1).every((r) =>\n          getElementStyle(r as HTMLElement, \"position\") === \"static\"\n        )\n      ) {\n        return c;\n      }\n      return null;\n    }) ||\n    // istanbul ignore next: optional guard\n    getDocument(element).body\n  );\n};\n\nexport default getElementContainer;\n","/* Native JavaScript for Bootstrap 5 | Tooltip\n---------------------------------------------- */\nimport {\n  addClass,\n  ariaDescribedBy,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  emulateTransitionEnd,\n  focus,\n  focusEvent,\n  focusinEvent,\n  focusoutEvent,\n  getAttribute,\n  getDocument,\n  getElementStyle,\n  getInstance,\n  getUID,\n  hasAttribute,\n  hasClass,\n  isApple,\n  mouseclickEvent,\n  mousedownEvent,\n  mouseenterEvent,\n  mousehoverEvent,\n  mouseleaveEvent,\n  ObjectAssign,\n  passiveHandler,\n  removeAttribute,\n  removeClass,\n  setAttribute,\n  Timer,\n  toLowerCase,\n  touchstartEvent,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\nimport PositionObserver from \"@thednp/position-observer\";\n\nimport dataBsToggle from \"../strings/dataBsToggle\";\nimport dataOriginalTitle from \"../strings/dataOriginalTitle\";\nimport showClass from \"../strings/showClass\";\nimport tooltipString from \"../strings/tooltipString\";\nimport tooltipComponent from \"../strings/tooltipComponent\";\nimport popoverString from \"../strings/popoverString\";\nimport popoverComponent from \"../strings/popoverComponent\";\nimport modalString from \"../strings/modalString\";\nimport offcanvasString from \"../strings/offcanvasString\";\n\nimport styleTip from \"../util/styleTip\";\nimport createTip from \"../util/createTip\";\nimport { appendPopup, hasPopup, removePopup } from \"../util/popupContainer\";\nimport getElementContainer from \"../util/getElementContainer\";\nimport tooltipDefaults from \"../util/tooltipDefaults\";\nimport BaseComponent from \"./base-component\";\nimport type { TooltipEvent, TooltipOptions } from \"../interface/tooltip\";\nimport type { PopoverEvent, PopoverOptions } from \"../interface/popover\";\n\n// TOOLTIP PRIVATE GC\n// ==================\nconst tooltipSelector =\n  `[${dataBsToggle}=\"${tooltipString}\"],[data-tip=\"${tooltipString}\"]`;\nconst titleAttr = \"title\";\n\n/**\n * Static method which returns an existing `Tooltip` instance associated\n * to a target `Element`.\n */\nlet getTooltipInstance = (element: HTMLElement) =>\n  getInstance<Tooltip>(element, tooltipComponent);\n\n/**\n * A `Tooltip` initialization callback.\n */\nconst tooltipInitCallback = (element: HTMLElement) => new Tooltip(element);\n\n// TOOLTIP PRIVATE METHODS\n// =======================\n/**\n * Removes the tooltip from the DOM.\n *\n * @param self the `Tooltip` instance\n */\nconst removeTooltip = (self: Tooltip) => {\n  const { element, tooltip, container, offsetParent } = self;\n  removeAttribute(element, ariaDescribedBy);\n  removePopup(\n    tooltip as HTMLElement,\n    container === offsetParent ? container : offsetParent,\n  );\n};\n\n/**\n * Check if container contains the tooltip.\n *\n * @param self Tooltip\n */\nconst hasTip = (self: Tooltip): boolean | undefined => {\n  const { tooltip, container, offsetParent } = self;\n\n  return tooltip &&\n    hasPopup(tooltip, container === offsetParent ? container : offsetParent);\n};\n\n/**\n * Executes after the instance has been disposed.\n *\n * @param self the `Tooltip` instance\n * @param callback the parent dispose callback\n */\nconst disposeTooltipComplete = (self: Tooltip, callback?: () => void) => {\n  const { element } = self;\n  self._toggleEventListeners();\n\n  // istanbul ignore else @preserve\n  if (\n    hasAttribute(element, dataOriginalTitle) && self.name === tooltipComponent\n  ) {\n    toggleTooltipTitle(self);\n  }\n  // istanbul ignore else @preserve\n  if (callback) callback();\n};\n\n/**\n * Toggles on/off the special `Tooltip` event listeners.\n *\n * @param self the `Tooltip` instance\n * @param add when `true`, event listeners are added\n */\nconst toggleTooltipAction = (self: Tooltip, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n\n  action(\n    getDocument(element),\n    touchstartEvent,\n    self.handleTouch,\n    passiveHandler,\n  );\n};\n\n/**\n * Executes after the tooltip was shown to the user.\n *\n * @param self the `Tooltip` instance\n */\nconst tooltipShownAction = (self: Tooltip) => {\n  const { element } = self;\n  const shownTooltipEvent = createCustomEvent<\n    Record<string, never>,\n    TooltipEvent | PopoverEvent\n  >(\n    `shown.bs.${toLowerCase(self.name)}`,\n  );\n\n  toggleTooltipAction(self, true);\n  dispatchEvent(element, shownTooltipEvent);\n  Timer.clear(element, \"in\");\n};\n\n/**\n * Executes after the tooltip was hidden to the user.\n *\n * @param self the `Tooltip` instance\n */\nconst tooltipHiddenAction = (self: Tooltip) => {\n  const { element } = self;\n  const hiddenTooltipEvent = createCustomEvent<\n    Record<string, never>,\n    TooltipEvent | PopoverEvent\n  >(\n    `hidden.bs.${toLowerCase(self.name)}`,\n  );\n\n  toggleTooltipAction(self);\n  removeTooltip(self);\n  dispatchEvent(element, hiddenTooltipEvent);\n\n  Timer.clear(element, \"out\");\n};\n\n/**\n * Toggles on/off the `Tooltip` event listeners that hide/update the tooltip.\n *\n * @param self the `Tooltip` instance\n * @param add when `true`, event listeners are added\n */\nconst toggleTooltipOpenHandlers = (self: Tooltip, add?: boolean) => {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n  // const { offsetHeight, scrollHeight } = container as HTMLElement;\n  const parentModal = closest(element, `.${modalString}`);\n  const parentOffcanvas = closest(element, `.${offcanvasString}`);\n\n  if (add) self._observer.observe(self.element);\n  else self._observer.disconnect();\n\n  // dismiss tooltips inside modal / offcanvas\n  if (parentModal) {\n    action(parentModal, `hide.bs.${modalString}`, self.handleHide);\n  }\n  if (parentOffcanvas) {\n    action(parentOffcanvas, `hide.bs.${offcanvasString}`, self.handleHide);\n  }\n};\n\n/**\n * Toggles the `title` and `data-original-title` attributes.\n *\n * @param self the `Tooltip` instance\n * @param content when `true`, event listeners are added\n */\nconst toggleTooltipTitle = (self: Tooltip, content?: string) => {\n  // [0 - add, 1 - remove] | [0 - remove, 1 - add]\n  const titleAtt = [dataOriginalTitle, titleAttr];\n  const { element } = self;\n\n  setAttribute(\n    element,\n    titleAtt[content ? 0 : 1],\n    content ||\n      getAttribute(element, titleAtt[0]) ||\n      // istanbul ignore next @preserve\n      \"\",\n  );\n  removeAttribute(element, titleAtt[content ? 1 : 0]);\n};\n\n// TOOLTIP DEFINITION\n// ==================\n/** Creates a new `Tooltip` instance. */\nexport default class Tooltip extends BaseComponent {\n  static selector = tooltipSelector;\n  static init = tooltipInitCallback;\n  static getInstance = getTooltipInstance;\n  static styleTip = styleTip;\n  declare options: TooltipOptions;\n  declare btn?: HTMLElement;\n  declare tooltip?: HTMLElement;\n  declare container: ParentNode;\n  declare arrow?: HTMLElement;\n  declare offsetParent?: HTMLElement;\n  declare enabled: boolean;\n  declare id: string;\n  declare _observer: PositionObserver;\n\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<TooltipOptions>) {\n    super(target, config);\n\n    const { element } = this;\n    const isTooltip = this.name === tooltipComponent;\n    const tipString = isTooltip ? tooltipString : popoverString;\n    const tipComponent = isTooltip ? tooltipComponent : popoverComponent;\n\n    // istanbul ignore next @preserve: this is to set Popover too\n    getTooltipInstance = <T extends Tooltip>(elem: HTMLElement) =>\n      getInstance<T>(elem, tipComponent);\n\n    // additional properties\n    this.enabled = true;\n    /** Set unique ID for `aria-describedby`. */\n    this.id = `${tipString}-${getUID(element, tipString)}`;\n\n    // instance options\n    const { options } = this;\n\n    // invalidate\n    if (!((!options.title && isTooltip) || (!isTooltip && !options.content))) {\n      // reset default options\n      ObjectAssign(tooltipDefaults, { titleAttr: \"\" });\n\n      // set title attributes and add event listeners\n      // istanbul ignore else @preserve\n      if (\n        hasAttribute(element, titleAttr) && isTooltip &&\n        typeof options.title === \"string\"\n      ) {\n        toggleTooltipTitle(this, options.title);\n      }\n\n      // set containers\n      this.container = getElementContainer(element);\n      this.offsetParent = [\"sticky\", \"fixed\"].some(\n          (position) =>\n            getElementStyle(this.container as HTMLElement, \"position\") ===\n              position,\n        )\n        ? (this.container as HTMLElement)\n        : getDocument(this.element).body;\n\n      // create tooltip here\n      createTip(this);\n\n      // create observer\n      this._observer = new PositionObserver(() => this.update());\n\n      // attach events\n      this._toggleEventListeners(true);\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return tooltipComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return tooltipDefaults;\n  }\n\n  // TOOLTIP PUBLIC METHODS\n  // ======================\n  /** Handles the focus event on iOS. */\n  // istanbul ignore next @preserve - impossible to test without Apple device\n  handleFocus = () => focus(this.element);\n  /** Shows the tooltip. */\n  handleShow = () => this.show();\n  show() {\n    const { options, tooltip, element, container, offsetParent, id } = this;\n    const { animation } = options;\n    const outTimer = Timer.get(element, \"out\");\n    const tipContainer = container === offsetParent ? container : offsetParent;\n\n    Timer.clear(element, \"out\");\n\n    if (tooltip && !outTimer && !hasTip(this)) {\n      Timer.set(\n        element,\n        () => {\n          const showTooltipEvent = createCustomEvent<\n            Record<string, never>,\n            TooltipEvent | PopoverEvent\n          >(\n            `show.bs.${toLowerCase(this.name)}`,\n          );\n          dispatchEvent(element, showTooltipEvent);\n\n          // istanbul ignore else @preserve\n          if (!showTooltipEvent.defaultPrevented) {\n            // append to container\n            appendPopup(tooltip, tipContainer);\n\n            setAttribute(element, ariaDescribedBy, `#${id}`);\n\n            this.update();\n            toggleTooltipOpenHandlers(this, true);\n\n            // istanbul ignore else @preserve\n            if (!hasClass(tooltip, showClass)) addClass(tooltip, showClass);\n            // istanbul ignore else @preserve\n            if (animation) {\n              emulateTransitionEnd(tooltip, () => tooltipShownAction(this));\n            } else tooltipShownAction(this);\n          }\n        },\n        17,\n        \"in\",\n      );\n    }\n  }\n\n  /** Hides the tooltip. */\n  handleHide = () => this.hide();\n  hide() {\n    const { options, tooltip, element } = this;\n    const { animation, delay } = options;\n\n    Timer.clear(element, \"in\");\n\n    // istanbul ignore else @preserve\n    if (tooltip && hasTip(this)) {\n      Timer.set(\n        element,\n        () => {\n          const hideTooltipEvent = createCustomEvent<\n            Record<string, never>,\n            TooltipEvent | PopoverEvent\n          >(\n            `hide.bs.${toLowerCase(this.name)}`,\n          );\n          dispatchEvent(element, hideTooltipEvent);\n\n          // istanbul ignore else @preserve\n          if (!hideTooltipEvent.defaultPrevented) {\n            this.update();\n            removeClass(tooltip, showClass);\n            toggleTooltipOpenHandlers(this);\n\n            // istanbul ignore else @preserve\n            if (animation) {\n              emulateTransitionEnd(tooltip, () => tooltipHiddenAction(this));\n            } else tooltipHiddenAction(this);\n          }\n        },\n        delay + 17,\n        \"out\",\n      );\n    }\n  }\n\n  /** Updates the tooltip position. */\n  update = () => {\n    styleTip<Tooltip>(this);\n  };\n\n  /** Toggles the tooltip visibility. */\n  toggle = () => {\n    const { tooltip } = this;\n\n    if (tooltip && !hasTip(this)) this.show();\n    else this.hide();\n  };\n\n  /** Enables the tooltip. */\n  enable() {\n    const { enabled } = this;\n    // istanbul ignore else @preserve\n    if (!enabled) {\n      this._toggleEventListeners(true);\n      this.enabled = !enabled;\n    }\n  }\n\n  /** Disables the tooltip. */\n  disable() {\n    const { tooltip, enabled } = this;\n    // istanbul ignore else @preserve\n    if (enabled) {\n      if (tooltip && hasTip(this)) this.hide();\n      this._toggleEventListeners();\n      this.enabled = !enabled;\n    }\n  }\n\n  /** Toggles the `disabled` property. */\n  toggleEnabled() {\n    if (!this.enabled) this.enable();\n    else this.disable();\n  }\n\n  /**\n   * Handles the `touchstart` event listener for `Tooltip`\n   *\n   * @this {Tooltip}\n   * @param {TouchEvent} e the `Event` object\n   */\n  handleTouch = ({ target }: TouchEvent) => {\n    const { tooltip, element } = this;\n\n    // istanbul ignore if @preserve\n    if (\n      (tooltip && tooltip.contains(target as HTMLElement)) ||\n      target === element ||\n      (target && element.contains(target as HTMLElement))\n    ) {\n      // smile for ESLint\n    } else {\n      this.hide();\n    }\n  };\n\n  /**\n   * Toggles on/off the `Tooltip` event listeners.\n   *\n   * @param add when `true`, event listeners are added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    // btn is only for dismissible popover\n    const { element, options, btn } = this;\n    const { trigger } = options;\n    const isPopover = this.name !== tooltipComponent;\n    const dismissible = isPopover && (options as PopoverOptions).dismissible\n      ? true\n      : false;\n\n    // istanbul ignore else @preserve\n    if (!trigger.includes(\"manual\")) {\n      this.enabled = !!add;\n\n      const triggerOptions = trigger.split(\" \");\n\n      triggerOptions.forEach((tr) => {\n        // istanbul ignore else @preserve\n        if (tr === mousehoverEvent) {\n          action(element, mousedownEvent, this.handleShow);\n          action(element, mouseenterEvent, this.handleShow);\n\n          // istanbul ignore else @preserve\n          if (!dismissible) {\n            action(element, mouseleaveEvent, this.handleHide);\n            action(\n              getDocument(element),\n              touchstartEvent,\n              this.handleTouch,\n              passiveHandler,\n            );\n          }\n        } else if (tr === mouseclickEvent) {\n          action(element, tr, !dismissible ? this.toggle : this.handleShow);\n        } else if (tr === focusEvent) {\n          action(element, focusinEvent, this.handleShow);\n          // istanbul ignore else @preserve\n          if (!dismissible) action(element, focusoutEvent, this.handleHide);\n          // istanbul ignore else @preserve\n          if (isApple()) {\n            action(element, mouseclickEvent, this.handleFocus);\n          }\n        }\n        // istanbul ignore else @preserve\n        if (dismissible && btn) {\n          action(btn, mouseclickEvent, this.handleHide);\n        }\n      });\n    }\n  };\n\n  /** Removes the `Tooltip` from the target element. */\n  dispose() {\n    const { tooltip, options } = this;\n    const clone = { ...this, name: this.name };\n    const callback = () =>\n      setTimeout(\n        () => disposeTooltipComplete(clone, () => super.dispose()),\n        17,\n      );\n\n    if (options.animation && hasTip(clone)) {\n      this.options.delay = 0; // reset delay\n      this.hide();\n      emulateTransitionEnd(tooltip as HTMLElement, callback);\n    } else {\n      callback();\n    }\n  }\n}\n","/* Native JavaScript for Bootstrap 5 | Popover\n---------------------------------------------- */\nimport { focus, getInstance, ObjectAssign } from \"@thednp/shorty\";\n\nimport dataBsToggle from \"../strings/dataBsToggle\";\nimport popoverString from \"../strings/popoverString\";\nimport popoverComponent from \"../strings/popoverComponent\";\n\nimport getTipTemplate from \"../util/getTipTemplate\";\nimport styleTip from \"../util/styleTip\";\nimport tooltipDefaults from \"../util/tooltipDefaults\";\nimport Tooltip from \"./tooltip\";\n\nimport type { PopoverOptions /* , PopoverEvent */ } from \"../interface/popover\";\n\n// POPOVER PRIVATE GC\n// ==================\nconst popoverSelector =\n  `[${dataBsToggle}=\"${popoverString}\"],[data-tip=\"${popoverString}\"]`;\n\nconst popoverDefaults: PopoverOptions = ObjectAssign({}, tooltipDefaults, {\n  template: getTipTemplate(popoverString),\n  content: \"\",\n  dismissible: false,\n  btnClose: '<button class=\"btn-close\" aria-label=\"Close\"></button>',\n});\n\n/**\n * Static method which returns an existing `Popover` instance associated\n * to a target `Element`.\n */\nconst getPopoverInstance = (element: HTMLElement) =>\n  getInstance<Popover>(element, popoverComponent);\n\n/**\n * A `Popover` initialization callback.\n */\nconst popoverInitCallback = (element: HTMLElement) => new Popover(element);\n\n// POPOVER DEFINITION\n// ==================\n/** Returns a new `Popover` instance. */\nexport default class Popover extends Tooltip {\n  static selector = popoverSelector;\n  static init = popoverInitCallback;\n  static getInstance = getPopoverInstance;\n  static styleTip = styleTip;\n  declare options: PopoverOptions;\n\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<PopoverOptions>) {\n    super(target, config);\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return popoverComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return popoverDefaults;\n  }\n\n  /* extend original `show()` */\n  show = () => {\n    super.show();\n    // btn only exists within dismissible popover\n    const { options, btn } = this;\n    // istanbul ignore else @preserve\n    if (options.dismissible && btn) setTimeout(() => focus(btn), 17);\n  };\n}\n","/** @type {string} */\nconst scrollspyString = \"scrollspy\";\nexport default scrollspyString;\n","/** @type {string} */\nconst scrollspyComponent = \"ScrollSpy\";\nexport default scrollspyComponent;\n","/* Native JavaScript for Bootstrap 5 | ScrollSpy\n------------------------------------------------ */\nimport {\n  addClass,\n  createCustomEvent,\n  dispatchEvent,\n  getAttribute,\n  getBoundingClientRect,\n  getDocument,\n  getDocumentBody,\n  getDocumentElement,\n  getElementsByTagName,\n  getInstance,\n  hasClass,\n  isHTMLElement,\n  querySelector,\n  removeClass,\n} from \"@thednp/shorty\";\n\nimport PositionObserver from \"@thednp/position-observer\";\n\nimport activeClass from \"../strings/activeClass\";\nimport scrollspyString from \"../strings/scrollspyString\";\nimport scrollspyComponent from \"../strings/scrollspyComponent\";\n\nimport BaseComponent from \"./base-component\";\nimport { ScrollSpyEvent, ScrollSpyOptions } from \"../interface/scrollspy\";\n\n// SCROLLSPY PRIVATE GC\n// ====================\nconst scrollspySelector = '[data-bs-spy=\"scroll\"]';\n\nconst scrollspyDefaults: ScrollSpyOptions = {\n  offset: 10,\n  target: null,\n};\n\ntype ScrollSpyEventProps = {\n  relatedTarget: HTMLElement;\n};\n\n/**\n * Static method which returns an existing `ScrollSpy` instance associated\n * to a target `Element`.\n */\nconst getScrollSpyInstance = (element: HTMLElement) =>\n  getInstance<ScrollSpy>(element, scrollspyComponent);\n\n/**\n * A `ScrollSpy` initialization callback.\n */\nconst scrollspyInitCallback = (element: HTMLElement) => new ScrollSpy(element);\n\n// SCROLLSPY CUSTOM EVENT\n// ======================\nconst activateScrollSpy = createCustomEvent<\n  ScrollSpyEventProps,\n  ScrollSpyEvent\n>(`activate.bs.${scrollspyString}`);\n\n// SCROLLSPY PRIVATE METHODS\n// =========================\n/**\n * Update the state of all items.\n *\n * @param self the `ScrollSpy` instance\n */\nconst updateSpyTargets = (self: ScrollSpy) => {\n  const { target, scrollTarget, options, itemsLength, scrollHeight, element } =\n    self;\n  const { offset } = options;\n  const isRoot = scrollTarget !== element;\n\n  const links = target && getElementsByTagName(\"A\", target);\n  const doc = getDocument(element);\n  const scrollHEIGHT = scrollTarget.scrollHeight;\n\n  self.scrollTop = scrollTarget.scrollTop;\n\n  // only update items/offsets once or with each mutation\n  // istanbul ignore else @preserve\n  if (\n    links && (scrollHEIGHT !== scrollHeight || itemsLength !== links.length)\n  ) {\n    let href;\n    let targetItem;\n    let rect;\n\n    // reset arrays & update\n    self.items = [];\n    self.targets = [];\n    self.offsets = [];\n    self.scrollHeight = scrollHEIGHT;\n    self.maxScroll = self.scrollHeight - getOffsetHeight(self);\n\n    Array.from(links).forEach((link) => {\n      href = getAttribute(link, \"href\");\n      targetItem = href && href.charAt(0) === \"#\" && href.slice(-1) !== \"#\" &&\n        querySelector(href, doc);\n\n      if (targetItem) {\n        self.items.push(link);\n        self.targets.push(targetItem);\n        rect = getBoundingClientRect(targetItem);\n        self.offsets.push(\n          (isRoot ? rect.top + self.scrollTop : targetItem.offsetTop) - offset,\n        );\n      }\n    });\n    self.itemsLength = self.items.length;\n  }\n};\n\n/**\n * Toggles on/off the component observer.\n *\n * @param self the ScrollSpy instance\n * @param add when `true`, listener is added\n */\nconst toggleObservers = (\n  { targets, scrollTarget, element, _observer }: ScrollSpy,\n  add?: boolean,\n) => {\n  if (add) {\n    if (scrollTarget === element) {\n      targets.forEach((targetItem) => _observer.observe(targetItem));\n    } else {\n      _observer.observe(element);\n    }\n  } else _observer.disconnect();\n};\n\n/**\n * Returns the `scrollHeight` property of the scrolling element.\n *\n * @param scrollTarget the `ScrollSpy` instance\n * @return `scrollTarget` height\n */\nconst getScrollHeight = (scrollTarget: HTMLElement) => {\n  return scrollTarget.scrollHeight;\n};\n\n/**\n * Returns the height property of the scrolling element.\n *\n * @param params the `ScrollSpy` instance\n */\nconst getOffsetHeight = ({ element, scrollTarget }: ScrollSpy) => {\n  return scrollTarget !== element\n    ? scrollTarget.clientHeight\n    : getBoundingClientRect(element).height;\n};\n\n/**\n * Clear all items of the target.\n *\n * @param target a single item\n */\nconst clear = (target: HTMLElement) => {\n  [...getElementsByTagName(\"A\", target)].forEach((item) => {\n    if (hasClass(item, activeClass)) removeClass(item, activeClass);\n  });\n};\n\n/**\n * Activates a new item.\n *\n * @param self the `ScrollSpy` instance\n * @param item a single item\n */\nconst activate = (self: ScrollSpy, item: HTMLElement) => {\n  const { target, element } = self;\n\n  // istanbul ignore else @preserve\n  if (isHTMLElement(target)) clear(target);\n\n  self.activeItem = item;\n  addClass(item, activeClass);\n\n  // activate all parents\n  const parents: HTMLElement[] = [];\n  let parentItem = item;\n  while (parentItem !== getDocumentBody(element)) {\n    parentItem = parentItem.parentElement as HTMLElement;\n    if (hasClass(parentItem, \"nav\") || hasClass(parentItem, \"dropdown-menu\")) {\n      parents.push(parentItem);\n    }\n  }\n\n  parents.forEach((menuItem) => {\n    const parentLink = menuItem.previousElementSibling as HTMLElement | null;\n\n    // istanbul ignore else @preserve\n    if (parentLink && !hasClass(parentLink, activeClass)) {\n      addClass(parentLink, activeClass);\n    }\n  });\n\n  // dispatch\n  activateScrollSpy.relatedTarget = item;\n  dispatchEvent(element, activateScrollSpy);\n};\n\n// SCROLLSPY DEFINITION\n// ====================\n/** Returns a new `ScrollSpy` instance. */\nexport default class ScrollSpy extends BaseComponent {\n  static selector = scrollspySelector;\n  static init = scrollspyInitCallback;\n  static getInstance = getScrollSpyInstance;\n  declare options: ScrollSpyOptions;\n  declare target: HTMLElement | null;\n  declare scrollTarget: HTMLElement;\n  declare scrollTop: number;\n  declare maxScroll: number;\n  declare scrollHeight: number;\n  declare activeItem: HTMLElement | null;\n  declare items: HTMLElement[];\n  declare targets: HTMLElement[];\n  declare itemsLength: number;\n  declare offsets: number[];\n  declare _observer: PositionObserver;\n\n  /**\n   * @param target the target element\n   * @param config the instance options\n   */\n  constructor(\n    target: HTMLElement | string,\n    config?: Partial<ScrollSpyOptions>,\n  ) {\n    super(target, config);\n\n    // initialization element & options\n    const { element, options } = this;\n\n    // additional properties\n    this.target = querySelector(\n      options.target as HTMLElement | string,\n      getDocument(element),\n    );\n\n    // invalidate\n    if (this.target) {\n      // set initial state\n      this.scrollTarget = element.clientHeight < element.scrollHeight\n        ? element\n        : getDocumentElement(element);\n      this.scrollHeight = getScrollHeight(this.scrollTarget);\n\n      // run an initial burst, we need to know the targets\n      this.refresh();\n\n      // create observer\n      this._observer = new PositionObserver(() => this.refresh(), {\n        root: this.scrollTarget,\n      });\n\n      // add event handlers\n      toggleObservers(this, true);\n    }\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return scrollspyComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return scrollspyDefaults;\n  }\n  /* eslint-enable */\n\n  // SCROLLSPY PUBLIC METHODS\n  // ========================\n  /** Updates all items. */\n  refresh = () => {\n    const { target } = this;\n\n    // check if target is visible and invalidate\n    // istanbul ignore else @preserve\n    if (isHTMLElement(target) && target.offsetHeight > 0) {\n      updateSpyTargets(this);\n\n      const { scrollTop, maxScroll, itemsLength, items, activeItem } = this;\n\n      if (scrollTop >= maxScroll) {\n        const newActiveItem = items[itemsLength - 1];\n\n        // istanbul ignore else @preserve\n        if (activeItem !== newActiveItem) {\n          activate(this, newActiveItem);\n        }\n        return;\n      }\n\n      const { offsets } = this;\n\n      // istanbul ignore else @preserve\n      if (activeItem && scrollTop < offsets[0] && offsets[0] > 0) {\n        this.activeItem = null;\n        // istanbul ignore else @preserve\n        if (target) clear(target);\n        return;\n      }\n\n      items.forEach((item, i) => {\n        if (\n          activeItem !== item &&\n          scrollTop >= offsets[i] &&\n          (typeof offsets[i + 1] === \"undefined\" || scrollTop < offsets[i + 1])\n        ) {\n          activate(this, item);\n        }\n      });\n    }\n  };\n\n  /** Removes `ScrollSpy` from the target element. */\n  dispose() {\n    const clone = { ...this };\n    toggleObservers(clone);\n    super.dispose();\n  }\n}\n","/** @type {string} */\nconst tabString = \"tab\";\nexport default tabString;\n","/** @type {string} */\nconst tabComponent = \"Tab\";\nexport default tabComponent;\n","/* Native JavaScript for Bootstrap 5 | Tab\n------------------------------------------ */\nimport {\n  addClass,\n  ariaSelected,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  emulateTransitionEnd,\n  getElementsByClassName,\n  getInstance,\n  hasClass,\n  isHTMLElement,\n  mouseclickEvent,\n  querySelector,\n  reflow,\n  removeClass,\n  setAttribute,\n  Timer,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport collapsingClass from \"../strings/collapsingClass\";\nimport activeClass from \"../strings/activeClass\";\nimport fadeClass from \"../strings/fadeClass\";\nimport showClass from \"../strings/showClass\";\nimport dropdownClasses from \"../strings/dropdownClasses\";\nimport dataBsToggle from \"../strings/dataBsToggle\";\nimport tabString from \"../strings/tabString\";\nimport tabComponent from \"../strings/tabComponent\";\n\nimport getTargetElement from \"../util/getTargetElement\";\nimport BaseComponent from \"./base-component\";\nimport type { /* TabOptions, */ TabEvent } from \"../interface/tab\";\n\n// TAB PRIVATE GC\n// ================\nconst tabSelector = `[${dataBsToggle}=\"${tabString}\"]`;\n\n/**\n * Static method which returns an existing `Tab` instance associated\n * to a target `Element`.\n */\nconst getTabInstance = (element: HTMLElement) =>\n  getInstance<Tab>(element, tabComponent);\n\n/** A `Tab` initialization callback. */\nconst tabInitCallback = (element: HTMLElement) => new Tab(element);\n\ntype TabEventProps = {\n  relatedTarget: HTMLElement | undefined;\n};\n\n// TAB CUSTOM EVENTS\n// =================\nconst showTabEvent = createCustomEvent<TabEventProps, TabEvent>(\n  `show.bs.${tabString}`,\n);\nconst shownTabEvent = createCustomEvent<TabEventProps, TabEvent>(\n  `shown.bs.${tabString}`,\n);\nconst hideTabEvent = createCustomEvent<TabEventProps, TabEvent>(\n  `hide.bs.${tabString}`,\n);\nconst hiddenTabEvent = createCustomEvent<TabEventProps, TabEvent>(\n  `hidden.bs.${tabString}`,\n);\n\ninterface TabPrivate {\n  tab: HTMLElement | null;\n  content: HTMLElement | null;\n  currentHeight: number;\n  nextHeight: number;\n}\n\n/**\n * Stores the current active tab and its content\n * for a given `.nav` element.\n */\nconst tabPrivate: Map<HTMLElement, TabPrivate> = new Map();\n\n// TAB PRIVATE METHODS\n// ===================\n/**\n * Executes after tab transition has finished.\n *\n * @param self the `Tab` instance\n */\nconst triggerTabEnd = (self: Tab) => {\n  const { tabContent, nav } = self;\n\n  // istanbul ignore else @preserve\n  if (tabContent && hasClass(tabContent, collapsingClass)) {\n    tabContent.style.height = \"\";\n    removeClass(tabContent, collapsingClass);\n  }\n\n  // istanbul ignore else @preserve\n  if (nav) Timer.clear(nav);\n};\n\n/**\n * Executes before showing the tab content.\n *\n * @param self the `Tab` instance\n */\nconst triggerTabShow = (self: Tab) => {\n  const { element, tabContent, content: nextContent, nav } = self;\n  const { tab } = (isHTMLElement(nav) && tabPrivate.get(nav)) ||\n    // istanbul ignore next @preserve\n    { tab: null };\n\n  // istanbul ignore else @preserve\n  if (tabContent && nextContent && hasClass(nextContent, fadeClass)) {\n    const { currentHeight, nextHeight } = tabPrivate.get(element) ||\n      // istanbul ignore next @preserve\n      { currentHeight: 0, nextHeight: 0 };\n    // istanbul ignore else @preserve: vitest won't validate this branch\n    if (currentHeight !== nextHeight) {\n      // enables height animation\n      setTimeout(() => {\n        tabContent.style.height = `${nextHeight}px`;\n        reflow(tabContent);\n        emulateTransitionEnd(tabContent, () => triggerTabEnd(self));\n      }, 50);\n    } else {\n      triggerTabEnd(self);\n    }\n  } else if (nav) Timer.clear(nav);\n\n  shownTabEvent.relatedTarget = tab as HTMLElement | undefined;\n\n  dispatchEvent(element, shownTabEvent);\n};\n\n/**\n * Executes before hiding the tab.\n *\n * @param self the `Tab` instance\n */\nconst triggerTabHide = (self: Tab) => {\n  const { element, content: nextContent, tabContent, nav } = self;\n  const { tab, content } = (nav && tabPrivate.get(nav)) ||\n    // istanbul ignore next @preserve\n    { tab: null, content: null };\n  let currentHeight = 0;\n\n  // istanbul ignore else @preserve\n  if (tabContent && nextContent && hasClass(nextContent, fadeClass)) {\n    [content, nextContent].forEach((c) => {\n      // istanbul ignore else @preserve\n      if (isHTMLElement(c)) addClass(c, \"overflow-hidden\");\n    });\n    currentHeight = isHTMLElement(content)\n      ? content.scrollHeight // istanbul ignore next @preserve\n      : 0;\n  }\n\n  // update relatedTarget and dispatch event\n  showTabEvent.relatedTarget = tab as HTMLElement | undefined;\n  hiddenTabEvent.relatedTarget = element;\n  dispatchEvent(element, showTabEvent);\n\n  // istanbul ignore else @preserve\n  if (!showTabEvent.defaultPrevented) {\n    // istanbul ignore else @preserve\n    if (nextContent) addClass(nextContent, activeClass);\n    // istanbul ignore else @preserve\n    if (content) removeClass(content, activeClass);\n\n    // istanbul ignore else @preserve\n    if (tabContent && nextContent && hasClass(nextContent, fadeClass)) {\n      const nextHeight = nextContent.scrollHeight;\n      tabPrivate.set(element, {\n        currentHeight,\n        nextHeight,\n        tab: null,\n        content: null,\n      });\n\n      addClass(tabContent, collapsingClass);\n      tabContent.style.height = `${currentHeight}px`;\n      reflow(tabContent);\n      [content, nextContent].forEach((c) => {\n        // istanbul ignore else @preserve\n        if (c) removeClass(c, \"overflow-hidden\");\n      });\n    }\n\n    if (nextContent && nextContent && hasClass(nextContent, fadeClass)) {\n      setTimeout(() => {\n        addClass(nextContent, showClass);\n        emulateTransitionEnd(nextContent, () => {\n          triggerTabShow(self);\n        });\n      }, 1);\n    } else {\n      // istanbul ignore else @preserve\n      if (nextContent) addClass(nextContent, showClass);\n      triggerTabShow(self);\n    }\n\n    // istanbul ignore else @preserve\n    if (tab) dispatchEvent(tab, hiddenTabEvent);\n  }\n};\n\n/**\n * Returns the current active tab and its target content.\n *\n * @param self the `Tab` instance\n * @returns the query result\n */\nconst getActiveTab = (\n  self: Tab,\n): { tab: HTMLElement | null; content: HTMLElement | null } => {\n  const { nav } = self;\n  // istanbul ignore next @preserve\n  if (!isHTMLElement(nav as HTMLElement | undefined)) {\n    return { tab: null, content: null };\n  }\n\n  const activeTabs = getElementsByClassName(activeClass, nav as HTMLElement);\n  let tab: HTMLElement | null = null;\n  // istanbul ignore else @preserve\n  if (\n    activeTabs.length === 1 &&\n    !dropdownClasses.some((c) =>\n      hasClass(activeTabs[0].parentElement as HTMLElement, c)\n    )\n  ) {\n    [tab] = activeTabs;\n  } else if (activeTabs.length > 1) {\n    tab = activeTabs[activeTabs.length - 1];\n  }\n  const content = isHTMLElement(tab as HTMLElement)\n    ? getTargetElement(tab as HTMLElement)\n    : null;\n  return { tab, content };\n};\n\n/**\n * Returns a parent dropdown.\n *\n * @param element the `Tab` element\n * @returns the parent dropdown\n */\nconst getParentDropdown = (element?: HTMLElement): HTMLElement | null => {\n  // istanbul ignore next @preserve\n  if (!isHTMLElement(element)) return null;\n  const dropdown = closest(element, `.${dropdownClasses.join(\",.\")}`);\n  return dropdown\n    ? querySelector(`.${dropdownClasses[0]}-toggle`, dropdown)\n    : null;\n};\n\n// TAB EVENT HANDLER\n// =================\n/**\n * Handles the `click` event listener.\n *\n * @param e the `Event` object\n */\nconst tabClickHandler = (e: Event) => {\n  const self = getTabInstance(e.target as HTMLElement);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    e.preventDefault();\n    self.show();\n  }\n};\n\n// TAB DEFINITION\n// ==============\n/** Creates a new `Tab` instance. */\nexport default class Tab extends BaseComponent {\n  static selector = tabSelector;\n  static init = tabInitCallback;\n  static getInstance = getTabInstance;\n  declare nav: HTMLElement | null;\n  declare content: HTMLElement | null;\n  declare tabContent: HTMLElement | null;\n  declare nextContent: HTMLElement | null;\n  declare dropdown: HTMLElement | null;\n\n  /** @param target the target element */\n  constructor(target: HTMLElement | string) {\n    super(target);\n\n    // initialization element\n    const { element } = this;\n    const content = getTargetElement(element);\n\n    // no point initializing a tab without a corresponding content\n    // istanbul ignore else @preserve\n    if (content) {\n      const nav = closest(element, \".nav\");\n      const container = closest(content, \".tab-content\");\n\n      this.nav = nav;\n      this.content = content;\n      this.tabContent = container;\n\n      // event targets\n      this.dropdown = getParentDropdown(element);\n\n      // show first Tab instance of none is shown\n      // suggested on #432\n      const { tab } = getActiveTab(this);\n      if (nav && !tab) {\n        const firstTab = querySelector(tabSelector, nav);\n        const firstTabContent = firstTab && getTargetElement(firstTab);\n\n        // istanbul ignore else @preserve\n        if (firstTabContent) {\n          addClass(firstTab, activeClass);\n          addClass(firstTabContent, showClass);\n          addClass(firstTabContent, activeClass);\n          setAttribute(element, ariaSelected, \"true\");\n        }\n      }\n\n      // add event listener\n      this._toggleEventListeners(true);\n    }\n  }\n\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return tabComponent;\n  }\n\n  // TAB PUBLIC METHODS\n  // ==================\n  /** Shows the tab to the user. */\n  show() {\n    const { element, content: nextContent, nav, dropdown } = this;\n\n    // istanbul ignore else @preserve\n    if (!(nav && Timer.get(nav)) && !hasClass(element, activeClass)) {\n      const { tab, content } = getActiveTab(this);\n\n      // istanbul ignore else @preserve\n      if (nav) {\n        tabPrivate.set(nav, { tab, content, currentHeight: 0, nextHeight: 0 });\n      }\n\n      // update relatedTarget and dispatch\n      hideTabEvent.relatedTarget = element;\n\n      // istanbul ignore else @preserve\n      if (isHTMLElement(tab)) {\n        dispatchEvent(tab as EventTarget, hideTabEvent);\n        // istanbul ignore else @preserve\n        if (!hideTabEvent.defaultPrevented) {\n          addClass(element, activeClass);\n          setAttribute(element, ariaSelected, \"true\");\n\n          const activeDropdown = isHTMLElement(tab) && getParentDropdown(tab);\n          if (activeDropdown && hasClass(activeDropdown, activeClass)) {\n            removeClass(activeDropdown, activeClass);\n          }\n\n          // istanbul ignore else @preserve\n          if (nav) {\n            const toggleTab = () => {\n              // istanbul ignore else @preserve\n              if (tab) {\n                removeClass(tab, activeClass);\n                setAttribute(tab, ariaSelected, \"false\");\n              }\n              if (dropdown && !hasClass(dropdown, activeClass)) {\n                addClass(dropdown, activeClass);\n              }\n            };\n\n            if (\n              content &&\n              (hasClass(content, fadeClass) ||\n                (nextContent && hasClass(nextContent, fadeClass)))\n            ) {\n              Timer.set(nav, toggleTab, 1);\n            } else toggleTab();\n          }\n\n          // istanbul ignore else @preserve\n          if (content) {\n            removeClass(content, showClass);\n            if (hasClass(content, fadeClass)) {\n              emulateTransitionEnd(content, () => triggerTabHide(this));\n            } else {\n              triggerTabHide(this);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Toggles on/off the `click` event listener.\n   *\n   * @param add when `true`, event listener is added\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    action(this.element, mouseclickEvent, tabClickHandler);\n  };\n\n  /** Removes the `Tab` component from the target element. */\n  dispose() {\n    this._toggleEventListeners();\n    super.dispose();\n  }\n}\n","/** @type {string} */\nconst toastString = \"toast\";\nexport default toastString;\n","/** @type {string} */\nconst toastComponent = \"Toast\";\nexport default toastComponent;\n","/* Native JavaScript for Bootstrap 5 | Toast\n-------------------------------------------- */\nimport {\n  addClass,\n  closest,\n  createCustomEvent,\n  dispatchEvent,\n  emulateTransitionEnd,\n  focusinEvent,\n  focusoutEvent,\n  getDocument,\n  getInstance,\n  hasClass,\n  mouseclickEvent,\n  mouseenterEvent,\n  mouseleaveEvent,\n  querySelector,\n  querySelectorAll,\n  reflow,\n  removeClass,\n  Timer,\n} from \"@thednp/shorty\";\n\nimport { addListener, removeListener } from \"@thednp/event-listener\";\n\nimport fadeClass from \"../strings/fadeClass\";\nimport showClass from \"../strings/showClass\";\nimport dataBsDismiss from \"../strings/dataBsDismiss\";\nimport dataBsToggle from \"../strings/dataBsToggle\";\nimport toastString from \"../strings/toastString\";\nimport toastComponent from \"../strings/toastComponent\";\nimport getTargetElement from \"../util/getTargetElement\";\nimport BaseComponent from \"./base-component\";\nimport { ToastEvent, ToastOptions } from \"../interface/toast\";\n\n// TOAST PRIVATE GC\n// ================\nconst toastSelector = `.${toastString}`;\nconst toastDismissSelector = `[${dataBsDismiss}=\"${toastString}\"]`;\nconst toastToggleSelector = `[${dataBsToggle}=\"${toastString}\"]`;\nconst showingClass = \"showing\";\n/** @deprecated */\nconst hideClass = \"hide\";\n\nconst toastDefaults = {\n  animation: true,\n  autohide: true,\n  delay: 5000,\n};\n\n/**\n * Static method which returns an existing `Toast` instance associated\n * to a target `Element`.\n */\nconst getToastInstance = (element: HTMLElement) =>\n  getInstance<Toast>(element, toastComponent);\n\n/**\n * A `Toast` initialization callback.\n */\nconst toastInitCallback = (element: HTMLElement) => new Toast(element);\n\n// TOAST CUSTOM EVENTS\n// ===================\nconst showToastEvent = createCustomEvent<Record<string, never>, ToastEvent>(\n  `show.bs.${toastString}`,\n);\nconst shownToastEvent = createCustomEvent<Record<string, never>, ToastEvent>(\n  `shown.bs.${toastString}`,\n);\nconst hideToastEvent = createCustomEvent<Record<string, never>, ToastEvent>(\n  `hide.bs.${toastString}`,\n);\nconst hiddenToastEvent = createCustomEvent<Record<string, never>, ToastEvent>(\n  `hidden.bs.${toastString}`,\n);\n\n// TOAST PRIVATE METHODS\n// =====================\n/**\n * Executes after the toast is shown to the user.\n *\n * @param self the `Toast` instance\n */\nconst showToastComplete = (self: Toast) => {\n  const { element, options } = self;\n  removeClass(element, showingClass);\n  Timer.clear(element, showingClass);\n\n  dispatchEvent(element, shownToastEvent);\n  // istanbul ignore else @preserve\n  if (options.autohide) {\n    Timer.set(element, () => self.hide(), options.delay, toastString);\n  }\n};\n\n/**\n * Executes after the toast is hidden to the user.\n *\n * @param self the `Toast` instance\n */\nconst hideToastComplete = (self: Toast) => {\n  const { element } = self;\n  removeClass(element, showingClass);\n  removeClass(element, showClass);\n  addClass(element, hideClass); // B/C\n  Timer.clear(element, toastString);\n  dispatchEvent(element, hiddenToastEvent);\n};\n\n/**\n * Executes before hiding the toast.\n *\n * @param self the `Toast` instance\n */\nconst hideToast = (self: Toast) => {\n  const { element, options } = self;\n  addClass(element, showingClass);\n\n  if (options.animation) {\n    reflow(element);\n    emulateTransitionEnd(element, () => hideToastComplete(self));\n  } else {\n    hideToastComplete(self);\n  }\n};\n\n/**\n * Executes before showing the toast.\n *\n * @param self the `Toast` instance\n */\nconst showToast = (self: Toast) => {\n  const { element, options } = self;\n  Timer.set(\n    element,\n    () => {\n      removeClass(element, hideClass); // B/C\n      reflow(element);\n      addClass(element, showClass);\n      addClass(element, showingClass);\n\n      if (options.animation) {\n        emulateTransitionEnd(element, () => showToastComplete(self));\n      } else {\n        showToastComplete(self);\n      }\n    },\n    17,\n    showingClass,\n  );\n};\n\n// TOAST EVENT HANDLERS\n// ====================\n/**\n * Handles the `click` event listener for toast.\n *\n * @param e the `Event` object\n */\nconst toastClickHandler = (e: Event) => {\n  const { target } = e;\n\n  const trigger = target && closest(target as HTMLElement, toastToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getToastInstance(element);\n\n  // istanbul ignore else @preserve\n  if (self) {\n    // istanbul ignore else @preserve\n    if (trigger && trigger.tagName === \"A\") e.preventDefault();\n    self.relatedTarget = trigger;\n    self.show();\n  }\n};\n\n/**\n * Executes when user interacts with the toast without closing it,\n * usually by hovering or focusing it.\n *\n * @param e the `Toast` instance\n */\nconst interactiveToastHandler = (e: MouseEvent) => {\n  const element = e.target as HTMLElement;\n  const self = getToastInstance(element);\n  const { type, relatedTarget } = e;\n\n  // istanbul ignore else @preserve: a solid filter is required\n  if (\n    self && element !== relatedTarget &&\n    !element.contains(relatedTarget as Node)\n  ) {\n    if ([mouseenterEvent, focusinEvent].includes(type)) {\n      Timer.clear(element, toastString);\n    } else {\n      Timer.set(element, () => self.hide(), self.options.delay, toastString);\n    }\n  }\n};\n\n// TOAST DEFINITION\n// ================\n/** Creates a new `Toast` instance. */\nexport default class Toast extends BaseComponent {\n  static selector = toastSelector;\n  static init = toastInitCallback;\n  static getInstance = getToastInstance;\n  declare options: ToastOptions;\n  declare dismiss: HTMLElement | null;\n  declare triggers: HTMLElement[];\n  declare relatedTarget: HTMLElement | null;\n\n  /**\n   * @param target the target `.toast` element\n   * @param config the instance options\n   */\n  constructor(target: HTMLElement | string, config?: Partial<ToastOptions>) {\n    super(target, config);\n    const { element, options } = this;\n\n    // set fadeClass, the options.animation will override the markup\n    if (options.animation && !hasClass(element, fadeClass)) {\n      addClass(element, fadeClass);\n    } else if (!options.animation && hasClass(element, fadeClass)) {\n      removeClass(element, fadeClass);\n    }\n\n    // dismiss button\n    this.dismiss = querySelector(toastDismissSelector, element);\n\n    // toast can have multiple triggering elements\n    this.triggers = [\n      ...querySelectorAll(toastToggleSelector, getDocument(element)),\n    ].filter(\n      (btn) => getTargetElement(btn) === element,\n    );\n\n    // add event listener\n    this._toggleEventListeners(true);\n  }\n  /**\n   * Returns component name string.\n   */\n  get name() {\n    return toastComponent;\n  }\n  /**\n   * Returns component default options.\n   */\n  get defaults() {\n    return toastDefaults;\n  }\n  /**\n   * Returns *true* when toast is visible.\n   */\n  get isShown() {\n    return hasClass(this.element, showClass);\n  }\n\n  // TOAST PUBLIC METHODS\n  // ====================\n  /** Shows the toast. */\n  show = () => {\n    const { element, isShown } = this;\n\n    // istanbul ignore else @preserve\n    if (element && !isShown) {\n      dispatchEvent(element, showToastEvent);\n      if (!showToastEvent.defaultPrevented) {\n        showToast(this);\n      }\n    }\n  };\n\n  /** Hides the toast. */\n  hide = () => {\n    const { element, isShown } = this;\n\n    // istanbul ignore else @preserve\n    if (element && isShown) {\n      dispatchEvent(element, hideToastEvent);\n      if (!hideToastEvent.defaultPrevented) {\n        hideToast(this);\n      }\n    }\n  };\n\n  /**\n   * Toggles on/off the `click` event listener.\n   *\n   * @param add when `true`, it will add the listener\n   */\n  _toggleEventListeners = (add?: boolean) => {\n    const action = add ? addListener : removeListener;\n    const { element, triggers, dismiss, options, hide } = this;\n\n    // istanbul ignore else @preserve\n    if (dismiss) {\n      action(dismiss, mouseclickEvent, hide);\n    }\n\n    // istanbul ignore else @preserve\n    if (options.autohide) {\n      [focusinEvent, focusoutEvent, mouseenterEvent, mouseleaveEvent].forEach(\n        (e) => action(element, e, interactiveToastHandler),\n      );\n    }\n    // istanbul ignore else @preserve\n    if (triggers.length) {\n      triggers.forEach((btn) =>\n        action(btn, mouseclickEvent, toastClickHandler)\n      );\n    }\n  };\n\n  /** Removes the `Toast` component from the target element. */\n  dispose() {\n    const { element, isShown } = this;\n    this._toggleEventListeners();\n    Timer.clear(element, toastString);\n\n    if (isShown) {\n      removeClass(element, showClass);\n    }\n    super.dispose();\n  }\n}\n","import { Data, getElementsByTagName, matches } from \"@thednp/shorty\";\n\nimport { addListener } from \"@thednp/event-listener\";\n\nimport Alert from \"../components/alert\";\nimport Button from \"../components/button\";\nimport Carousel from \"../components/carousel\";\nimport Collapse from \"../components/collapse\";\nimport Dropdown from \"../components/dropdown\";\nimport Modal from \"../components/modal\";\nimport Offcanvas from \"../components/offcanvas\";\nimport Popover from \"../components/popover\";\nimport ScrollSpy from \"../components/scrollspy\";\nimport Tab from \"../components/tab\";\nimport Toast from \"../components/toast\";\nimport Tooltip from \"../components/tooltip\";\n\nconst componentsList = new Map<\n  string,\n  | typeof Alert\n  | typeof Button\n  | typeof Carousel\n  | typeof Collapse\n  | typeof Dropdown\n  | typeof Modal\n  | typeof Offcanvas\n  | typeof Popover\n  | typeof ScrollSpy\n  | typeof Tab\n  | typeof Toast\n  | typeof Tooltip\n>();\n\ntype Component =\n  | Alert\n  | Button\n  | Carousel\n  | Collapse\n  | Dropdown\n  | Modal\n  | Offcanvas\n  | Popover\n  | ScrollSpy\n  | Tab\n  | Toast\n  | Tooltip;\n\n[\n  Alert,\n  Button,\n  Carousel,\n  Collapse,\n  Dropdown,\n  Modal,\n  Offcanvas,\n  Popover,\n  ScrollSpy,\n  Tab,\n  Toast,\n  Tooltip,\n].forEach((c) => componentsList.set(c.prototype.name, c));\n\n/**\n * Initialize all matched `Element`s for one component.\n *\n * @param callback\n * @param collection\n */\nconst initComponentDataAPI = (\n  callback: (el: HTMLElement) => Component,\n  collection: HTMLCollectionOf<HTMLElement> | HTMLElement[],\n) => {\n  [...collection].forEach((x) => callback(x));\n};\n\n/**\n * Remove one component from a target container element or all in the page.\n *\n * @param component the component name\n * @param context parent `Node`\n */\nconst removeComponentDataAPI = <T>(component: string, context: ParentNode) => {\n  const compData = Data.getAllFor(component) as Map<HTMLElement, T>;\n\n  if (compData) {\n    [...compData].forEach(([element, instance]) => {\n      if (context.contains(element)) {\n        (instance as T & { dispose: () => void }).dispose();\n      }\n    });\n  }\n};\n\n/**\n * Initialize all BSN components for a target container.\n *\n * @param context parent `Node`\n */\nexport const initCallback = (context?: ParentNode) => {\n  const lookUp = context && context.nodeName ? context : document;\n  const elemCollection = [...getElementsByTagName(\"*\", lookUp)];\n\n  componentsList.forEach((cs) => {\n    const { init, selector } = cs;\n    initComponentDataAPI(\n      init,\n      elemCollection.filter((item) => matches(item, selector)),\n    );\n  });\n};\n\n/**\n * Remove all BSN components for a target container.\n *\n * @param context parent `Node`\n */\nexport const removeDataAPI = (context?: ParentNode) => {\n  const lookUp = context && context.nodeName ? context : document;\n\n  componentsList.forEach((comp) => {\n    removeComponentDataAPI(comp.prototype.name, lookUp);\n  });\n};\n\n// Bulk initialize all components\nif (document.body) initCallback();\nelse {\n  addListener(document, \"DOMContentLoaded\", () => initCallback(), {\n    once: true,\n  });\n}\n"],"names":["x","e","k","addListener","removeListener","dropdownClasses","p","r","f","PositionObserver"],"mappings":"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","x_google_ignoreList":[0,1,52]}